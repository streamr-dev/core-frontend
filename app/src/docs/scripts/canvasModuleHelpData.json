[
  {
    "id": 30,
    "name": "And",
    "path": "Boolean",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Implements the boolean AND operation: outputs 1 if <span class='highlight'>both</span> inputs equal 1, otherwise outputs 0.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 1003,
    "name": "BooleanConstant",
    "path": "Boolean",
    "help": {
      "helpText": "This module represents a constant boolean value i.e. true|false, that can be connected to any boolean input. The input will have that value during the whole execution."
    }
  },
  {
    "id": 1002,
    "name": "BooleanToNumber",
    "path": "Boolean",
    "help": {
      "helpText": "Converts `false` to `0` and `true` to `1`."
    }
  },
  {
    "id": 45,
    "name": "Equals",
    "path": "Boolean",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Outputs 1 if the inputs are equal within the specified <span class='highlight'>tolerance</span>, that is, if abs(A-B)&nbsp;&le;&nbsp;tolerance. Otherwise outputs 0.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 46,
    "name": "GreaterThan",
    "path": "Boolean",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Outputs 1 if <span class='highlight'>A</span> is greater than <span class='highlight'>B</span> (A&gt;B). If <span class='highlight'>equality</span> is set to true, outputs 1 if A&ge;B. Otherwise outputs 0.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 48,
    "name": "IfThenElse",
    "path": "Boolean",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>If the value at the <span class='highlight'>if</span> input is 1, then outputs the value present at the <span class='highlight'>then</span> input. Otherwise outputs the value at <span class='highlight'>else</span> input.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 47,
    "name": "LessThan",
    "path": "Boolean",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Outputs 1 if <span class='highlight'>A</span> is less than <span class='highlight'>B</span> (A&lt;B). If <span class='highlight'>equality</span> is set to true, outputs 1 if A&le;B. Otherwise outputs 0.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 32,
    "name": "Not",
    "path": "Boolean",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Implements the boolean NOT operation: outputs 0 if the input equals 1, otherwise outputs 1.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 31,
    "name": "Or",
    "path": "Boolean",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Implements the boolean OR operation: outputs 1 if <span class='highlight'>at least one</span> of the inputs equal 1, otherwise outputs 0.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 33,
    "name": "SameSign",
    "path": "Boolean",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Outputs 0 unless both inputs have the same sign. If both inputs are positive, the output is 1. If both are negative, the output is -1.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 573,
    "name": "Xor",
    "path": "Boolean",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Implements the boolean XOR operation: outputs true&nbsp;if <span class=\"highlight\">one</span> of the inputs equal true, otherwise outputs false.</p>"
    }
  },
  {
    "id": 136,
    "name": "JavaModule",
    "path": "Custom Modules",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>This module allows you to implement custom functionality by writing code in the Java programming language directly in your browser.\n</p><p>\nClick the <span class='highlight'>Edit code</span> button to open the code editor. The code you write will be dynamically compiled and executed.\n</p><p>\nSee the User Guide for more information on programmable modules.</p>"
    }
  },
  {
    "id": 218,
    "name": "Button",
    "path": "Input",
    "help": {
      "params": {
        "buttonName": "The name which the button gets",
        "outputValue": "Value which is outputted when the button is clicked"
      },
      "paramNames": [
        "buttonName",
        "outputValue"
      ],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>The button module outputs the given value everytime the button is pressed. Module can be used any time, even during a run.</p>"
    }
  },
  {
    "id": 219,
    "name": "Switcher",
    "path": "Input",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>The module ouputs even 1 or 0 depending of the value of the switcher. The value can be changed during a run.</p>"
    }
  },
  {
    "id": 220,
    "name": "TextField",
    "path": "Input",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>The module outputs the value of the text field every time &#39;send&#39; is pressed.</p>"
    }
  },
  {
    "id": 1001,
    "name": "HTTP Request",
    "path": "Integrations",
    "help": {
      "helpText": "This module sends inputs as HTTP request to given URL, and returns server response. Headers, query params and body should be Maps. Body can also be List or String. Request body format can be changed in Options. Default is JSON. Server is expected to return JSON formatted documents. HTTP Request is asynchronous by default. Synchronized requests block the execution of the whole canvas until they receive the server response, but otherwise they work just like any other module; asynchronous requests on the other hand work like streams in that they activate modules they're connected to only when they receive data from the server. If a data path branches, and one branch passes through the HTTP Request module and another around it, if they also converge in a module, that latter module may experience multiple activations due to asynchronicity. This also means that server responses may arrive in different order than they were sent. If this kind of behaviour causes problems, you can try to fix it by changing sync mode to synchronized in Options. However, data throughput WILL be lower, and external servers may freeze your canvas simply by responding very slowly or not at all. For simple data paths and somewhat stable response times, the two sync modes will yield precisely the same results."
    }
  },
  {
    "id": 1034,
    "name": "MQTT",
    "path": "Integrations",
    "help": {
      "params": {
        "URL": "URL of MQTT broker to listen to",
        "topic": "MQTT topic",
        "username": "MQTT username (optional)",
        "password": "MQTT password (optional)",
        "certType": "MQTT certificate type"
      },
      "paramNames": [
        "URL",
        "topic",
        "username",
        "password",
        "certType"
      ],
      "inputs": {},
      "inputNames": [],
      "outputs": {
        "message": "MQTT message string"
      },
      "outputNames": [
        "message"
      ],
      "helpText": "<p>Listen to MQTT messages, output them as strings. If message is JSON, a JsonParser module can be used to transform the string into a map, and GetMultiFromMap module to extract values from the map.</p><h2>Examples:</h2><h3>Connecting to MQTT service without certificate</h3><p>Give URL address as</p><pre>mqtt://service.com</pre><p>or</p><pre>tcp://service.com</pre><p>Add topic and username and password if needed.</p><h3>Connecting to MQTT with certificate</h3><p>Give URL address as</p><pre>ssl://service.com</pre><p>Add topic and username and password if needed.</p><p>Select certificate type to be .crt and paste your certificate to text area.</p>"
    }
  },
  {
    "id": 1000,
    "name": "Simple HTTP",
    "path": "Integrations",
    "help": {
      "helpText": "There is no documentation for this module at this time.",
      "code": "FORBIDDEN",
      "resource": "ModulePackage",
      "fault": "operation",
      "id": "5",
      "message": "Non-authenticated user does not have permission to read ModulePackage (id 5)",
      "user": "<not authenticated>",
      "operation": "read"
    }
  },
  {
    "id": 1010,
    "name": "SQL",
    "path": "Integrations",
    "help": {
      "params": {
        "engine": "Database engine, e.g. MySQL",
        "host": "Database server to connect",
        "database": "Name of the database",
        "username": "Login username",
        "password": "Login password"
      },
      "paramNames": [
        "engine",
        "host",
        "database",
        "username",
        "password"
      ],
      "inputs": {
        "sql": "SQL command to be executed"
      },
      "inputNames": [
        "sql"
      ],
      "outputs": {
        "errors": "List of error strings",
        "result": "List of rows returned by the database"
      },
      "outputNames": [
        "errors",
        "result"
      ],
      "helpText": "<p>The result is a list of map objects, e.g. <i>[{&quot;id&quot;:0, &quot;name&quot;:&quot;Me&quot;}, {&quot;id&quot;:1, &quot;name&quot;:&quot;You&quot;}]</i></p>"
    }
  },
  {
    "id": 1101,
    "name": "BinaryBetting",
    "path": "Integrations: Ethereum",
    "help": {
      "helpText": "BinaryBetting Ethereum contract"
    }
  },
  {
    "id": 1150,
    "name": "EthereumCall",
    "path": "Integrations: Ethereum",
    "help": {
      "params": {
        "ethAccount": "The account used to make transaction or call",
        "function": "The contract function to invoke"
      },
      "paramNames": [
        "ethAccount",
        "function"
      ],
      "inputs": {
        "contract": "Ethereum contract",
        "trigger": "Send call (for functions that have no inputs)",
        "ether": "ETH to send with the function call (for <i>payable</i> functions)"
      },
      "inputNames": [
        "contract",
        "trigger",
        "ether"
      ],
      "outputs": {
        "errors": "List of error messages"
      },
      "outputNames": [
        "errors"
      ],
      "helpText": "<p>Call Ethereum smart contract.</p><p>First, connect Ethereum contract into <strong>contract</strong>&nbsp;input. You can write your own using SolidityModule, or pick a template such as PayByUse.</p><p>Second, choose the <strong>function</strong> you want to call from the dropdown. There are two kinds of functions calls:</p><ul><li>constant function calls that return results directly, and</li><li>transactions that return values through events that the function call invokes.</li></ul><p>The contract must be deployed before this module can activate.</p>"
    }
  },
  {
    "id": 1023,
    "name": "GetContractAt",
    "path": "Integrations: Ethereum",
    "help": {
      "helpText": "Ethereum contract that has been deployed in the blockchain"
    }
  },
  {
    "id": 1032,
    "name": "GetEvents",
    "path": "Integrations: Ethereum",
    "help": {
      "helpText": "Get events sent out by given contract in the given transaction"
    }
  },
  {
    "id": 1100,
    "name": "PayByUse",
    "path": "Integrations: Ethereum",
    "help": {
      "helpText": "PayByUse Ethereum contract"
    }
  },
  {
    "id": 1151,
    "name": "SolidityCompileDeploy",
    "path": "Integrations: Ethereum",
    "help": {
      "params": {
        "ethAccount": "The account used to deploy contract",
        "initial ETH": "initial ETH amount to be deployed with contract"
      },
      "paramNames": [
        "ethAccount",
        "initial ETH"
      ],
      "inputs": {},
      "inputNames": [],
      "outputs": {
        "contract": "Ethereum contract"
      },
      "outputNames": [
        "contract"
      ],
      "helpText": "<p>Compile and deploy Ethereum smart contract. Edit the code in text window, close window and then contract will be compiled. Enter constructor args and initial ETH (if applicable) and press deploy. Deployed address will be displayed in bottom text field.  You can connect the contract output to SendEthereumTransaction module.</p>"
    }
  },
  {
    "id": 574,
    "name": "VerifySignature",
    "path": "Integrations: Ethereum",
    "help": {
      "helpText": "Given message and signature get Ethereum address of signee."
    }
  },
  {
    "id": 548,
    "name": "AddToList",
    "path": "List",
    "help": {
      "params": {
        "index": "index to add to, from 0 to length of list"
      },
      "paramNames": [
        "index"
      ],
      "inputs": {
        "item": "item to add to list",
        "list": "the list to add to"
      },
      "inputNames": [
        "item",
        "list"
      ],
      "outputs": {
        "error": "error string if given invalid index",
        "list": "the result if operation successful"
      },
      "outputNames": [
        "error",
        "list"
      ],
      "helpText": "<p>Insert an item into&nbsp;an arbitrary position of a List. Unless adding to the very end of a list,&nbsp;items starting from&nbsp;<em>index </em>are&nbsp;all shifted to the right to allow insertion of new item.</p>"
    }
  },
  {
    "id": 549,
    "name": "AppendToList",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "item": "item to append",
        "list": "list to append to"
      },
      "inputNames": [
        "item",
        "list"
      ],
      "outputs": {
        "list": "resulting list"
      },
      "outputNames": [
        "list"
      ],
      "helpText": "<p>Append an item to the end of a List.</p>"
    }
  },
  {
    "id": 550,
    "name": "BuildList",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Build a fixed-sized list from values at inputs.</p>"
    }
  },
  {
    "id": 802,
    "name": "ConstantList",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>This module allows you to manually enter a constant List object.</p>\n"
    }
  },
  {
    "id": 551,
    "name": "ContainsItem",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "item": "item to look for",
        "list": "list to look from"
      },
      "inputNames": [
        "item",
        "list"
      ],
      "outputs": {
        "found": "true if found; false otherwise"
      },
      "outputNames": [
        "found"
      ],
      "helpText": "<p>Checks whether a list contains an item.</p>"
    }
  },
  {
    "id": 552,
    "name": "FlattenList",
    "path": "List",
    "help": {
      "params": {
        "deep": "whether to flatten recursively"
      },
      "paramNames": [
        "deep"
      ],
      "inputs": {
        "in": "input list"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "flattened list"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Flattens lists inside a list, e.g. [1, [2,3], [4, 5], 6, [7, 8], 9] -&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9].</p><p>&nbsp;</p><p>If <em>deep&nbsp;= true</em>, flattening will be done recursively. E.g. [1, [2, [3, [4, 5, [6]]], 7], 8, 9] -&gt;&nbsp;[1, 2, 3, 4, 5, 6, 7, 8, 9]. Otherwise only one level of flattening will be perfomed.</p>"
    }
  },
  {
    "id": 539,
    "name": "ForEachItem",
    "path": "List",
    "help": {
      "params": {
        "keepState": "when false, sub-canvas state is cleared after lists have been processed  ",
        "canvas": "the sub-canvas to be executed"
      },
      "paramNames": [
        "keepState",
        "canvas"
      ],
      "inputs": {},
      "inputNames": [],
      "outputs": {
        "numOfItems": "indicates how many times the sub-canvas was executed"
      },
      "outputNames": [
        "numOfItems"
      ],
      "helpText": "<p>Execute a sub-canvas for each item of input lists.</p><p>&nbsp;</p><p>The&nbsp;exported inputs and outputs of sub-canvas <em>canvas</em>&nbsp;appear as list inputs and list outputs. The input lists are iterated element-wise, and the sub-canvas is executed every time a value is available for each input list. If input list sizes vary, the sub-canvas is executed as many times as the&nbsp;smallest list is of size. After the input lists have been iterated through,&nbsp;and the sub-canvas activated accordingly, lists of produced values are sent to output lists.</p><p>&nbsp;</p><p>The output&nbsp;<em>numOfItems</em>&nbsp;indicates how many times the sub-canvas was executed, i.e., the size of the smallest input list.</p><p>&nbsp;</p><p>You may want to look into the module&nbsp;<strong>RepeatItem</strong>&nbsp;when using this module to repeat parameter values etc.</p>"
    }
  },
  {
    "id": 1012,
    "name": "GetFromList",
    "path": "List",
    "help": {
      "params": {
        "index": "Index in the list for the item to be fetched. Negative index counts from end of list."
      },
      "paramNames": [
        "index"
      ],
      "inputs": {
        "in": "List to be indexed"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "Item found at given index",
        "error": "Error message, e.g. <i>List is empty</i>"
      },
      "outputNames": [
        "out",
        "error"
      ],
      "helpText": "<p>Fetch item from a list by index.</p><p>Indexing starts from zero, so the first item has index 0, second has index 1 etc.</p><p>Negative index counts from end of list, so that last item in the list has index -1, second-to-last has index -2 etc.</p>"
    }
  },
  {
    "id": 553,
    "name": "HeadList",
    "path": "List",
    "help": {
      "params": {
        "limit": "the maximum number of items to include"
      },
      "paramNames": [
        "limit"
      ],
      "inputs": {
        "in": "input list"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "a list containing the first items of a list"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Retrieves the first (a maximum of <em>limit</em>)&nbsp;items of a list.</p>"
    }
  },
  {
    "id": 561,
    "name": "IndexesOfItem",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "item": "item to look for",
        "list": "item to look for"
      },
      "inputNames": [
        "item",
        "list"
      ],
      "outputs": {
        "indexes": "list of indexes of occurrences; empty list if none"
      },
      "outputNames": [
        "indexes"
      ],
      "helpText": "<p>Finds indexes of all&nbsp;occurrences of an item in a list.</p>"
    }
  },
  {
    "id": 560,
    "name": "IndexOfItem",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "item": "item to look for",
        "list": "list to look in"
      },
      "inputNames": [
        "item",
        "list"
      ],
      "outputs": {
        "index": "outputs the index of the first occurrence; does not output anything if no occurrences"
      },
      "outputNames": [
        "index"
      ],
      "helpText": "<p>Finds the index of the first occurrence of an item in a list.</p>"
    }
  },
  {
    "id": 541,
    "name": "Indices",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "list": "an input list"
      },
      "inputNames": [
        "list"
      ],
      "outputs": {
        "indices": "a list of indices for the input list",
        "list": "the original input list"
      },
      "outputNames": [
        "indices",
        "list"
      ],
      "helpText": "<p>Generates a list from <strong>[0,n-1]</strong>&nbsp;according to the size <strong>n</strong>&nbsp;of the given input list.&nbsp;</p>"
    }
  },
  {
    "id": 544,
    "name": "ListSize",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "input list"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "size": "number of items in list"
      },
      "outputNames": [
        "size"
      ],
      "helpText": "<p>Determine size of list.</p>"
    }
  },
  {
    "id": 1030,
    "name": "ListToEvents",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "list": "input list"
      },
      "inputNames": [
        "list"
      ],
      "outputs": {
        "item": "input list items one by one as separate events"
      },
      "outputNames": [
        "item"
      ],
      "helpText": "<p>Split input list into separate events. They will be sent out as separate events, one item at a time.</p><p>Each event causes activation of all modules where the output item is sent to.</p>"
    }
  },
  {
    "id": 554,
    "name": "MergeList",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "head": "the first items of the merged list",
        "tail": "the last items of the merged list"
      },
      "inputNames": [
        "head",
        "tail"
      ],
      "outputs": {
        "out": "merged list"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Merge two lists (<em>head + tail)</em> together to form a singe list. Merging is simply done by adding items of&nbsp;<em>tail&nbsp;</em>to the end of&nbsp;<em>head&nbsp;</em>to form a single list.</p>"
    }
  },
  {
    "id": 545,
    "name": "Range",
    "path": "List",
    "help": {
      "params": {
        "from": "start of sequence; included in sequence.",
        "step": "step size to add/subtract; sign is ignored; an empty sequence is produced if set to 0",
        "to": "upper bound of sequence; not necessarily included in sequence"
      },
      "paramNames": [
        "from",
        "step",
        "to"
      ],
      "inputs": {},
      "inputNames": [],
      "outputs": {
        "out": "the generated sequence"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Generates a sequence&nbsp;of numbers increasing/decreasing according to a specified <em>step</em>.</p><p>&nbsp;</p><p>When&nbsp;<em>from &lt; to</em>&nbsp;a growing sequence is produced.&nbsp;Otherwise (<em>from &gt; to)</em>&nbsp;a decreasing sequence is produced. The sign of parameter&nbsp;<em>step</em>&nbsp;is ignored, and&nbsp;is automatically determined&nbsp;by the inequality relation between&nbsp;<em>from&nbsp;</em>and&nbsp;<em>to</em>.</p><p>&nbsp;</p><p>Parameter&nbsp;<em>to</em>&nbsp;acts as an upper bound which means that if sequence generation goes over&nbsp;<em>to</em>, the exceeding values are not included in the sequence. E.g., from=1, to=2, seq=0.3 results in [1, 1.3, 1.6, 1.9], with&nbsp;2.1 notably not included.</p>"
    }
  },
  {
    "id": 555,
    "name": "RemoveFromList",
    "path": "List",
    "help": {
      "params": {
        "index": "position to remove item from"
      },
      "paramNames": [
        "index"
      ],
      "inputs": {
        "in": "list to remove item from"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "the list with the item removed"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Remove an item from a list by index. Given an invalid index, this module simply outputs&nbsp;the original&nbsp;input list.</p>"
    }
  },
  {
    "id": 540,
    "name": "RepeatItem",
    "path": "List",
    "help": {
      "params": {
        "times": "times to repeat the item"
      },
      "paramNames": [
        "times"
      ],
      "inputs": {
        "item": "item to be repeated"
      },
      "inputNames": [
        "item"
      ],
      "outputs": {
        "list": "the produced list"
      },
      "outputNames": [
        "list"
      ],
      "helpText": "<p>Make a list out of an&nbsp;item by repeating it <em>times&nbsp;</em>times.&nbsp;</p>"
    }
  },
  {
    "id": 556,
    "name": "ReverseList",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "list"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "reversed list"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Reverses a list.</p>"
    }
  },
  {
    "id": 565,
    "name": "ShuffleList",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "input list"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "input list randomly ordered"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Shuffle the items of a list.</p>"
    }
  },
  {
    "id": 557,
    "name": "SortList",
    "path": "List",
    "help": {
      "params": {
        "order": "ascending or descending"
      },
      "paramNames": [
        "order"
      ],
      "inputs": {
        "in": "list to sort"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "sorted list"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Sort a list.</p>"
    }
  },
  {
    "id": 546,
    "name": "SubList",
    "path": "List",
    "help": {
      "params": {
        "from": "start position (included)",
        "to": "end position (not included)"
      },
      "paramNames": [
        "from",
        "to"
      ],
      "inputs": {
        "in": "input list"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "error": "error string in case error occurred",
        "out": "extracted sub list if successful"
      },
      "outputNames": [
        "error",
        "out"
      ],
      "helpText": "<p>Extract a sub&nbsp;list from a list.</p><p>&nbsp;</p><p>This&nbsp;module is strict&nbsp;about correct indexing. If given incorrect indices, instead of a sub list being produced,&nbsp;an error will be produced in output <em>error</em>.&nbsp;</p>"
    }
  },
  {
    "id": 558,
    "name": "TailList",
    "path": "List",
    "help": {
      "params": {
        "limit": "the maximum number of items to include"
      },
      "paramNames": [
        "limit"
      ],
      "inputs": {
        "in": "input list"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "a list containing the last items of a list"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p><br />Retrieves the last&nbsp;(a maximum of limit) items of a list.</p>"
    }
  },
  {
    "id": 559,
    "name": "Unique",
    "path": "List",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "list": "list with possible duplicates"
      },
      "inputNames": [
        "list"
      ],
      "outputs": {
        "list": "list without duplicates"
      },
      "outputNames": [
        "list"
      ],
      "helpText": "<p>Removes duplicate items from a list resulting in a list of unique items. The first occurrence of an item is kept&nbsp;and subsequent occurrences removed.</p>"
    }
  },
  {
    "id": 501,
    "name": "BuildMap",
    "path": "Map",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in-1": "default single input, name used as key in Map"
      },
      "inputNames": [
        "in-1"
      ],
      "outputs": {
        "map": "produced map"
      },
      "outputNames": [
        "map"
      ],
      "helpText": "<p>Build a new Map from given inputs. Number of inputs is specified via module options (wrench icon).&nbsp;<strong>The names of input are used as map keys so make sure to change them!</strong></p>"
    }
  },
  {
    "id": 526,
    "name": "CollectFromMaps",
    "path": "Map",
    "help": {
      "params": {
        "selector": "a map property name"
      },
      "paramNames": [
        "selector"
      ],
      "inputs": {
        "listOrMap": "list or map to collect from"
      },
      "inputNames": [
        "listOrMap"
      ],
      "outputs": {
        "listOrMap": "collected list or map"
      },
      "outputNames": [
        "listOrMap"
      ],
      "helpText": "<p>Given a list/map of maps, selects from each an entry according to parameter&nbsp;<em>selector,&nbsp;</em>and then returns a list/map of the collected entry values.</p><p>&nbsp;</p><p>In case a map does not have an entry for <em>selector,&nbsp;</em>or the value is null, that entry will be simply skipped in the resulting output.</p><p>&nbsp;</p><p>Map entry <em>selector</em> supports dot and array notation for selecting from nested maps and lists, e.g. &quot;parents[1].name&quot; would return [&quot;Homer&quot;, &quot;Fred&quot;] for input [{name: &quot;Bart&quot;, parents: [{name: &quot;Marge&quot;}, {name: &quot;Homer&quot;}]}, {name: &quot;Pebbles&quot;, parents: [{name: &quot;Wilma}, {name: &quot;Fred&quot;}]}]</p>"
    }
  },
  {
    "id": 800,
    "name": "ConstantMap",
    "path": "Map",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>This module allows you to enter a constant Map object, which is a set of key-value pairs. It can be connected to any Map input in Streamr - for example, to set headers on the HTTP module.</p>\n"
    }
  },
  {
    "id": 224,
    "name": "ContainsValue",
    "path": "Map",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "a map",
        "value": "a value"
      },
      "inputNames": [
        "in",
        "value"
      ],
      "outputs": {
        "found": "1.0 if found, else 0.0."
      },
      "outputNames": [
        "found"
      ],
      "helpText": "<p>Determine whether a map contains a value.</p>"
    }
  },
  {
    "id": 221,
    "name": "CountByKey",
    "path": "Map",
    "help": {
      "params": {
        "sort": "Whether key-count pairs should be order by count",
        "maxKeyCount": "Maximum number of (sorted) key-count pairs to keep. Everything else will be dropped."
      },
      "paramNames": [
        "sort",
        "maxKeyCount"
      ],
      "inputs": {
        "key": "The (string) key"
      },
      "inputNames": [
        "key"
      ],
      "outputs": {
        "map": "Key-count pairs",
        "valueOfCurrentKey": "The occurrence count of the last key received. "
      },
      "outputNames": [
        "map",
        "valueOfCurrentKey"
      ],
      "helpText": "<p>Keeps count of the occurrences of keys.</p>"
    }
  },
  {
    "id": 525,
    "name": "FilterMap",
    "path": "Map",
    "help": {
      "params": {
        "keys": "if empty, keep all entries. otherwise filter by given keys."
      },
      "paramNames": [
        "keys"
      ],
      "inputs": {
        "in": "map to be filtered"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "filtered map"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Filter incoming maps by retaining entries with specified keys.</p>"
    }
  },
  {
    "id": 223,
    "name": "ForEach",
    "path": "Map",
    "help": {
      "params": {
        "canvas": "The \"sub\" canvas that implements the ForEach-loop \"body\""
      },
      "paramNames": [
        "canvas"
      ],
      "inputs": {
        "key": "Differentiate between canvas"
      },
      "inputNames": [
        "key"
      ],
      "outputs": {
        "map": "The state of outputs of all distinct Canvases by key."
      },
      "outputNames": [
        "map"
      ],
      "helpText": "<p>This module allows you to reuse a Canvas saved into the Archive as a module in your current Canvas.</p><p>A separate Canvas instance will be created for each distinct key, which enables ForEach-like behavior to be implemented. The canvas instances will also retain state as expected.</p><p>Any parameters, inputs or outputs you export will be visible on the module. You can export endpoints by right-clicking on them and selecting \"Toggle export\".</p>"
    }
  },
  {
    "id": 225,
    "name": "GetFromMap",
    "path": "Map",
    "help": {
      "params": {
        "key": "a key"
      },
      "paramNames": [
        "key"
      ],
      "inputs": {
        "in": "a map"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "found": "1.0 if key was present in map, 0.0 otherwise.",
        "out": "the corresponding value if key was found."
      },
      "outputNames": [
        "found",
        "out"
      ],
      "helpText": "<p>Retrieve a value from a map by key.</p>"
    }
  },
  {
    "id": 523,
    "name": "GetMultiFromMap",
    "path": "Map",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "input map"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "founds": "an array indicating for each output with 0 (false) and (1) whether a value was found",
        "out-1": "a (default) value from map, output name is used as key"
      },
      "outputNames": [
        "founds",
        "out-1"
      ],
      "helpText": "<p>Get multiple values&nbsp;from a Map. &nbsp;<strong>The names of outputs are used as map keys so make sure to change them!</strong></p>"
    }
  },
  {
    "id": 226,
    "name": "HeadMap",
    "path": "Map",
    "help": {
      "params": {
        "limit": "the number of entries to fetch"
      },
      "paramNames": [
        "limit"
      ],
      "inputs": {
        "in": "a map"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "a submap of the first entries of map"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Retrieve&nbsp;first (n=limit)&nbsp;entries of a map.</p>"
    }
  },
  {
    "id": 227,
    "name": "KeysToList",
    "path": "Map",
    "help": {
      "params": {
        "limit": "the number of entries to fetch"
      },
      "paramNames": [
        "limit"
      ],
      "inputs": {
        "in": "a map"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "a submap of the first entries of map"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Retrieve&nbsp;first (n=limit)&nbsp;entries of a map.</p>"
    }
  },
  {
    "id": 235,
    "name": "MapSize",
    "path": "Map",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "a map"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "size": "the number of entries"
      },
      "outputNames": [
        "size"
      ],
      "helpText": "<p>Determine the number of entries in a map.</p>"
    }
  },
  {
    "id": 233,
    "name": "MergeMap",
    "path": "Map",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "leftMap": "a map to merge onto",
        "rightMap": "a map to be merged"
      },
      "inputNames": [
        "leftMap",
        "rightMap"
      ],
      "outputs": {
        "out": "the resulting merged map"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Merge&nbsp;<strong>rightMap</strong>&nbsp;onto&nbsp;<strong>leftMap</strong>&nbsp;resulting in a single map. In case of conflicting keys,&nbsp;entries of&nbsp;<strong>rightMap</strong>&nbsp;will replace those of <strong>leftMap</strong>.</p>"
    }
  },
  {
    "id": 232,
    "name": "NewMap",
    "path": "Map",
    "help": {
      "params": {
        "alwaysNew": "When false (defult), same map is sent every time. When true, a new map is sent on each activation."
      },
      "paramNames": [
        "alwaysNew"
      ],
      "inputs": {
        "trigger": "used to activate module"
      },
      "inputNames": [
        "trigger"
      ],
      "outputs": {
        "out": "a map"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Emit a map everytime trigger receives a value.</p>"
    }
  },
  {
    "id": 228,
    "name": "PutToMap",
    "path": "Map",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "key": "key to insert",
        "map": "a map",
        "value": "value to insert"
      },
      "inputNames": [
        "key",
        "map",
        "value"
      ],
      "outputs": {
        "map": "a map with the key-value entry inserted"
      },
      "outputNames": [
        "map"
      ],
      "helpText": "<p>Put a key-value-entry&nbsp;into a map.</p>"
    }
  },
  {
    "id": 234,
    "name": "RemoveFromMap",
    "path": "Map",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "a map",
        "key": "a key"
      },
      "inputNames": [
        "in",
        "key"
      ],
      "outputs": {
        "out": "a map without the removed key"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Remove an entry for a map by key.</p>"
    }
  },
  {
    "id": 229,
    "name": "SortMap",
    "path": "Map",
    "help": {
      "params": {
        "byValue": "when false (default), sorts by key. when true, sorts by value"
      },
      "paramNames": [
        "byValue"
      ],
      "inputs": {
        "in": "a map"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "a sorted map"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Sorts a map.</p>"
    }
  },
  {
    "id": 222,
    "name": "SumByKey",
    "path": "Map",
    "help": {
      "params": {
        "windowLength": "Limit moving window size of sum.",
        "sort": "Whether key-sum pairs should be order by sums",
        "maxKeyCount": "Maximum number of (sorted) key-sum pairs to keep. Everything else will be dropped."
      },
      "paramNames": [
        "windowLength",
        "sort",
        "maxKeyCount"
      ],
      "inputs": {
        "value": "The value to be added to aggregated sum.",
        "key": "The (string) key"
      },
      "inputNames": [
        "value",
        "key"
      ],
      "outputs": {
        "map": "Key-sum pairs",
        "valueOfCurrentKey": "The aggregated sum of the last key received. "
      },
      "outputNames": [
        "map",
        "valueOfCurrentKey"
      ],
      "helpText": "<p>Keeps aggregated sums of received key-value-pairs by key.</p>"
    }
  },
  {
    "id": 230,
    "name": "TailMap",
    "path": "Map",
    "help": {
      "params": {
        "limit": "the number of entries to fetch"
      },
      "paramNames": [
        "limit"
      ],
      "inputs": {
        "in": "a map"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "a submap of the last entries of map"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Retrieve&nbsp;last (n=limit)&nbsp;entries of a map.</p>"
    }
  },
  {
    "id": 231,
    "name": "ValuesToList",
    "path": "Map",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "a map"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "keys": "values as a list"
      },
      "outputNames": [
        "keys"
      ],
      "helpText": "<p>Retrieves the values of a map.</p>"
    }
  },
  {
    "id": 529,
    "name": "CreateStream",
    "path": "Streams",
    "help": {
      "params": {
        "fields": "the fields to be assigned to the stream"
      },
      "paramNames": [
        "fields"
      ],
      "inputs": {
        "name": "name of the stream",
        "description": "human-readable description"
      },
      "inputNames": [
        "name",
        "description"
      ],
      "outputs": {
        "created": "true if stream was created, false if failed to create stream",
        "stream": "the id of the created stream"
      },
      "outputNames": [
        "created",
        "stream"
      ],
      "helpText": "<p>Create a new stream.</p>"
    }
  },
  {
    "id": 1033,
    "name": "GetOrCreateStream",
    "path": "Streams",
    "help": {
      "params": {
        "fields": "the fields to be assigned to the stream if a new stream is created"
      },
      "paramNames": [
        "fields"
      ],
      "inputs": {
        "name": "name of the stream",
        "description": "human-readable description if a new stream is created"
      },
      "inputNames": [
        "name",
        "description"
      ],
      "outputs": {
        "created": "true if stream was created, false if existing stream was found",
        "stream": "the id of the found or created stream"
      },
      "outputNames": [
        "created",
        "stream"
      ],
      "helpText": "<p>Find existing stream by name, or create a new stream if a stream by that name doesn't exist yet. If a stream is found, <i>fields</i> and <i>description</i> inputs are <b>ignored</b>.</p>"
    }
  },
  {
    "id": 528,
    "name": "SearchStream",
    "path": "Streams",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "name": "stream to search for by name, must be exact"
      },
      "inputNames": [
        "name"
      ],
      "outputs": {
        "found": "true if stream was found",
        "stream": "id of stream if found"
      },
      "outputNames": [
        "found",
        "stream"
      ],
      "helpText": "<p>Search for a stream by name</p>"
    }
  },
  {
    "id": 131,
    "name": "Concatenate",
    "path": "Text",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Concatenates (appends) the given strings. For example if input <span class='highlight'>A</span> is \"foo\" and input <span class='highlight'>B</span> is \"bar\", the output is \"foobar\".</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 19,
    "name": "ConstantText",
    "path": "Text",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {},
      "helpText": "<p>This module represents a constant text value that can be connected to any input that accepts text.</p>",
      "inputNames": [],
      "params": {
        "str": "The text constant"
      },
      "outputs": {
        "out": "Outputs the text constant"
      },
      "paramNames": [
        "str"
      ]
    }
  },
  {
    "id": 129,
    "name": "Contains",
    "path": "Text",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Tests whether the input string contains the substring given as the <span class='highlight'>search</span> parameter. If it does, 1 is sent out. Otherwise the output is 0.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 198,
    "name": "EndsWith",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Tests whether the input string ends with the substring given as the&nbsp;search&nbsp;parameter. If it does, 1 is sent out. Otherwise the output is 0.</p>\n"
    }
  },
  {
    "id": 569,
    "name": "FormatNumber",
    "path": "Text",
    "help": {
      "params": {
        "decimalPlaces": "number of decimal places"
      },
      "paramNames": [
        "decimalPlaces"
      ],
      "inputs": {
        "number": "number to format"
      },
      "inputNames": [
        "number"
      ],
      "outputs": {
        "text": "number formatted as string"
      },
      "outputNames": [
        "text"
      ],
      "helpText": "<p>Format a number into a string with a specified number of&nbsp;decimal places.</p>"
    }
  },
  {
    "id": 1016,
    "name": "JsonParser",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "json": "JSON string to parse"
      },
      "inputNames": [
        "json"
      ],
      "outputs": {
        "errors": "List of error strings",
        "result": "Map, List or value that the JSON string represents"
      },
      "outputNames": [
        "errors",
        "result"
      ],
      "helpText": "<p>JSON string should fulfill the <a href='http://json.org/' target='_blank'>JSON specification</a>.</p>"
    }
  },
  {
    "id": 564,
    "name": "RandomString",
    "path": "Text",
    "help": {
      "params": {
        "length": "length of strings to generate"
      },
      "paramNames": [
        "length"
      ],
      "inputs": {
        "trigger": "when value is received, activates module"
      },
      "inputNames": [
        "trigger"
      ],
      "outputs": {
        "out": "the random string"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Generate fixed-length random strings from an equiprobable symbol pool. Allowed symbols can be configured from module settings.</p>"
    }
  },
  {
    "id": 201,
    "name": "Regex",
    "path": "Text",
    "help": {
      "params": {
        "pattern": "Regex pattern"
      },
      "paramNames": [
        "pattern"
      ],
      "inputs": {
        "text": "Text to be analyzed."
      },
      "inputNames": [
        "text"
      ],
      "outputs": {
        "match?": "1 if in the text is something that matches with the pattern. Else 0.",
        "matchCount": "How many matches there are in the text.",
        "matchList": "A list of the matches. An empty list if there aren't any."
      },
      "outputNames": [
        "match?",
        "matchCount",
        "matchList"
      ],
      "helpText": "<p>Module for analyzing text with a&nbsp;Regular Expression (Regex) pattern. <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html\" target=\"_blank\">Pattern</a> is given in java format, without the starting and ending slashes.</p>\n"
    }
  },
  {
    "id": 202,
    "name": "Replace",
    "path": "Text",
    "help": {
      "params": {
        "search": "The substring to be replaced",
        "replaceWith": "The replacer"
      },
      "paramNames": [
        "search",
        "replaceWith"
      ],
      "inputs": {},
      "inputNames": [],
      "outputs": {
        "out": "The output, with replaced texts"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Searches the input text by the <strong>search&nbsp;</strong>parameter, and if it is found, replaces it with the <strong>replaceWith&nbsp;</strong>parameter and outputs the result.</p>\n"
    }
  },
  {
    "id": 203,
    "name": "Split",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "text": "The text to be splitted"
      },
      "inputNames": [
        "text"
      ],
      "outputs": {
        "list": "Splitted output as list"
      },
      "outputNames": [
        "list"
      ],
      "helpText": "<p>Splits the text by a given separator and outputs a list with the results</p>\n\n<p>Examples:</p>\n\n<ul>\n\t<li>Separator: &quot;&nbsp;&quot;(empty space),Text: &quot;Two Words&quot;\n\t<ul>\n\t\t<li>Output: Two, Words</li>\n\t</ul>\n\t</li>\n</ul>\n"
    }
  },
  {
    "id": 204,
    "name": "StartsWith",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Tests whether the input string starts with the substring given as the&nbsp;search&nbsp;parameter. If it does, 1 is sent out. Otherwise the output is 0.</p>\n"
    }
  },
  {
    "id": 1015,
    "name": "StringTemplate",
    "path": "Text",
    "help": {
      "params": {
        "template": "Text template"
      },
      "paramNames": [
        "template"
      ],
      "inputs": {
        "args": "Map of arguments that will be substituted into the template"
      },
      "inputNames": [
        "args"
      ],
      "outputs": {
        "errors": "List of error strings",
        "result": "Completed template string"
      },
      "outputNames": [
        "errors",
        "result"
      ],
      "helpText": "<p>For template syntax, see <a href='https://github.com/antlr/stringtemplate4/blob/master/doc/cheatsheet.md' target='_blank'>StringTemplate cheatsheet</a>.</p><p>Values of the <strong>args</strong> map are added as substitutions in the template. For example, incoming map <strong>{name: &quot;Bernie&quot;, age: 50}</strong> substituted into template &quot;<strong>Hi, &lt;name&gt;!</strong>&quot;&nbsp;would produce string &quot;Hi, Bernie!&quot;</p><p>Nested maps can be accessed with dot notation:&nbsp;<strong>{name: &quot;Bernie&quot;, pet: {species: &quot;dog&quot;, age: 3}}</strong>&nbsp;substituted into &quot;<strong>What a cute &lt;pet.species&gt;!</strong>&quot; would result in &quot;What a cute dog!&quot;.</p><p>Lists will be smashed together: <strong>{pals:&nbsp;[&quot;Sam&quot;, &quot;Herb&quot;, &quot;Dud&quot;]}</strong>&nbsp;substituted into &quot;<strong>BFF: me, &lt;pals&gt;</strong>&quot; results in &quot;BFF: me, SamHerbDud&quot;. Separator must be explicitly given: &quot;<strong>BFF: me, &lt;pals; separator=&quot;, &quot;&gt;</strong>&quot; gives &quot;BFF: me, Sam, Herb, Dud&quot;.</p><p>Transforming list items can be done with <em>{ x | f(x) }</em> syntax, e.g. <strong>{pals:&nbsp;[&quot;Sam&quot;, &quot;Herb&quot;, &quot;Dud&quot;]}</strong> substituted into &quot;<strong>&lt;pals: { x | Hey &lt;x&gt;! }&gt; Hey y&#39;all!</strong>&quot; results in &quot;Hey Sam! Hey Herb! Hey Dud! Hey y&#39;all!&quot;.</p>"
    }
  },
  {
    "id": 1031,
    "name": "StringToNumber",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "input string"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "number parsed from input string",
        "error": "Error if input can't be parsed"
      },
      "outputNames": [
        "out",
        "error"
      ],
      "helpText": "<p>Parse a number from the input string.</p><p>Examples of valid floating-point numbers:</p><ul><li>&quot;1&quot;</li><li>&quot;3.14159&quot;</li><li>&quot;-.234e4&quot; (outputs -2340)</li><li>&quot;+3.e1&quot; (outputs 30)</li></ul>"
    }
  },
  {
    "id": 199,
    "name": "TextEquals",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Tests whether the input string equals with the string&nbsp;given as the&nbsp;search&nbsp;parameter. If it does, 1 is sent out. Otherwise the output is 0.</p>\n"
    }
  },
  {
    "id": 200,
    "name": "TextLength",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Ouputs the length of the input text (all characters including).</p>\n"
    }
  },
  {
    "id": 206,
    "name": "ToLowerCase",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Outputs the input text in lower case.</p>\n"
    }
  },
  {
    "id": 207,
    "name": "ToUpperCase",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Outputs the input text in upper case.</p>\n"
    }
  },
  {
    "id": 205,
    "name": "Trim",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Removes the whitespace in front of and behind the input text.</p>\n\n<p>E.g.&nbsp; &quot; &nbsp; &nbsp; &nbsp; &nbsp; example with a space &nbsp; &nbsp; &nbsp; &quot; -&gt; &quot;example with a space&quot;</p>\n"
    }
  },
  {
    "id": 208,
    "name": "ValueAsText",
    "path": "Text",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "Any Object"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Transforms the input value (which can be any value) into text.</p>\n"
    }
  },
  {
    "id": 209,
    "name": "Clock",
    "path": "Time & Date",
    "help": {
      "params": {
        "format": "Format of the string date",
        "rate": "the rate of the interval",
        "unit": "the unit of the interval"
      },
      "paramNames": [
        "format",
        "rate",
        "unit"
      ],
      "inputs": {},
      "inputNames": [],
      "outputs": {
        "date": "String notation of the time and date",
        "timestamp": "unix timestamp"
      },
      "outputNames": [
        "date",
        "timestamp"
      ],
      "helpText": "<p>Tells the time and date at fixed time intervals (by default every second). Outputs the time either in string notation of given format or as a timestamp (milliseconds from 1970-01-01 00:00:00.000).</p><p>The time interval can be chosen with parameter&nbsp;<em>unit&nbsp;</em>and&nbsp;granularly controlled via parameter&nbsp;<em>rate</em>. For example,&nbsp;<em>unit=minute&nbsp;</em>and&nbsp;<em>rate=2</em>&nbsp;will tell the time every other minute.</p>"
    }
  },
  {
    "id": 211,
    "name": "DateConversion",
    "path": "Time & Date",
    "help": {
      "params": {
        "timezone": "Timezone of the outputs",
        "format": "Format of the input and output string notations"
      },
      "paramNames": [
        "timezone",
        "format"
      ],
      "inputs": {
        "date": "Timestamp, string or Date"
      },
      "inputNames": [
        "date"
      ],
      "outputs": {
        "date": "String notation",
        "ts": "Timestamp(ms)",
        "dayOfWeek": "In shortened form, e.g. \"Mon\""
      },
      "outputNames": [
        "date",
        "ts",
        "dayOfWeek"
      ],
      "helpText": "<p>Takes a date as an input in either in <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Date.html\" target=\"_blank\">Date</a> object, timestamp(ms) or in string notation. If the input is in text form, is the given format used.</p>\n\n<p>Example:</p>\n\n<p>Parameters:</p>\n\n<ul>\n\t<li>Format &lt;- &quot;yyyy-MM-dd HH:mm:ss&quot;</li>\n\t<li>Timezone &lt;- Europe/Helsinki</li>\n</ul>\n\n<p><br />\nInputs:</p>\n\n<ul>\n\t<li>Date in &lt;- &quot;2015-07-15&nbsp;13:06:13&quot; or&nbsp;1436954773474</li>\n</ul>\n\n<p>Outputs:&nbsp;</p>\n\n<ul>\n\t<li>Date out -&gt;&nbsp;2015-07-15&nbsp;13:06:13</li>\n\t<li>ts -&gt;&nbsp;1436954773474</li>\n\t<li>dayOfWeek -&gt; &quot;Wed&quot;</li>\n\t<li>years -&gt; 2015</li>\n\t<li>months -&gt; 7</li>\n\t<li>days -&gt; 15</li>\n\t<li>hours -&gt; 13</li>\n\t<li>minutes -&gt; 6</li>\n\t<li>seconds -&gt; 13</li>\n\t<li>milliseconds -&gt; 0</li>\n</ul>\n"
    }
  },
  {
    "id": 801,
    "name": "Scheduler",
    "path": "Time & Date",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {
        "value": "The value from a active rule or the default value"
      },
      "outputNames": [
        "value"
      ],
      "helpText": "<p>Outputs a certain value at a certain time.&nbsp;E.g. Every day from 10:00 to 14:00 the module outputs value 1&nbsp;and otherwise value 0.<br />\nIf more than one rule are active at the same time, the value from the rule with the highest priority (the highest rule in the list) is sent.<br />\nIf no rule is active,&nbsp;the default value will be sent out.&nbsp;</p>\n"
    }
  },
  {
    "id": 210,
    "name": "TimeBetweenEvents",
    "path": "Time & Date",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "Any type event"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "ms": "Time in milliseconds"
      },
      "outputNames": [
        "ms"
      ],
      "helpText": "<p>Tells the time between two consecutive events in milliseconds.</p>\n"
    }
  },
  {
    "id": 60,
    "name": "TimeOfDay",
    "path": "Time & Date",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {},
      "helpText": "<p>Outputs 1 if the current time of day (in the time zone your user account is set to) is between <span class='highlight'>startTime</span> and <span class='highlight'>endTime</span> (both inclusive). At other times outputs 0.\n</p>",
      "inputNames": [],
      "params": {
        "startTime": "24 hour format HH:MM:SS",
        "endTime": "24 hour format HH:MM:SS"
      },
      "outputs": {
        "out": "1 between the given times, otherwise 0"
      },
      "paramNames": [
        "startTime",
        "endTime"
      ]
    }
  },
  {
    "id": 566,
    "name": "TimeOfEvent",
    "path": "Time & Date",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "trigger": "any value; causes module to activate, i.e., produce output"
      },
      "inputNames": [
        "trigger"
      ],
      "outputs": {
        "timestamp": "time of the current event"
      },
      "outputNames": [
        "timestamp"
      ],
      "helpText": "<p>Get timestamp for the event currently being processed. Similar to <strong>Clock,&nbsp;</strong>but instead of generating events,&nbsp;this&nbsp;module is triggered manually through input&nbsp;<em>trigger</em>.&nbsp;</p>"
    }
  },
  {
    "id": 70,
    "name": "MODWT",
    "path": "Time Series: Filtering",
    "help": {
      "params": {
        "wavelet": "<span>Chosen wavelet filter</span>",
        "level": "<span>Transform level (1..N)</span>"
      },
      "paramNames": [
        "wavelet",
        "level"
      ],
      "inputs": {
        "in": "<span>Input time series</span>"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "details": "<span>The wavelet detail</span>",
        "energy": "<span>Energy at this level</span>",
        "smooth": "<span>The wavelet smooth</span>"
      },
      "outputNames": [
        "details",
        "energy",
        "smooth"
      ],
      "helpText": "<p>This module implements a realtime maximal overlap discrete wavelet transform (MODWT). A number of different wavelets are available.\n</p><p>\nNote that, like all filters, the MODWT introduces increasing amounts of delay with higher levels of smoothing. No additional delay is added to any level - this means that a multi-level decomposition is not aligned at a given time. Reconstructing the original signal would require adding delay to all but the last level.</p>"
    }
  },
  {
    "id": 524,
    "name": "MovingAverage",
    "path": "Time Series: Filtering",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "Input values"
      },
      "helpText": "<p>This module calculates the simple moving average (MA, SMA) of values arriving at the input. Each value is assigned equal weight. The moving average is calculated based on a sliding window of adjustable length.</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "minSamples": "Minimum number of input values received before a value is output",
        "length": "Length of the sliding window, ie. the number of most recent input values to include in calculation"
      },
      "outputs": {
        "out": "The moving average"
      },
      "paramNames": [
        "length",
        "minSamples"
      ]
    }
  },
  {
    "id": 96,
    "name": "MovingAverageExp",
    "path": "Time Series: Filtering",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Smooths the incoming time series by calculating an exponential moving average (EMA)</p>\n\n<ul>\n\t<li><span class=\"formula\">EMA(t) = a x&nbsp;<strong>in</strong>(t) + (1-a) x&nbsp;EMA(t-1)</span></li>\n\t<li><span class=\"formula\">a = <span class=\"math-tex\">\\(2 \\over \\text{length} + 1\\)</span></span></li>\n</ul>\n"
    }
  },
  {
    "id": 98,
    "name": "ARIMA",
    "path": "Time Series: Prediction",
    "help": {
      "outputNames": [
        "pred"
      ],
      "inputs": {
        "in": "Incoming time series"
      },
      "helpText": "<p>Evaluates an ARIMA prediction model with given parameters. Check the module options to set the number of autoregressive and moving average parameters. Model fitting is not (yet) implemented.</p>",
      "inputNames": [
        "in"
      ],
      "params": {},
      "outputs": {
        "pred": "ARIMA prediction"
      },
      "paramNames": []
    }
  },
  {
    "id": 562,
    "name": "RandomNumber",
    "path": "Time Series: Random",
    "help": {
      "params": {
        "min": "lower bound of interval to sample from",
        "max": "upper bound of interval to sample from"
      },
      "paramNames": [
        "min",
        "max"
      ],
      "inputs": {
        "trigger": "when value is received, activates module"
      },
      "inputNames": [
        "trigger"
      ],
      "outputs": {
        "out": "the random number"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Generate random numbers between [<em>min</em>, <em>max</em>] with uniform probability.</p>"
    }
  },
  {
    "id": 563,
    "name": "RandomNumberGaussian",
    "path": "Time Series: Random",
    "help": {
      "params": {
        "mean": "mean of normal distribution",
        "sd": "standard deviation of normal distribution"
      },
      "paramNames": [
        "mean",
        "sd"
      ],
      "inputs": {
        "trigger": "when value is received, activates module"
      },
      "inputNames": [
        "trigger"
      ],
      "outputs": {
        "out": "the random number"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Generate random numbers from normal (Gaussian) distribution with mean&nbsp;<em>mean</em>&nbsp;and standard deviation&nbsp;<em>sd</em>.</p>"
    }
  },
  {
    "id": 27,
    "name": "Abs",
    "path": "Time Series: Simple Math",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "The original value"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "The absolute value of the original value"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Outputs the absolute value (positive value with original sign stripped) of the input.</p>\n"
    }
  },
  {
    "id": 520,
    "name": "Add",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [
        "sum"
      ],
      "inputs": {},
      "helpText": "<p>Adds together two or more numeric input values.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {
        "sum": "Sum of inputs"
      },
      "paramNames": []
    }
  },
  {
    "id": 11,
    "name": "ChangeAbsolute",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Outputs the difference between the received value and the previous received value, or <span class='highlight'>in(t)&nbsp;-&nbsp;in(t-1)</span>.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 87,
    "name": "ChangeLogarithmic",
    "path": "Time Series: Simple Math",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Outputs the logarithmic difference (log return) between the received value and the previous received value, or <span class=\"highlight\">log[in(t)]&nbsp;-&nbsp;log[in(t-1)]</span>.</p>\n"
    }
  },
  {
    "id": 35,
    "name": "ChangeRelative",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Outputs the received value divided by the previous received value, or <span class='highlight'>in(t)&nbsp;/&nbsp;in(t-1)</span>. If the previous received value is zero, the result is undefined and no output is produced.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 161,
    "name": "Count",
    "path": "Time Series: Simple Math",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "Counts the number of incoming events."
    }
  },
  {
    "id": 6,
    "name": "Divide",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [
        "A/B"
      ],
      "inputs": {
        "A": "The dividend, or numerator",
        "B": "The divisor, or denominator"
      },
      "helpText": "<p>This module calculates the quotient of its two input values. If the input <span class='highlight'>B</span> is zero, the result is not defined and thus no output is produced.</p>",
      "inputNames": [
        "A",
        "B"
      ],
      "params": {},
      "outputs": {
        "A/B": "The quotient: A divided by B"
      },
      "paramNames": []
    }
  },
  {
    "id": 567,
    "name": "Expression",
    "path": "Time Series: Simple Math",
    "help": {
      "params": {
        "expression": "mathematical expression to evaluate"
      },
      "paramNames": [
        "expression"
      ],
      "inputs": {
        "x": "variable for default expression",
        "y": "variable for default expression"
      },
      "inputNames": [
        "x",
        "y"
      ],
      "outputs": {
        "out": "result if evaluation succeeded",
        "error": "error message if evaluation failed (e.g. syntax error in expression)"
      },
      "outputNames": [
        "out",
        "error"
      ],
      "helpText": "<p>Evaluate arbitrary mathematical expressions containing operators, variables, and functions. Variables introduced in an&nbsp;expression&nbsp;will automatically appear as&nbsp;inputs.</p><p>&nbsp;</p><p>See&nbsp;<a href=https://github.com/uklimaschewski/EvalEx#supported-operators>https://github.com/uklimaschewski/EvalEx#supported-operators</a>&nbsp;for further detail about supported features.</p>"
    }
  },
  {
    "id": 29,
    "name": "Invert",
    "path": "Time Series: Simple Math",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "in": "<span></span>"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "out": "<span></span>"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "<p>Outputs the multiplicative inverse (reciprocal) of the input (1/in, in^-1).</p>"
    }
  },
  {
    "id": 116,
    "name": "LinearMapper",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Linearly transforms a range of incoming (x) values to a range of outgoing (y) values. For example, this could be used to transform the input range of -1...1 (<span class='highlight'>xMin</span>...<span class='highlight'>xMax</span>) into an output range of 0...1000 (<span class='highlight'>yMin</span>...<span class='highlight'>yMax</span>).\n</p><p>\nIncoming values outside the x range will just output the min/max y value.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 115,
    "name": "LogNatural",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Outputs the natural logarithm of the input value.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 62,
    "name": "Max",
    "path": "Time Series: Simple Math",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Outputs the greater one of the two input values. For finding the maximum in a window of values, see the <span class=\"highlight\">Max (window)</span> module.</p>"
    }
  },
  {
    "id": 61,
    "name": "Min",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Outputs the lesser one of the two input values. For finding the minimum in a window of values, see the <span class='highlight'>Min (window)</span> module.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 213,
    "name": "Modulo",
    "path": "Time Series: Simple Math",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Calculates the remainder of two values. Outputs ( divisor mod divider).</p>\n\n<p>E.g.</p>\n\n<ul>\n\t<li>3 mod 2 = 1</li>\n</ul>\n"
    }
  },
  {
    "id": 1,
    "name": "Multiply",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [
        "A*B"
      ],
      "inputs": {
        "A": "The first value to be multiplied",
        "B": "The second value to be multiplied"
      },
      "helpText": "<p>This module calculates the product of two numeric input values.</p>",
      "inputNames": [
        "A",
        "B"
      ],
      "params": {},
      "outputs": {
        "A*B": "The product of the inputs"
      },
      "paramNames": []
    }
  },
  {
    "id": 28,
    "name": "Negate",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Outputs the negated input value <span class='highlight'>-1 * in</span>.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 120,
    "name": "RoundToStep",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Rounds incoming values to given precision/step. The direction of rounding can be set with the <span class='highlight'>mode</span> parameter.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 34,
    "name": "Sign",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Outputs the sign of the input: -1 if the input is negative, 0 if the input is zero, and 1 if the input is positive.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 162,
    "name": "SquareRoot",
    "path": "Time Series: Simple Math",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "Calculates the square root of the input."
    }
  },
  {
    "id": 4,
    "name": "Subtract",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [
        "A-B"
      ],
      "inputs": {
        "A": "Value to subtract from",
        "B": "Value to be subtracted"
      },
      "helpText": "<p>This module calculates the difference of its two input values.</p>",
      "inputNames": [
        "A",
        "B"
      ],
      "params": {},
      "outputs": {
        "A-B": "The difference"
      },
      "paramNames": []
    }
  },
  {
    "id": 53,
    "name": "Sum",
    "path": "Time Series: Simple Math",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "Values to be summed"
      },
      "helpText": "<p>Calculates the (optionally rolling) sum of incoming values. For an infinite sum, enter a <span class='highlight'>windowLength</span> of 0.</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "minSamples": "How many values must exist in the window before outputting a value",
        "windowLength": "Length of the sliding window of values to be summed, or 0 for infinite"
      },
      "outputs": {
        "out": "Sum of values in the window"
      },
      "paramNames": [
        "windowLength",
        "minSamples"
      ]
    }
  },
  {
    "id": 54,
    "name": "Correlation",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Calculates (Pearson's) correlation between two input variables in a sliding window of length <span class='highlight'>windowLength</span>.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 56,
    "name": "Covariance",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Calculates the covariance of two input variables in a sliding window of length <span class='highlight'>windowLength</span>.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 151,
    "name": "GeometricMean",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Calculates the geometric mean of incoming values in a sliding window of length <span class='highlight'>windowLength</span>. At least </span>minSamples</span> values must be received before an output is produced.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 152,
    "name": "Kurtosis",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "Input random variable"
      },
      "helpText": "<p>Calculates the kurtosis (or fourth standardized moment) of a distribution of values in a sliding window. Kurtosis is a measure of the \"peakedness\" of a distribution.\n</p><p>\nNote that at least 4 samples is required to calculate kurtosis.\n</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "minSamples": "Number of samples required to produce output. At least 4 samples are required to calculate kurtosis",
        "windowLength": "Length of the sliding window of values"
      },
      "outputs": {
        "out": "Kurtosis"
      },
      "paramNames": [
        "windowLength",
        "minSamples"
      ]
    }
  },
  {
    "id": 150,
    "name": "Max (window)",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Calculates the maximum value in a sliding window of length <span class='highlight'>windowLength</span>. At least </span>minSamples</span> values must be received before an output is produced.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 149,
    "name": "Min (window)",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Calculates the minimum value in a sliding window of length <span class='highlight'>windowLength</span>. At least </span>minSamples</span> values must be received before an output is produced.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 153,
    "name": "Percentile",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "The input values"
      },
      "helpText": "<p>Calculates the value below which a given <span class='highlight'>percentage</span> of values fall in a sliding window of observations.</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "minSamples": "Minimum number of observations for producing output",
        "windowLength": "Length of the sliding window",
        "percentage": "This percentage (0-100) of observations fall under the output of this module"
      },
      "outputs": {
        "out": "The value under which <span class='highlight'>percentage</span> % of input values fall"
      },
      "paramNames": [
        "windowLength",
        "minSamples",
        "percentage"
      ]
    }
  },
  {
    "id": 154,
    "name": "PopulationVariance",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Calculates the non-bias-corrected population variance. See the <span class='highlight'>Variance</span> module or bias-corrected variance.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 156,
    "name": "Skewness",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "Input random variable"
      },
      "helpText": "<p>Calculates the skewness (or third standardized moment) of a distribution of values in a sliding window. Skewness is a measure of the asymmetry of a distribution.</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "minSamples": "Number of samples required to produce output",
        "windowLength": "Length of the sliding window of values"
      },
      "outputs": {
        "out": "Skewness"
      },
      "paramNames": [
        "windowLength",
        "minSamples"
      ]
    }
  },
  {
    "id": 55,
    "name": "SpearmansRankCorrelation",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Calculates Spearman's Rank correlation between two input variables in a sliding window of length <span class='highlight'>windowLength</span>.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 138,
    "name": "StandardDeviation",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "Input time series"
      },
      "helpText": "<p>Calculates the standard deviation in a sliding window of the input time series.</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "minSamples": "Minimum number of observations for producing output",
        "windowLength": "Length of the sliding window (number of observations)"
      },
      "outputs": {
        "out": "Standard deviation"
      },
      "paramNames": [
        "windowLength",
        "minSamples"
      ]
    }
  },
  {
    "id": 157,
    "name": "SumOfSquares",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Calculates the sum of squared input values in a sliding window of length <span class='highlight'>windowLength</span>. At least <span class='highlight'>minSamples</span> values are collected before producing output.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 51,
    "name": "UnivariateLinearRegression",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [
        "slope",
        "intercept",
        "error",
        "R^2"
      ],
      "inputs": {
        "inX": "Input X values",
        "inY": "Input Y values"
      },
      "helpText": "<p>Performs a least-squares linear regression on a sliding window of input data. The model is <span class='highlight'>y&nbsp;=&nbsp;slope*X&nbsp;+&nbsp;intercept.</p>",
      "inputNames": [
        "inX",
        "inY"
      ],
      "params": {
        "windowLength": "Length of the sliding window as number of samples"
      },
      "outputs": {
        "error": "Mean square error (MSE) of the fit",
        "intercept": "Intercept of the linear fit",
        "slope": "Slope of the linear fit",
        "R^2": "R-squared value of the fit"
      },
      "paramNames": [
        "windowLength"
      ]
    }
  },
  {
    "id": 155,
    "name": "Variance",
    "path": "Time Series: Statistics",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Calculates the bias-corrected sample variance (with N-1 in the denominator). Use the <span class='highlight'>PopulationVariance</span> module for the non-bias-corrected population variance.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 16,
    "name": "Barify",
    "path": "Time Series: Utils",
    "help": {
      "outputNames": [
        "open",
        "high",
        "low",
        "close",
        "avg"
      ],
      "inputs": {
        "in": "Input values"
      },
      "helpText": "<p>This is a utility for moving from event time to wall-clock time. This module outputs new values every <span class='highlight'>barLength</span> seconds. You would use this module to sample a time series every 60 seconds, for example.</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "barLength": "Length of the bar (time interval) in seconds"
      },
      "outputs": {
        "open": "Value at start of period",
        "high": "Maximum value during period",
        "avg": "Simple average of values received during the period",
        "low": "Minimum value during period",
        "close": "Value at end of period (the most recent value)"
      },
      "paramNames": [
        "barLength"
      ]
    }
  },
  {
    "id": 7,
    "name": "Delay",
    "path": "Time Series: Utils",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "Incoming values to be delayed"
      },
      "helpText": "<p>This module will delay the received values by a number of events. For example, if the <span class='highlight'> delayEvents</span> parameter is set to 1, the module will always output the previous value received.\n</p><p>\nThe module will not produce output until the <span class='highlight'>delayEvents+1</span>th event, at which point the first received value will be output. For example, if the parameter is set to 2, the following sequence would be produced:\n</p><p>\n<table>\n<tr><th>Input</th><th>Output</th></tr>\n<tr><td>1</td><td>(no value)</td></tr>\n<tr><td>2</td><td>(no value)</td></tr>\n<tr><td>3</td><td>1</td></tr>\n<tr><td>4</td><td>2</td></tr>\n<tr><td>...</td><td>...</td></tr>\n</table></p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "delayEvents": "Number of events to delay the incoming values"
      },
      "outputs": {
        "out": "The delayed values"
      },
      "paramNames": [
        "delayEvents"
      ]
    }
  },
  {
    "id": 158,
    "name": "FlexBarify",
    "path": "Time Series: Utils",
    "help": {
      "outputNames": [
        "open",
        "high",
        "low",
        "close",
        "avg"
      ],
      "inputs": {
        "value": "Value to be sampled into the bar",
        "valueLength": "Length of each event, contributes to <span class='highlight'>barLength</span>"
      },
      "helpText": "<p>Similar to the <span class='highlight'>Barify</span> module, which creates open-high-low-close bars equally long in <span class='highlight'>time</span>, this module creates bars equally long in an arbitrary variable passed into the <span class='highlight'>valueLength</span> input.\n</p><p>\nIncoming <span class='highlight'>valueLength</span> is summed for the current bar until <span class='highlight'>barLength</span> is reached, at which point the outputs are sent and the bar is reset.\n</p><p>\nNote that if multiple bars would be filled on the same event, only one is output. To avoid this situation you may want to keep <span class='highlight'>barLength</span> substantially larger than incoming <span class='highlight'>valueLength</span>. </p>",
      "inputNames": [
        "valueLength",
        "value"
      ],
      "params": {
        "barLength": "Length of each bar (in <span class='highlight'>valueLength</span> units)"
      },
      "outputs": {
        "open": "Value at start of period",
        "high": "Maximum value during period",
        "avg": "Average of values received during the period, weighted by <span class='highlight'>valueLength</span>",
        "low": "Minimum value during period",
        "close": "Value at end of period (the most recent value)"
      },
      "paramNames": [
        "barLength"
      ]
    }
  },
  {
    "id": 521,
    "name": "PassThrough",
    "path": "Time Series: Utils",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>This module just sends out whatever it receives.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 84,
    "name": "FourZones",
    "path": "Time Series: Triggers",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "Input values"
      },
      "helpText": "<p>This module waits for the input signal to reach either the <span class='highlight'>highTrigger</span> or <span class='highlight'>lowTrigger</span> level. Either 1 or -1 is output respectively. The triggered value is kept until it is set back to 0 at the corresponding release level.\n</p><p>\nIf you set <span class='highlight'>mode</span> to <span class='highlight'>exit</span>, the output will trigger when exiting the trigger level instead of entering it.</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "lowRelease": "Low release level",
        "highTrigger": "High trigger level",
        "lowTrigger": "Low trigger level",
        "highRelease": "High release level",
        "mode": "Trigger on entering/exiting the high/low trigger level"
      },
      "outputs": {
        "out": "1 on high trigger, -1 on low trigger, 0 on release"
      },
      "paramNames": [
        "mode",
        "highTrigger",
        "highRelease",
        "lowRelease",
        "lowTrigger"
      ]
    }
  },
  {
    "id": 49,
    "name": "Peak",
    "path": "Time Series: Triggers",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "Input time series"
      },
      "helpText": "<p>Attempts to detect upward turns below <span class='highlight'>lowZone</span> (outputs 1) and downward turns below <span class='highlight'>highZone</span> (outputs -1).\n</p><p>\nFor an upward turn to be registered, the change between subsequent input values must be larger than <span class='highlight'>threshold</span>. For a downward turn the change must be less than <span class='highlight'>-threshold</span>.</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "highZone": "The level above which a downward turn can occur",
        "lowZone": "The level below which an upward turn can occur",
        "threshold": "The minimum change in the correct direction between subsequent input values that is allowed to trigger a turn"
      },
      "outputs": {
        "out": "1 for upward turn and -1 for downward turn"
      },
      "paramNames": [
        "highZone",
        "lowZone",
        "threshold"
      ]
    }
  },
  {
    "id": 125,
    "name": "SampleIf",
    "path": "Time Series: Triggers",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>This module can be used to sample values from one timeseries upon events from another timeseries, just like the Sampler module.\n</p><p>\nHowever the <span class='highlight'>triggerIf</span> value must be equal to 1 for the value at <span class='highlight'>value</span> input to be sent out. Trigger events with other values than 1 will produce no effect.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 85,
    "name": "Sampler",
    "path": "Time Series: Triggers",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>This module can be used to sample values from one timeseries upon events from another timeseries.\n</p><p>\nAn event arriving at the <span class='highlight'>trigger</span> input will cause the module to send out whatever value the <span class='highlight'>value</span> input has. The <span class='highlight'>trigger</span> is the only <span class='highlight'>driving input</span>.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 25,
    "name": "ThreeZones",
    "path": "Time Series: Triggers",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "Incoming value"
      },
      "helpText": "<p>This module outputs -1, 0 or +1 depending on whether the input value is below <span class='highlight'>lowZone</span>, between <span class='highlight'>lowZone</span> and <span class='highlight'>highZone</span>, or above <span class='highlight'>highZone</span> respectively.</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "highZone": "The high limit",
        "lowZone": "The low limit"
      },
      "outputs": {
        "out": "-1, 0 or +1 depending on which zone the input value is in"
      },
      "paramNames": [
        "highZone",
        "lowZone"
      ]
    }
  },
  {
    "id": 24,
    "name": "ZeroCross",
    "path": "Time Series: Triggers",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {
        "in": "Input values"
      },
      "helpText": "<p>This module is used to detect when a time series crosses the zero line. It outputs -1 when below zero (minus threshold) and +1 when above zero (plus threshold).</p>",
      "inputNames": [
        "in"
      ],
      "params": {
        "strictMode": "In strict mode, the incoming series actually needs to cross the trigger line before an output is produced. Otherwise a value is produced on the first event above or below the trigger line.",
        "threshold": "Zero or a positive value indicating the distance beyond zero that the incoming series must reach before a different output is triggered"
      },
      "outputs": {
        "out": "-1 or +1"
      },
      "paramNames": [
        "strictMode",
        "threshold"
      ]
    }
  },
  {
    "id": 81,
    "name": "Canvas",
    "path": "Utils",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>This module allows you to reuse a Canvas saved into the Archive as a module in your current Canvas. This enables reuse and abstraction of functionality and helps keep your Canvases tidy and modular.\n</p><p>\nAny parameters, inputs or outputs you export will be visible on the module. You can export endpoints by right-clicking on them and selecting \"Toggle export\".</p>"
    }
  },
  {
    "id": 119,
    "name": "Comment",
    "path": "Utils",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Just a text box for comments. Commenting what you build is a good idea, as it helps you and others understand what is going on.</p>"
    }
  },
  {
    "id": 5,
    "name": "Constant",
    "path": "Utils",
    "help": {
      "outputNames": [
        "out"
      ],
      "inputs": {},
      "helpText": "<p>This module represents a constant numeric value that can be connected to any numeric input. The input will have that value during the whole execution.</p>",
      "inputNames": [],
      "params": {
        "constant": "The value to output"
      },
      "outputs": {
        "out": "The value of the parameter"
      },
      "paramNames": [
        "constant"
      ]
    }
  },
  {
    "id": 195,
    "name": "Email",
    "path": "Utils",
    "help": {
      "params": {
        "subject": "Email Subject",
        "message": "Custom message to include in the email, optional"
      },
      "paramNames": [
        "subject",
        "message"
      ],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>The Email module can be used to send notifications to your email address. Just like any module, it activates when an event is received at any driving input. The number of inputs can be set in module options, and the values at the inputs will be included in the email content. The inputs can be renamed to give them more descriptive names.</p>\n\n<p>When running against historical data, emails are not actually sent. Instead, a notification is shown representing the would-be email. Emails are capped at one per minute to avoid accidental self-spamming.</p>\n\n<p>Here's an example of email content:</p>\n\n<p>\nMessage:<BR>\n(your custom message)\n<BR><BR>\nEvent Timestamp:<BR>\n2014-11-18 10:30:00.124\n<BR><BR>\nInput Values:<BR>\nvalue1: 7357<BR>\nvalue2: test value\n</p>"
    }
  },
  {
    "id": 571,
    "name": "ExportCSV",
    "path": "Utils",
    "help": {
      "helpText": "Generates a CSV (Comma-Separated Values) file from event data that flows into this module’s inputs. The file download link becomes available once the canvas has been started, and then stopped. You may wish to connect the inputs of this module to a `stream` module with real-time data flowing."
    }
  },
  {
    "id": 522,
    "name": "Filter",
    "path": "Utils",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "pass": "The filter condition. 1 (true) for letting the event pass, 0 (false) to filter it out",
        "in": "The incoming event (any type)"
      },
      "inputNames": [
        "pass",
        "in"
      ],
      "outputs": {
        "out": "The event that came in, if passed. If filtered, nothing is sent"
      },
      "outputNames": [
        "out"
      ],
      "helpText": "Only lets the incoming value through if the value at <span class='highlight'>pass</span> is 1. If this condition is not met, no event is sent out."
    }
  },
  {
    "id": 145,
    "name": "Label",
    "path": "Utils",
    "help": {
      "helpText": "Displays a text representation of the input received in real-time. This module can take any data type and is often used to debug your canvas or display a single piece of data."
    }
  },
  {
    "id": 1011,
    "name": "ListAsTable",
    "path": "Utils",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "list": "List to be shown"
      },
      "inputNames": [
        "list"
      ],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Display contents of a list as a table. If it's a list of maps, break maps into columns</p>"
    }
  },
  {
    "id": 236,
    "name": "MapAsTable",
    "path": "Utils",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "map": "a map"
      },
      "inputNames": [
        "map"
      ],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Display the entries of a map as a table.</p>"
    }
  },
  {
    "id": 141,
    "name": "Merge",
    "path": "Utils",
    "help": {
      "outputNames": [],
      "inputs": {},
      "helpText": "<p>Merges two event streams into one. Whatever arrives at inputs <span class='highlight'>A</span> or <span class='highlight'>B</span> is sent out from the single output. The inputs and the output can be connected to all types of endpoints. A runtime error may occur if there is a type conflict.</p>",
      "inputNames": [],
      "params": {},
      "outputs": {},
      "paramNames": []
    }
  },
  {
    "id": 570,
    "name": "MovingWindow",
    "path": "Utils",
    "help": {
      "params": {
        "windowLength": "Length of the sliding window, ie. the number of most recent input values to include in calculation",
        "windowType": "behavior of window",
        "minSamples": "Minimum number of input values received before a value is output"
      },
      "paramNames": [
        "windowLength",
        "windowType",
        "minSamples"
      ],
      "inputs": {
        "in": "values of any type"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "list": "the window's current state as a list"
      },
      "outputNames": [
        "list"
      ],
      "helpText": "<p>Provides&nbsp;a moving window (list)&nbsp;for any types of values. Window size and behavior&nbsp;can be set via parameters.</p>"
    }
  },
  {
    "id": 217,
    "name": "RateLimit",
    "path": "Utils",
    "help": {
      "params": {
        "rate": "How many messages are let through in given time",
        "timeInMillis": "The time in milliseconds, in which the given number of messages are let through"
      },
      "paramNames": [
        "rate",
        "timeInMillis"
      ],
      "inputs": {
        "in": "Input"
      },
      "inputNames": [
        "in"
      ],
      "outputs": {
        "limitExceeded?": "Outputs 1 if the message was blocked and 0 if it wasn't",
        "out": "Outputs the input value if it wasn't blocked"
      },
      "outputNames": [
        "limitExceeded?",
        "out"
      ],
      "helpText": "<p>The RateLimit module lets through n messages in t milliseconds. Then module just blocks the rest which do not fit in the window.</p>\n"
    }
  },
  {
    "id": 572,
    "name": "RequireAll",
    "path": "Utils",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Simply passes the values of inputs&nbsp;to corresponding outputs, but only&nbsp;if <strong>all</strong> inputs receive a value on the same event. If one or more inputs do not receive a value on an event, none of the values are sent forward.</p>"
    }
  },
  {
    "id": 197,
    "name": "SendToStream",
    "path": "Utils",
    "help": {
      "helpText": "Capable of pushing data from your canvas into a selected stream. The module will reveal its inputs based on the fields configured on your selected stream. To select your stream click into the value input inside the module and select from the dropdown menu containing all the streams you have permission to access. Ensure that your selected stream has some fields configured, otherwise the module will not show any inputs."
    }
  },
  {
    "id": 527,
    "name": "Table",
    "path": "Utils",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>Displays a table of events arriving at the inputs along with their timestamps. The number of inputs can be adjusted in module options. Every input corresponds to a table column. Very useful for debugging and inspecting values. The inputs can be connected to all types of outputs.</p>"
    }
  },
  {
    "id": 215,
    "name": "ConstantColor",
    "path": "Utils",
    "help": {
      "helpText": "This module represents a constant color value, that can be connected to any color input. The input will have that value during the whole execution."
    }
  },
  {
    "id": 216,
    "name": "Gradient",
    "path": "Utils",
    "help": {
      "helpText": "Generates an RGBA color string based on the combination of its inputs. The `Min Value` input correlates to the `Min Color` input. The `Max Value` input correlates to the `Max Color` input. The color output is determined by the `in` input in relation to these boundary values. For example, `Min Value = 0` `In = 0` `Min Color = Output Color` (e.g. White) Where, `Max Value = 1` `In = 1` `Max Color = Output Color` (e.g. Black) Where, `In = 0.5` Output color will be grey (rgba(128,128,128,1))"
    }
  },
  {
    "id": 67,
    "name": "Chart",
    "path": "Visualizations",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {},
      "inputNames": [],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>This module is the main tool for visualizing time series. The chart is updated on fly as new data becomes available. You can zoom the chart by dragging over the area you want to zoom to. To pan the chart while zoomed, use the <span class='highlight'>navigator</span> below the chart. Individual series can be toggled on or off by clicking on the series name in the <span class='highlight'>legend</span>. Also note that the chart module can be resized by dragging from its lower right corner.\n</p><p>\nEach input series is drawn on y-axis 1 by default. You can edit y-axis assignments by clicking the button beside the input endpoint.\n</p><p>\nThe number of inputs is adjustable in the module <span class='highlight'>options</span> (the wrench icon). Other options include ignoring data points outside a certain time of day.\n</p><p>\nThe module can also produce a downloadable CSV file containing whatever data points are sent to the chart. To use this feature, run in CSV export mode by selecting that option from the Run button dropdown menu.</p>"
    }
  },
  {
    "id": 196,
    "name": "Heatmap",
    "path": "Visualizations",
    "help": {
      "helpText": "Displays a colored heatmap overlay on top of a geographical map. "
    }
  },
  {
    "id": 214,
    "name": "Map (geo)",
    "path": "Visualizations",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "id": "Id of the marker to place. Will also be displayed on hover over the marker.",
        "latitude": "Latitude coordinate for the marker",
        "longitude": "Longitude coordinate for the marker"
      },
      "inputNames": [
        "id",
        "latitude",
        "longitude"
      ],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>This module displays a world map. Markers can be drawn on the map at WGS84 coordinates given to the inputs&nbsp;<strong>latitude</strong>&nbsp;and&nbsp;<strong>longitude</strong>&nbsp;as&nbsp;decimal numbers (degrees). Markers also have an&nbsp;<strong>id</strong>. To draw multiple markers, connect the <b>id</b> input. Coordinates for the same id will move the marker, and coordinates for a new id will create a new marker.</p><p>In module options, you can enable directional markers to expose an additional&nbsp;<strong>heading</strong>&nbsp;input, which controls marker heading (e.g. vehicles on the street or ships at sea). Other options include marker coloring, autozoom behavior etc.</p>"
    }
  },
  {
    "id": 583,
    "name": "Map (image)",
    "path": "Visualizations",
    "help": {
      "params": {},
      "paramNames": [],
      "inputs": {
        "id": "Id of the marker to draw",
        "x": "Horizontal coordinate of the marker between 0 and 1",
        "y": "Vertical coordinate of the marker between 0 and 1"
      },
      "inputNames": [
        "id",
        "x",
        "y"
      ],
      "outputs": {},
      "outputNames": [],
      "helpText": "<p>This module displays a map based on an user-defined image. The image is loaded from a&nbsp;<strong>URL</strong>&nbsp;given in module options.&nbsp;The map automatically scales <strong>x</strong> and <strong>y</strong> coordinates between 0..1&nbsp;to image dimensions.&nbsp;This means&nbsp;that regardless of image size in pixels&nbsp;(x,y) = (0,0) is the top left corner of the image, and (1,1) is the bottom right corner.</p><p>Markers also have an&nbsp;<strong>id</strong>. To draw multiple markers, connect the <b>id</b> input. Coordinates for the same id will move the marker, and coordinates for a new id will create a new marker.</p><p>In module options, you can enable directional markers to expose an additional&nbsp;<strong>heading</strong>&nbsp;input, which controls marker heading (e.g. direction in which people are facing in a space). Other options include marker coloring, autozoom behavior etc.</p>"
    }
  }
]