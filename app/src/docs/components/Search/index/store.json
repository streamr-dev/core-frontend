{"/docs/introduction":{"id":"/docs/introduction","content":"\n\nStreamr Documentation\n\nWelcome to Streamr, the platform for real-time data on the decentralized web. Explore what you can do with Streamr below.\n\n\n\nWhat is Streamr?\n\nStreamr is an open source, crowdfunded, decentralized platform for real-time data. At its heart is the Streamr Network, which transports streams of messages from data publishers to subscribers, appearing to the user as a global publish/subscribe messaging service.\n\nIt is similar in functionality to message queues, enterprise messaging systems, MQTT brokers, Apache Kafka, or pub/sub cloud messaging services. The key features of such systems, including Streamr, are:\n\nPublishing messages in order to make them available to subscribers\n\nSubscribing to messages in order to process them as they occur\n\nStoring messages for later use\n\nYou can interact with Streamr using the Core user interface, SDKs, or directly via the API.\nIn addition to the Network, the Streamr stack includes a Marketplace for data sharing and monetization.\n\nUsing the built-in tooling is optional, as Streamr also integrates with many popular data frameworks including Apache Spark and Node-RED. To start using Streamr right away, check out the Getting Started section and the Tutorials.\n\nWhy use Streamr?\n\nThe big difference to comparable data frameworks is that Streamr aims to be decentralized and peer-to-peer. There are plenty of advantages to decentralization.\n\nSimilar to cloud services, you get on-demand scalability, minimal up-front investment, and benefit from economies of scale. Unlike cloud services, there's no vendor lock-in, no monopolies, no proprietary code, and no need to trust a third party with your data. Decentralized networks are also secure by design, more resilient to attacks and disruptions due to their distributed and peer-to-peer nature. They also benefit from network effects‚Äî as adoption grows, the above points become stronger, a shared standard is formed across industries, and a lot of useful content becomes available from a single source.\n\nInstead of a centralized party, the Network is run by its community of users, and it heavily relies on cryptography to remove the need for trust. This creates a permissionless and neutral network for real-time data, which is highly suitable for use cases such as data sharing, data monetisation, and the decentralized web, extending the capabilities of the underlying internet without compromising its open and decentralized nature.\n\nAnother major difference is that Streamr utilizes a companion blockchain, currently Ethereum. The blockchain provides users with secure digital identities, enables direct transfers of value in the form of a Streamr-specific cryptocurrency DATA, and provides a shared ground truth for the network nodes.\n\nWork in Progress\n\nWhile Streamr already works today, it is not yet feature-complete or fully decentralized. It is being very actively developed towards decentralization, node incentives, and new features. Learn more about the roadmap on the project website.\n\nKey Concepts\n\n\n\nDig Deeper\n\nOn the below channels, you can find others developing on Streamr, as well as get in touch with the Streamr core contributors:\n\n\n\nTo understand the exact inner workings of Streamr, and perhaps help build it, check the Technical Notes section and of course the project GitHub.\n","section":"Introduction","title":"Introduction"},"/docs/getting-started":{"id":"/docs/getting-started","content":"\n\nGetting Started\n\nWelcome to Streamr! To get a feel for what Streamr is, check out our intro docs. \n\nTo get started, you'll want to login to Streamr. Your Streamr account is your Ethereum account - there's no email registration, simply login with your Web3 Ethereum wallet such as Metamask.\n\nConnect your Ethereum Account\n\nThe easiest way to get started is through the free and open source Chrome browser extension, Metamask. Metamask is also available on Android and Apple mobile devices. The explainer video below will help you understand how to use Metamask.\n\n\n\nOnce you have your Ethereum account on Metamask, you can connect it to Streamr. A popup will ask you to sign a message with your Ethereum account to prove ownership, click Sign.\n\n\n\nYou're done! üéâ There's no need to remember passwords anymore - your Ethereum account doubles up as your Streamr identity! Check out some of the suggestions below to get your feet wet inside the Streamr Platform.\n\nIn case you already have a Streamr account, this is the way to go. Head to the Ethereum accounts section of your profile page, and click Add new address to attach your address to your Streamr account.\n\n\n\nChoosing a memorable name for each address is recommended if you have many Ethereum accounts. You will be asked to sign a challenge to prove ownership of the address, and then you're done! üéâ      \n\n","section":"Getting Started","title":"Getting Started"},"/docs/streams/intro-to-streams":{"id":"/docs/streams/intro-to-streams","content":"\n\nIntro to streams\n\nAll of the data in the Streamr network is contained inside individual streams. A stream is simply a sequence of data points in time. The data may originate, for example from machines on the factory floor, sensors in a smart city, in-house databases or systems, or from commercial streaming data feeds.\n\nStreams have the following properties:\n\nAny kind of real-time data can be stored in it.\n\nThe data will always be retrieved in the correct order.\n\nThe data is persisted on the Streamr network and identifiable by unique ID.\n\nSome common use cases for streams:\n\nSensory readings of speed and orientation\n\nGeolocation\n\nAmbient temperature and humidity \n\nSocial media messages\n\nStock market events\n\nMobile ad impressions\n\nThese are just a few examples. There is virtually no limit on the kind, format, or quantity of data you can feed into Streamr, even digital images, streaming video, or other domain-specific data could be pushed into a stream.\n\nStreams implement a publish-subscribe paradigm, or pub/sub for short. A stream can receive data from many sources (or publishers), and there can be several listeners who subscribe to a stream. There are several variations on the possible pub/sub topologies, such as many-to-one, one-to-many, or many-to-many. Streamr supports all of these.\n\nIf you want to try it out already, you can dive into our tutorial on building a simple pub/sub system with Streamr.\n\nExample stream\n\nHere‚Äôs an example of what a small part of a stream could look like. Each row shows one data point, and the columns correspond to the timestamp followed by two data fields, a measurement of the operating temperature and the number of rotations per minute (RPM).\n\n\n\nStream data fields\n\nA field is a kind of placeholder for an individual piece of data, from a single data point. Each data point contains at least one data field, but you can have as many fields per data point as required.\n\nFor example, here's a data point in a stock market stream.\n\n\n\nGiven the structure of this data point, the stream's fields could be configured as follows:\n\n\n\nData field types\n\nThere‚Äôs a number of built-in data types that can be used in a stream. These are:\n\nNumber is a numeric data type internally stored as a double precision (64-bit) float.\n\nBoolean is a logical data type with two possible values, True and False. In Streamr, a numeric value exactly equal to one represents logical truth. Anything else is interpreted as a logical falsehood.\n\nString is a sequence of zero or more alphabetical characters.\n\nObject is a collection of key-value pairs. Each key is a string, and the value can be of any built-in data type (even another object). Object is equivalent to Java's 'Map'.\n\nList is an ordered collection of zero or more elements. List is equivilent to an array.\n\nField types can be freely mixed in a single data point. And you can freely add new fields to an existing stream; you don‚Äôt have to know what fields you might eventually need. A single data point can be of any size within reason, and a stream can grow indefinitely when extended by new data points.\n","section":"Streams","title":"Intro to streams"},"/docs/streams/using-streams-in-core":{"id":"/docs/streams/using-streams-in-core","content":"\n\nWork with streams in Core\n\nStreamr Core provides you with the tools to create, edit, share and delete your streams as well as view and inspect the streams you have subscribed to on the Marketplace.\n\nOverview of your streams\n\nHead over to the Streams page to see an overview of your subscribed streams. The list includes streams you have created and streams that you have subscribe to on the Marketplace.\n\n\n\nThe stream listing page displays all the streams the current user has the right to publish or subscribe to. Clicking on a stream will open the stream editor. You may only edit streams that you have created or have explicit permission to edit.\n\nBy clicking on the more options icon you may access advanced features for each stream, such as stream sharing and code snippets. A new stream can be created by the clicking the Create Stream button.\n\nCreating streams\n\nStreams are identified by a stream ID, which consists of a domain and a user-given path, just like an Internet URL. The domain is either an Ethereum address of the logged in user, or it can also be an ENS (Ethereum Name Service) name owned by the Ethereum address of the logged in user. All streams require a unique path in the format¬†of domain/pathname and can contain single or multi-level paths.\n\nENS names allow streams to have human readable names, for example mydomain.eth/traffic/helsinki. If you haven‚Äôt used an ENS name before, you can easily create one with a small amount of ETH on ENS Domains. Your purchased addresses will automatically appear in the stream editor for immediate usage. At a future date, the stream registry will live on the blockchain.\n\nPlease remember, you may need to escape the pathname slash depending on your coding environment.\n\n\n\nStream status\n\nTraffic light indicators can show you at a glance when data was last pushed to each stream. \n\nGreen: The stream is active \n\nGrey: The stream is inactive\n\nRed: There is a problem with the stream\n\nThe criteria for an inactive stream is defined in the stream editor.\n\nEditing a stream\n\nThe stream editor provides basic tools for setting up, inspecting and editing your stream. Below is a run-down of each stream editor section.\n\nDetails\n\nThe details section provides basic information about your stream.\n\nThe stream name is used to identify your stream in the Core app.\n\nThe stream description can be used to offer more information about your stream and the kind of data it contains.\n\nThe stream ID is the unique identifier for your stream and is needed when interacting with the Streamr SDKs.\n\n\n\nConfigure\n\nIn this section you can configure stream fields and their data types. All fields have a name and a data type. The Autodetect feature can be used to automatically deduce fields from the stream's last received message. It is possible to manually correct the data types if automatic detection is not suitable for your stream.\n\n\n\nYou can also optionally toggle on the requirement for all messages to be signed to enforce a level of verification if you choose.\n\nPreview\n\nThis section is used to preview data flowing into the stream. Use the live inspector to make sure your stream is receiving data and it is correctly formatted.\n\n\n\nData storage\n\nThe data in the Streamr Network is stored in storage nodes. You can enable data storage on your streams to retain historical data in one or more geographic locations of your choice. You can also choose how long to store your stream‚Äôs historical data before auto-deletion.\n\n\n\nBy default, no storage nodes are selected. You can opt-in to storage by selecting a storage node. At the moment, there is only one available option: Streamr Germany. However, new options will be added as they become available.\n\nSharing\n\nRead more about sharing resources in Core.\n","section":"Streams","title":"Streams in Core"},"/docs/streams/using-streams-via-sdk":{"id":"/docs/streams/using-streams-via-sdk","content":"\n\nWork with streams via SDKs\n\nThe easiest way to work with streams is to use the JavaScript client, which works in Node.js as well as the browser. See the SDKs section for the official and community-maintained client libraries available for various languages.\n\nAuthentication\n\nWhen reading from or writing to streams, you need to provide a session token, or authenticate with an Ethereum account. To read more about obtaining a session token, refer to the Authentication section of the API docs.\n\nCreating a client instance with a private key\n\nJavascript\n\n\n\nJava\n\n\n\nSubscribing to real-time events in a stream\n\nBy subscribing to Streams, your application gets immediately notified about new events in the stream.\n\nJavaScript\n\n\n\nJava\n\n\n\nPublishing events to Streams\n\nJavaScript\n\n\n\nJava\n\nEvents in Streams are key-value pairs, represented in Java as Map objects. Below is an example of creating an event payload and publishing it into a Stream.\n\n","section":"Streams","title":"Streams via SDKs"},"/docs/streams/using-streams-via-api":{"id":"/docs/streams/using-streams-via-api","content":"\n\nWork with streams via API\n\nWhile the Core UI can do just about everything you'd want to do with streams, sometimes the using the API directly is preferred.\n\nData output over HTTP\n\nEvents in streams can be queried via HTTP. Example using curl:\n\n\n\nThe following endpoint would return the 5 most recent messages in a stream (or to be more precise, the default partition 0 of a stream):\n\n\n\nThe HTTP API covers session management, data input, data output, and managing Streamr resources. The endpoints allow you to list, create, read, update and delete the resources. You best way to view all of streams endpoints is in the API explorer.\n","section":"Streams","title":"Streams via API"},"/docs/streams/data-signing-and-verification":{"id":"/docs/streams/data-signing-and-verification","content":"Data signing and verification\n\nAuthenticity and integrity of events published on a stream can be guaranteed with digital signatures. Every stream's metadata has a boolean requiresSignedData that can be set by the stream's owner to let subscribers know whether they should expect signed or unsigned events.\n\nEvery message published to a stream has six fields that uniquely identify this message across time, all streams and all publishers:\n\nstreamId\n\nstreamPartititon\n\ntimestamp\n\nsequenceNumber\n\npublisherId\n\nmsgChainId\n\nMore details about these fields can be found in the protocol specification. All together they form the message ID. They must be signed along with the actual message  content to resist against replay attacks. So the payload to be signed for every message by every publisher is the following.\n\n\n\nThe signing algorithm follows the convention described here. The secp256k1 ECDSA algorithm is applied on the keccak256 hash of a string derived from the challenge text.\n\n\n\nOn the recipient side, every subscriber needs to verify signed events. If a received event is unsigned, the subscriber accepts the event if and only if the stream's boolean flag requiresSignedData is set to false. The signature verification is done in three steps:\n\nThe subscriber extracts from the event and the signature the Ethereum address that signed the message (using the EC recover operation).\n\nCheck that the address recovered in step 1 matches the address defined by publisherId\n\nCheck that this publisherId belongs to the set of valid publishers for that stream by querying the api/v1/streams/${id}/publishers endpoint.\n\nBoth signature computation and verification are implemented in the JavaScript and Java SDKs.\n","section":"Streams","title":"Data signing & verification"},"/docs/streams/end-to-end-encryption":{"id":"/docs/streams/end-to-end-encryption","content":"End-to-end encryption\n\nDocumentation coming soon\nConfidentiality of events published on a stream can be guaranteed with end-to-end encryption. The publisher decides on a AES-256 symmetric group key and encrypts the messages in CTR mode before publishing them to the network. The subscribers must know this symmetric group key in order to decrypt the data.\n\nCurrently, the symmetric key must be shared between the publisher and the subscribers in a secure way outside of the Streamr Network. In both the Javascript and the Java SDKs, the publisher can pass group keys per stream as parameters and the subscriber can pass group keys per stream and per publisher as parameters. Later it will be possible to use a secure key-exchange protocol directly in the Streamr Network.\n\nIn order to prevent new subscribers to eavesdrop and then decrypt past messages published before the start of their subscription, the publisher can decide at any time to update the symmetric group key by sending a new key concatenated with an event and encrypted with the current key:\n\n\n\nBoth the Javascript and the Java SDKs support this key update mechanism. It can be triggered by calling the publish method with a new symmetric group key as parameter.\n","section":"Streams","title":"End-to-end encryption"},"/docs/streams/partitioning":{"id":"/docs/streams/partitioning","content":"\n\nPartitioning\n\nTo be precise, when messages are published to a stream, they are actually published to a partition within that stream. Partitions can be understood as sub-streams, or in other words, parts of a stream. One partition per stream is the default, which is sufficient for streams with moderate rates of data (approx. less than 100 msg/sec).\n\nWhen a stream needs to handle large data rates, partitions are used for sharding of the data. Sharding data simply means dividing a large volume of messages to multiple partitions, a bit like a large river can split the same amount of water to multiple smaller branches. Each partition shares the general properties of the parent stream, such as name, description, and user permissions, but the partitions behave independently when it comes to delivering and storing data in the Streamr Network, which allows for scalability.\n\n\n\nPartitions also enable subscribers to scale horizontally: a user consuming data from a stream could load balance the messages over a number of consuming processes, up to the number of partitions. So if a stream has 5 partitions, the user could start up to 5 independent subscribers on separate physical machines, with each subscriber receiving different messages (each process subscribes to a unique partition).\n\nPartitions are identified by a number which starts from zero. For example, a stream with only one partition contains the partition 0 and all of the stream's data flows through this partition. A stream with 5 partitions has partitions 0 through 4 - here the stream's data is distributed across these 5 partitions. The data publisher is free to choose the target partition for each message. If no partition is specified, the data goes to partition 0.\n\nWhile the data publisher is free to choose a target partition for a message arbitrarily, a common approach is to utilize a partition key. A partition key is a value chosen from the data which is used to determine the partition of the message. For example, a customer ID could be used as a partition key in an application that publishes customer interactions to a stream. This way, all messages from a particular customer always go to the same partition. This is useful because it keeps all the events related to a particular customer in a single and known partition instead of spreading them over all partitions.\n\n\n\nThe publish methods in the Streamr SDKs usually take an optional partitionKey parameter. For example, in the JS client:\n\n\n\nInternally, the library maps the partitionKey to a partition number using a hash function (modulo the number of partitions in the stream):\n\n\n\nAt the time of writing, there are some limitations with multi-partition streams: The number of partitions can only be set when creating streams via the API, and the number cannot be changed afterwards.\n\n\n\nCurrently partitions don‚Äôt have well-defined rate limits, but future versions of the P2P network may enforce limits. For now, we recommend not exceeding around 100 msg/sec/partition.\n","section":"Streams","title":"Partitioning"},"/docs/streams/integration-patterns":{"id":"/docs/streams/integration-patterns","content":"Patterns for data integration\n\nThere are three distinct patterns for connecting data to Streamr, each with their own advantages and disadvantages.\n\nPushing from the source\n\nGood Simplicity \nGood Latency \nMedium Applicability\n\nIn this pattern, the data points are sent directly to Streamr by the source as soon as new data becomes available (for example, a sensor produces a new measurement).\n\nThis is the recommended pattern. However, depending on the circumstances, it may not always be available. It requires that you have control over the system that produces the data and can decide where it gets sent.\n\nFor example, if you are an IoT device manufacturer, you could add support for Streamr directly into your devices or gateways, enabling all your end users to easily connect their data to Streamr.\n\nVarious industrial data sources usually have good configurability for connecting the data anywhere you need to. However, consumer grade devices such as connected cars, phones, Fitbits, and others often force you to send your data to the manufacturer‚Äôs cloud, from where they might serve it back to you via an API. In these cases, you can use one of the bridging patterns in this post (see options two and three).\n\nFor a real-world example, here‚Äôs how to connect measurements from any number of Ruuvi IoT tags to Streamr. The devices transmit data over Bluetooth Low Energy to a gateway computer which runs this node.js script. A separate stream is created for each found Ruuvi device, and the measurements are produced to the appropriate stream as they occur.\n\nBridging from a streaming source\n\nMedium Simplicity \nGood Latency \nMedium Applicability\n\nThis pattern is useful when you don‚Äôt have direct control over the source, but a streaming API or some other kind of listener hook is available for the data. These allow you to be notified whenever new data occurs, enabling you to immediately forward the event to Streamr. Data that is typically available via these kinds of APIs are news feeds, financial market data and social media feeds.\n\nBridging by polling a source\n\nMedium Simplicity \nMedium Latency \nGood Applicability\n\nMost cloud services handing out data at least offer a request-response-based API, which can be used if neither of the above push-based options are available. In this case there is no way to get notified when new data is available, which means that the API needs to be repeatedly queried. This is called polling.\n\nIt‚Äôs not an optimal way to serve real-time data, because:\n\nData can be missed: multiple value changes in between subsequent requests are not observed.\n\nIt places an unnecessary load on the API server, as requests are made ‚Äújust in case‚Äù regardless of whether the data has actually changed or not.\n\nAn average latency of half the polling interval is introduced.\n\nFor more information and examples on using these integration patters, please see this deep dive blog post. Please note that the examples used an older version of streamr-client and you should confirm with the official docs on the best practices. \n","section":"Streams","title":"Integration Patterns"},"/docs/products/create-product":{"id":"/docs/products/create-product","content":"\n\nCreate a Product\n\nIn the Streamr Marketplace, you can buy and sell a variety of real-time data products, and if you have access to your own real-time data, you can make and sell your own within the Core app. A product is a single stream or bundle of real-time data streams either sold or made available for free on the Marketplace. These streams typically originate from sensors or applications. You can also create crowdsourced data products with Core, where they are called Data Unions.\n\nCore and the Marketplace support crypto token payments using Streamr's native token DATA, DAI or ETH. To create or subscribe to paid products, you will need an Ethereum wallet, some ETH for gas, and some DATA, ETH or DAI, if making subscriptions. Below we'll run through the basics of creating a product.\n\n\n\nCreate a product in Core\n\nCreating a product in Core is quite simple, but requires some preparation. Once you're ready, simply go to Core > Products and click Create Product But before you do, you should prepare the various things listed below. If you get stuck halfway through, you can click Save & Exit at any time, and Streamr will keep a draft of your product. When you come back, simply click on the draft product tile in Core > Products to continue.\n\nThe Product edit validator helps you to see what is required for publishing. If you see an orange ! icon there, it means you've skipped a section required. Once all the required sections have blue ticks, you're ready to publish.\n\n\n\nPrepare your streams\n\nYou need some real-time streams, added to Streamr. You can do this in Core > Streams by clicking Create Stream This will open the Stream editor, and create an empty stream container, with a unique ID. Then all you need to do is\n\nCopy the ID to use in your code to pipe data into Streamr\n\nTest whether data is flowing correctly by using the Preview section\n\nField names, type and order should be auto-configured by Streamr\n\nIf they aren't, you can manually name the fields, select a type, and drag to reorder them\n\nAdd your streams\n\nAll streams you have added to your Streamr account will show in the stream selector part of the Product Editor. Click to select as many streams as you like, but do consider how to best provide value to your buyers.\n\n\n\nCover images\n\nYou will need a good cover image. If you have a designer who can help, this is ideal, otherwise you can find many high quality free images at Unsplash.com or Reshot.com. Make sure your image is around 1000-1200 pixels on the long side so it is sharp even on large, high-dpi screens. Something thematically related to your data is good if you don't have custom imagery for it. If you upload the wrong one, just upload another and it will be replaced.\n\nDescription\n\nWrite a good description, be concise, but give enough details for buyers to understand the value of your data. You can use Markdown to format headlines and lists, but do remember to keep it simple. You can write as much as you like, but something around 400 words maximum is probably a good rule of thumb.\n\n\n\nPrice\n\nYou can make your product free or paid. For paid products, set price by minute, hour, day or week intervals. You can switch between viewing price in Streamr's DATA token or fiat currency for your convenience. You can also choose to fix price in fiat to protect against sudden shifts in the DATA price.\n\n\n\nDetails and Terms\n\nHere you can add contact details, choose a category, add your website for more information, as well as add some social media links. Social media is optional, but can help buyers feel more confident in buying from you as they can check your reputation online more easily. Terms allows you to state the terms you are offering your data on. You can choose from some multiple choice options, in addition to giving a link to a PDF or website which contains full terms of use..\n\nPublishing\n\nFor a paid product, you'll need a Web3 wallet, and a small amount of ethereum for gas fees, required to publish the product to the Marketplace smart contract. The Publish button will be enabled once required sections are filled, so click that, unlock your wallet and confirm the transaction. Your product will be published on the Marketplace once the ethereum blockchain has confirmed your transaction.\n\n","section":"Data Products","title":"Create a Product"},"/docs/data-unions/intro-to-data-unions":{"id":"/docs/data-unions/intro-to-data-unions","content":"\n\nIntroduction to Data Unions\n\nThe Data Union framework is a data crowdsourcing and crowdselling solution. Working in tandem with the Streamr Network and Ethereum, the framework powers applications that enable people to earn by sharing valuable data.\n\nData Unions are like Data Products in that they also contain a bundle of real-time data streams. A Data Union is listed on the Streamr Marketplace as a type of data product for sale. When a buyer subscribes to the product, the DATA revenue is automatically distributed among all of the data producers. The product can be bridged or exported¬†to other data marketplaces at any time, usually as static files. \n\nData Unions may differ from each other based on their membership model, use cases, revenue structure or governance, but they also share some common components: a group of members contributing their data, an entity providing the application layer to manage the data and a discovery mechanism, or marketplace for the data.\n\nThe most valuable Data Unions will incentivize collection of datasets that may be otherwise difficult to source. Some examples include real-time health data, web user data, pollution monitoring, smart city data and more. Swash is the world's first Data Union - a browser extension that monetizes your browsing data. Streamr supports new Data Unions through the Data Fund.\n\nSmart Contracts\n\nData Unions are fully on-chain, currently on xDai, with a conduit to the Ethereum mainnet. Data Unions are typically deployed via the Core app and subsequently published on the Marketplace. They can run on any Ethereum-compatible sidechain for scalability and affordable cost of operation. The first supported sidechain is xDai, and other options may be added in the future.\n\nThere are numerous benefits of having Data Unions fully on-chain. First of all, the security of the system becomes as strong as the security of the underlying blockchain itself. Secondly, Data Union members and builders get to benefit from composability, network effects, and services available on the same blockchain, particularly DeFi platforms.\n\nThe underlying smart contracts are all open source. A more technical explanation of the framework can be found on the Data Unions GitHub repository.\n\n\n\nWhat you‚Äôll need\n\nCreating a Data Union requires an Ethereum address to create, manage and receive revenue from the underlying smart contract. It also requires some sort of host application that enables your users to join and provide real-time data. For example, this can be a browser extension, a mobile app, or a publishing script on a hardware device.\n\nOnce the product has been published, you can view revenue and community metrics, as well as manage members via the Core app. Revenue from the marketplace subscriptions will be paid out to members in DATA tokens once they have begun accumulating in the Data Union smart contract.\n\nPre-flight Checklist\n\n\n\nLogin to Streamr with your Ethereum account\n\nHave an ETH balance at that address to deploy and publish the product\n\nCreated a name, description and cover image for the Marketplace listing\n\nHave an app with a community of users who will provide real-time data\n\n\n\nGeneral Flow\n\nUse the Core app to create a draft Data Union, and deploy the Data Union smart contract\n\nIntegrate the Data Unions Framework into your your app via one of our client libraries\n\nAllow users to join the Data Union. You must have a minimum of  to publish, but the larger the number of members, the more valuable your product is likely to be\n\nPublish the Data Union to the Marketplace\n\nManage users and view revenue via the Core app\n\nGet Started\n\nIf you want to get started immediately, you should learn how to Build a Data Union with Core. If this is your first time, you might want to start by Creating a free Product in Core. For an in-depth guide to connecting your app to a Data Union, check out our Data Unions Integration Guide.\n","section":"Data Unions","title":"Intro to Data Unions"},"/docs/data-unions/create-data-union-with-core":{"id":"/docs/data-unions/create-data-union-with-core","content":"\n\nBuild a Data Union with Core\n\nTo create a Data Union in Core, go to Core > Products, click Create and choose Data Union as the product type. Other than the sections below, the process is similar to creating a Data Product. If you haven‚Äôt made one before, please check out Creating a Data Product before proceeding with this article.\n\n\n\nDeploying a Data Union\n\nCreating a Data Union starts with deploying the Data Union smart contract. A Data Union is identified by the address of its smart contract. While the deployment transaction is an Ethereum mainnet transaction, the Data Union smart contract is deployed to the sidechain - currently xDai. The sidechain address is deterministic and can be found by reading the mainnet contract on Etherscan. Currently the Core UI shows the mainnet address, in the future it will show both the mainnet and sidechain addresses.\n\nThe account that deploys the contract is also the owner of that contract. Once all the required fields have been filled and the draft Data Union is ready to be deployed, click Continue to deploy the Data Union. The deploy dialogue will walk you through the deploy process.\n\nFor the mainnet contract deployment transaction, you'll need a Web3 wallet and a small amount of Ethereum for gas fees. The amount required is approximately 178k gas, not to be confused with gas price in Gwei which fluctuates based on network usage. The Data Union deployment might take a moment to register once the transaction has been mined. The progress indicator will show an estimate of the remaining time. You can either close the dialog and move on or wait for the process to complete after which you will be automatically redirected.\n\n\n\nMember authentication via shared secrets\n\nShared secrets allow new members to join the Data Union without explicit approval from the Data Union Admin, in order to streamline the on-ramp process. Users may still join the Data Union without a secret but they will have to be manually accepted by the Admin. Shared secret generation becomes available in the Data Union editor once you have deployed your Data Union.\n\nPublishing to the Marketplace\n\nA minimum of Continue from the action bar. Your Data Union will be published on the Marketplace once the Ethereum blockchain has confirmed your transaction.\n\nManaging the Data Union\n\nData Unions are listed along with Data Products in Core > Products. Data Unions are marked by a Data Union badge and a Members badge showing the current amount of approved members. Click the tile menu to access the Data Union stats and manage members.\n\nThe Stats view provides an overview of the Data Union as well as it's members and subscribers over time. The Members view allows you to manage manual member join requests (requests that did not contain a shared secret).\n\n\n\nAdmin fee\n\nAdmins are responsible for maintaining the Data Unions, including ensuring good data quality and removing members that are not contributing data as expected. They are incentivized by receiving an admin fee, a percentage of incoming revenue. Members agree to it by joining the Data Union.\n","section":"Data Unions","title":"Create a DU with Core"},"/docs/data-unions/framework-roles":{"id":"/docs/data-unions/framework-roles","content":"\n\nRoles and responsibilities\n\nEach Data Union has one Admin (owner), and potentially thousands or even millions of data producing members.\n\nAdmin\n\nAdmins have the power to add and remove members. They are responsible for maintaining their Data Unions, including ensuring good data quality and removing members that are not contributing data as they're expected to.\n\nAdmins are incentivized to perform this work by the Admin fee parameter, a fraction of the incoming Data Union revenue. Admins have control over this fee parameter, and members agree to it by joining the Data Union. Previous earnings are not affected by changes in the Admin fee.\n\nTypically, Admins are initially the creators of both the user application and the Data Union, though this role can be assigned to someone else or even performed by the members themselves via a DAO.\n\nMembers\n\nMembers are the people and/or devices that produce data into the data streams contained inside the Data Union. After joining, they start receiving a share of the revenue that accumulates in the Data Union contract. The main source of this revenue is likely to come from Marketplace subscriptions.\n\nMembers are identified by an Ethereum address, and they join the Data Union using one of the Streamr Client libraries or by doing a simple HTTP request as described in the Join & Withdraw guide.\n","section":"Data Unions","title":"Framework Roles"},"/docs/data-unions/auth-and-identity":{"id":"/docs/data-unions/auth-and-identity","content":"\n\nAuthentication and Identity\n\nMembers are identified by an Ethereum address, which is also their identity in the Streamr ecosystem, as Ethereum keys are used to authenticate to Streamr as well for signing datapoints.\n\nEthereum key generation & management\n\nEthereum addresses have an associated private key, which must be kept safe, as it grants access to earned funds. Similarly, losing it means losing funds.\n\nEthereum private keys are just randomly generated 256 bits (32 bytes). They are usually displayed in form of 64 hexadecimal characters. You can use any securely random method of generating those keys, but here‚Äôs how to do it using the Streamr SDK for JavaScript and easily get the associated address too:\n\n\n\nwhich returns an object of this form:\n\n\n\nThe data-producing application can generate the keys when it is launched for the first time, and store the information locally or the user may connect their existing wallet. The private key should always stay on the device and it should never be sent over the internet.\n\nStoring the private key in encrypted form is recommended. One way to approach this is to encrypt it using a user-defined password. If the key is stored encrypted, the key needs to be decrypted when the application starts. The decrypted version should be kept in memory, as it is continuously needed for signing data.\n\nAuthenticating to the Streamr API\n\nThe Ethereum key created above can be used to authenticate to the Streamr API as well as to sign data. The private key is never sent over the internet; instead a challenge generated by the server is signed with the key, and this signature is used to authenticate the user. The mechanism is the same as when signing Ethereum transactions.\n\nThe easiest way to handle authentication is to use the Streamr SDKs. Here‚Äôs how to initialize the JavaScript StreamrClient instance with a private key:\n\n\n\nAll requests made to the Streamr API via this client instance will now be automatically authenticated.\n","section":"Data Unions","title":"Auth & Identity"},"/docs/data-unions/create-and-monitor":{"id":"/docs/data-unions/create-and-monitor","content":"\n\nCreate and monitor Data Unions\n\nCreating a Data Union\n\nA Data Union is typically created in the Core app. See Creating a Data Union with Core for more details. It can also be achieved programmatically, via a client library. Deploying a Data Union requires gas.\n\nTo get a DataUnion instance, call streamr.getDataUnion(dataUnionAddress).\n\n\n\nTo deploy a new DataUnion, call deployDataUnion()\n\n\n\nA Data Union is identified by the address of its smart contract on the Ethereum Mainnet. After the smart contract has been created, the Admin may choose to create an shared secret:\n\n\n\nThe name parameter is simply an identifier for the secret. If it is not provided, a randomly generated one will be used. Note that the request must be authenticated using the Ethereum address of the Admin of the Data Union, as described in Data Unions Auth & Identity.\n\nThe shared secret allows new members to join the Data Union without explicit approval from the Data Union Admin, to streamline the member joining process.\n\nAfter the Data Union is deployed, it‚Äôs time to list it on the Marketplace. This is typically done using Core, but can also be done through the HTTP API.\n\nTo create a Data Union instead of a regular Data Product, add ‚Äútype‚Äù: \"DATAUNION\" to the POST /products body.\n\nObserving Data Unions\n\nThe Admin can make requests through the Data Unions client libraries to understand what‚Äôs going on in the Data Union:\n\n\n\nThe returned stats object would look something like:\n\n\n\nOther relevant query functions:\n\n\n\nThe Streamr Core app also provides monitoring functions for Admins, showing subscriber numbers, total revenue, join requests and more. Create a Data Union with Core provides more information.\n\nAutomatically generated API documentation is also available here. These docs are generated from the repository TypeScript source code.\n","section":"Data Unions","title":"Create & Monitor"},"/docs/data-unions/join-and-withdraw":{"id":"/docs/data-unions/join-and-withdraw","content":"\n\nJoining and withdrawing funds\n\nJoining a Data Union\n\nA member can join a Data Union by calling join in one of the Streamr Client libraries. This call is answered by a centralized gatekeeping service, currently run by Streamr, but can be replaced by your own gatekeeping service. Joining does not incur a gas fee if the default client settings are used. \n\nThe typical way for a device or member to join the Data Union is via shared secrets. See Create and monitor Data Unions for details on creating a shared secret. Calling join with a valid secret will allow the member to join immediately:\n\n\n\nMembership inside a Data Union offers a revenue share of funds that accumulate in the Data Union contract as well as data publishing rights to the collection of streams inside the Data Union.\n\nThe correct secret allows the member to join without manual approval from the Data Union Admin. If the secret is omitted, the Admin must login, find pending join requests in the Data Union Admin view of the product, and approve the requests manually.\n\nSimilar to deployDataunion, you should wait until the member has joined before querying the member‚Äôs stats. The Data Union member can check their earnings (minus earlier withdrawals) in every Data Union:\n\n\n\nAlso other interesting stats are available from the server:\n\n\n\nThe response would be something like:\n\n\n\nWithdrawing earnings\n\nEarnings in DATA token accumulate on the Data Union smart contract. Every active member has a claim to a fraction of these funds, as determined by their join date and the parameters of the Data Union smart contract. That claim is asserted when they make a withdrawal transaction.\n\n\n\nCheckout the JS client docs for further details on the withdrawal options.\n\nDATA tokens can be withdrawn to the mainnet or sidechain, (currently xDai). Withdrawing to the sidechain is recommended and from here the tokens can be swapped to some other tokens using a DEX (decentralized token exchange) present on that sidechain. The transaction fees on sidechains are orders of magnitude cheaper than on Ethereum mainnet, making it much more feasible to move around even small amounts of value. On xDai, transactions currently cost only fractions of a cent, compared to transactions costing tens or even hundreds of dollars on mainnet. \n\nWithout support from the Data Union Admin, the member will require a (very) small amount of xDai token (the native token of the xDai chain) to withdraw their funds from the Data Union to an address on the sidechain.\n\nThe Data Unions framework also support gasless withdrawals via metatransactions. This means that Data Union Admins can optionally pay the transaction fees on behalf of members, potentially enabling a better user experience. DATA tokens can also to be directly deposited to a particular member‚Äôs balance in the Data Union, allowing Data Union Admins to run referral campaigns that pay out personalised rewards (as opposed to the equal revenue sharing among members, the core feature of Data Unions).\n\nMembers of Data Unions that require support with withdrawing should reach out to the Data Union Admin and not Streamr as the Admin is best positioned to assist in all matters of the Data Union. Data Union Admins are encouraged to reach out for support from Streamr. Currently, the best way is on the Dev channel, inside our Discord.\n\nAutomatically generated API documentation is also available here. These docs are generated from the repository TypeScript source code.\n","section":"Data Unions","title":"Join & Withdraw"},"/docs/data-unions/ux-best-practices":{"id":"/docs/data-unions/ux-best-practices","content":"\n\nData Unions UX best practices\n\nIf you build a Data Union app or integrate Data Unions into an existing app, it needs to incorporate a simple crypto wallet because your users will receive revenue in DATA token. Below are a collection of features, suggestions and good usability practices you may want to include in your app.\n\nBalance, available balance and cumulative earnings\n\nBecause users can withdraw tokens from their primary Ethereum address to another wallet, showing both current total and cumulative earnings is a good idea, so users can know their historical earnings as well as the current balance.\n\n\n\nPrivate key handling\n\nBecause users may want to use another wallet for managing their funds, we strongly recommend offering private key access to all your users. Without this, they do not really have control of their own funds. When handling private keys, you need to allow users to access the private keys, but you should generally avoid displaying them on screen and keep them hidden from view.\n\nYou also need to inform your users about their responsibility for security, because it is entirely up to them. When onboarding, a good practice is to break the users flow of just blindly clicking onwards through key information. Using disabled, conditional buttons that require explicit agreement from the user will not solve all your problems, but might help to prevent some users from ignoring important warnings.\n\n\n\nWallet addresses\n\nProviding clear access and copy functionality to the user's wallet address is always good practice, so they can watch it via other applications, and check it with external services. When pasting addresses into wallet address fields, informing the user that the contents of the field match the clipboard, and also show the ETH & ERC-20 tokens held by that address helps to reduce user stress and avoids the common practice of double-checking addresses by copy-pasting them as text.\n\n\n\nFiat currency display\n\nAllowing your users to switch currency views between the DATA token and a standard fiat currency like USD is a good idea. If they use your app over a long time they might get accustomed to thinking in DATA, but don‚Äôt assume they will.\n\n","section":"Data Unions","title":"UX Best Practices"},"/docs/tutorials/building-pub-sub":{"id":"/docs/tutorials/building-pub-sub","content":"\n\nBuilding a simple pub/sub system\n\nBefore proceeding with this tutorial, we assume you have connected your Ethereum account and that you have also created your first stream.\n\nPublish to a stream\n\nThe easiest way to push data to a stream is to use one of our SDKs, currently available in Javascript, Java. Client libraries for other languages are on the roadmap. Here is an example of publishing data to a stream using Streamr Javascript client.\n\n\n\nInside the Core app, you can select the stream and monitor the data preview - your published messages will appear here in real-time.\n\n\n\nAdditionally, you can interact with the Streamr API using any HTTP library of your choice. You will find all the details in the API section. You will need to authenticate first before publishing data to any stream.\n\nOnce autenticated, you‚Äôll be making a HTTP POST request to a URL, which contains your stream ID. Please note that characters in the stream ID should be escaped using url encoding such as changing slashes to %2F. The body of the request will be your data payload in JSON. \n\n\n\nYou will need to get a session token to publish to a stream - all the different authorization options are explained in the: API docs.\n\n\n\nSubscribe to data\n\nAlong with publishing data to a stream, subscribing is best done with one of our SDKs. Depending on how you've configured the stream share permissions inside the core app, the subscriber may not need to authenticate. \n\nHere is the example from the Streamr JavaScript client readme on how to subscribe to a stream.\n\n\n\nCongratulations, you've now created a stream, published and subscribed to it üéâ\n","section":"Tutorials","title":"Simple pub/sub"},"/docs/data-token":{"id":"/docs/data-token","content":"\n\nDATA Token\n\nDATA is the cryptocurrency which powers the Streamr ecosystem in various ways. It is an ERC-20 token on the Ethereum blockchain.\n\nAdditional documentation coming soon\n","section":"DATA Token","title":"DATA Token"},"/docs/core/intro-to-core":{"id":"/docs/core/intro-to-core","content":"\n\nIntroduction to Core\n\nStreamr Core is the collection of open source applications developed and supported by Streamr that help you create, process, visualise and sell your real-time data. It allows you to create real-time data streams from your devices, grab free or paid data streams from our Marketplace, or build your own products and sell them. It keeps track of all of your resources and earnings and makes it all available in one easy to use interface.\n\nMain user interface\n\nThe main interface to the Core app contains a number of elements, including user profile, view switcher, main view panel (list or tile), create button, filter and sort controls,  quick help button and the app menu. The main views in the app are Streams, Products, Subscriptions and Transactions. There is also a Settings view accessed through the menu at top right (which shows the intials of your currently signed in account).\n\n\n\nCreate buttons\n\nTwo of the main views offer create functions; Streams and Products. Creating a stream or a product will take you into the relevant create flow. For more on this, see Working with Streams or Working with Products. \n\nUser profile\n\nYou can set or edit your profile image (useful in future iterations of the Marketplace), username, email address and Ethereum address by either going to the Settings menu (at upper right with your Eth Address) or by clicking on your profile image.\n\nFilter and sort\n\nLive filter works to filter your current Core view by keyword. It works on either tile or list views. Just click the search icon to open the filter. Sort is a contextual function, offering different options depending on which Core view you are in.\n\n\n\nQuick help\n\nThe quick help menu gives you fast access to the these docs and the main Streamr Discord so give it a try if you need some quick answers.\n\n\n\nTile and List submenus\n\nBoth tile (products and subscriptions) and list views (streams and transactions) offer per-item functions, accessed via a meatball menu from top right of tiles and right hand end of list views. Simply mouseover the item to see the menu.\n\n\n\nSharing resources in Core\n\nStreams are the main type of resource that can be shared with others. Streams can be shared from the main Streams view via the submenu or on the Stream edit page.\n\nWhen you share a resource, you can share it either privately or publicly. A private share means the link is only accessible to the users whose Ethereum address it has been shared with. A public share means anyone with the link ‚Äî and importantly, anyone using the public API ‚Äî can access your resource. \n\nTo share any resource, click share and paste in the Ethereum address of the person you want to share it with, and click +. Select the access level you want to give them, then hit Save to confirm.\n\n","section":"Core","title":"Intro to Core"},"/docs/core/sharing-resources-in-core":{"id":"/docs/core/sharing-resources-in-core","content":"\n\nSharing resources in Core\n\nWhen using the Core app, you can share your Stream resources with other Streamr user accounts. Streams are shared from the list item menu or the share button in the edit view.\n\n\n\nThe share sidebar\n\nWherever you access it from, all resources are shared from the sidebar. The general flow \nof sharing with the sidebar works like this.\n\nChoose private or public resource\n\nType the Ethereum address of the user you want invite to share\n\nChoose the permissions for that user, either via the role chooser or build a custom role by clicking the checkboxes\n\nAdd, remove or adjust permissions for as many people as you want\n\nClick Save to finalise any changes button before you close the side bar\n\nGet a confirmation ‚ÄúYour permissions have been updated‚Äù notification\n\n\n\nThe role chooser\n\nUsing the role chooser, you can assign a role with preset permissions, and then easily customise any role by adding or removing certain permissions. Click save to finalise any permission adjustments.\n\nPermissions and Roles\n\nThe matrix below outlines the role types and permissions for Streams.\n\n","section":"Core","title":"Sharing resources in Core"},"/docs/marketplace/introduction-marketplace":{"id":"/docs/marketplace/introduction-marketplace","content":"\n\nIntroduction to the Marketplace\n\nThe Marketplace is an application that enables users to buy and sell access to real-time data content on the Streamr Network. The Marketplace is filled with both paid and free products, offering data producers an opportunity to either monetise their data or make it freely available to everyone. Products have time-based subscription periods, and the currency used on the Marketplace is the DATA token.\n\n\n\nThe Marketplace is an open source project that builds on the Streamr Network and the Ethereum blockchain. Ethereum is used to store a registry of data products, coordinate access to them, and to provide a secure ledger of value transactions. Products are published to the Marketplace smart contract, and the contract allows data buyers to directly transact with sellers using the DATA token, removing all traditionally present middlemen and their fees. All of the data on the Marketplace is delivered peer-to-peer via the Streamr Network.\n\nGet data from the Marketplace\n\nMany products on the Marketplace are free. To access the streams of a free product, simply click Subscribe on the product page. The product will appear immediately in the Subscriptions view of Core, and the streams will be available for your use in the Streams view of Core. You don't need any DATA or Ether to subscribe to a free product.\n\n\n\nSubscribing to paid products\n\nInteracting with paid products requires an Ethereum wallet address, and a small amount of Ether, in order to pay the gas fees required to subscribe or publish the product. Getting access to a paid product requires a payment of DATA to the product owner.\n\n\n\nClicking the Subscribe button initiates the subscription dialog which guides you through the contract transaction process. Gaining access to the streams inside the product happens automatically once the transaction has been completed which usually takes no longer than a few minutes. A dialog will pop up where you select the desired access period.\n\n\n\nThe marketplace uses smart contracts to withdraw tokens from your account. In order to allow the smart contract to execute the transfer, an allowance must be set to give permission to withdraw up to a certain amount of your tokens. This is a security measure for ERC20 tokens that means that the smart contract will only ever be able to transfer the amount of tokens that you approve.\n\n\n\nTo complete the the allowance step, confirm the transaction in Metamask. After setting the allowance, you will be asked to confirm the payment.\n\n\n\nFinally, confirm the transaction in Metamask to complete your subscription. While the transaction is being mined, you can either wait for it to complete or continue browsing the Marketplace. You will be notified after it has completed.\n\n\n\nNote that while you may subscribe to products with any Web3 wallet, the subscriptions will not be visible until you link the account to your profile.\n","section":"Marketplace","title":"Intro to the Marketplace"},"/docs/sdk/overview":{"id":"/docs/sdk/overview","content":"\n\nSoftware Development Kits\n\nThere are both official and unofficial Software Development Kits (SDKs) available for building software that interacts with the Streamr platform. Using an SDK provides an effortless and reliable way to use Streamr from your software projects. The SDKs take care of the small details required to interact with Streamr through intuitive API libraries, allowing a developer to focus on their task at hand.\n\nCurrently, we provide official SDKs for JavaScript (browser and Node.js) and Java. There is also a community-built SDK for Python in the works. The range of features each of these SDKs provide may vary, so be sure to check the documentation of the specific SDK for more information. If your programming language or software environment of choice does not have an SDK available, you can still interact with Streamr using our JSON-based HTTP API.\n\nIn addition to the SDKs, there is the Command Line Interface (CLI) tool for interacting with Streamr. The CLI tool is a thin wrapper around the Streamr Javascript Client, which does the heavy lifting, while the tool concentrates on CLI concerns: parsing and passing arguments, stdin/stdout, errors, and so forth.\n\n\n\nHow to contribute\n\nContribute to these docs, or any of our open source projects is warmly welcomed!\nPlease get in touch on Discord, Reddit or email! Here is a guide on contributing to the Docs.\n","section":"SDKs","title":"Overview"},"/docs/sdk/javascript-sdk":{"id":"/docs/sdk/javascript-sdk","content":"\n\nJavaScript SDK\n\nThe JavaScript client library is available on npm to be integrated in your applications to interact with the Streamr API. The code and a comprehensive documentation are available on GitHub. Here is an example of how to create an authenticated client, publish and subscribe data using the JavaScript library.\n\nAutomatically generated API documentation is also available here. These docs are generated from the repository TypeScript source code.\n\n","section":"SDKs","title":"JavaScript"},"/docs/sdk/java-sdk":{"id":"/docs/sdk/java-sdk","content":"\n\nJava SDK\n\nThe Java client library is available on Maven Central which means it can be easily imported in your Java or Scala project. A comprehensive documentation and the code are available on GitHub. Here is an example of how to create an authenticated client, publish and subscribe data using the Java library.\n\n","section":"SDKs","title":"Java"},"/docs/sdk/python-sdk":{"id":"/docs/sdk/python-sdk","content":"\n\nPython SDK\n\nThe Python client library is available at this GitHub repo. If you are interested in contributing to this library, feel free to reach out via our Discord or submit directly a pull request.\n\n\n\nThis library is entirely community contributed and is being phased out.\n\n","section":"SDKs","title":"Python"},"/docs/api/api-overview":{"id":"/docs/api/api-overview","content":"\n\nAPI overview\n\nStreamr provides a set of APIs for easy integration with other systems. The APIs cover Authentication, data input, data output, and managing various resources within Streamr (such as Data Unions, streams and products).\n\nThere are RESTful HTTP endpoints that can be accessed using any HTTP library with ease. You can explore these endpoints using the API Explorer. You can expect:\n\nPredictable resource-oriented URL endpoints\n\nForm-encoded request bodies\n\nJSON-encoded responses\n\nStandard HTTP response codes, authentication, and verbs.\n\nThere are two APIs for requesting data from Streamr into external applications: the websocket-based streaming API, and the HTTP API. For efficiently publishing and subscribing to data in real-time, using the websocket API is recommended.\n\nThe streaming API can be used to control external applications using real-time events from Streamr. For example, you could push real-time stock prices into a mobile app, or update player positions in a multiplayer game. Or you could implement a thermostat by controlling warming or cooling based on a temperature measurement. The streaming API pushes new events to subscribed clients immediately when they become available.\n\nUsing a client library is recommended for most tasks and integrations:\n\n\n\nclient works in the browser as well as node.js. The package is available on npm.\n\n\n\nIf you'd like to contribute a client library and get it listed here, check out our section on contributing.\n\nAPI behaviour\n\nThe body of the request should be a JSON object, encoded in UTF-8, containing the key-value pairs representing your data.\n\nResponse codes\n\n\n\nData output over websocket\n\nThe websocket protocol is easiest to use with one of the available client libraries. If there isn't a client library available for your language, you can dive into the details of the websocket protocol.\n","section":"API","title":"API overview"},"/docs/api/authentication":{"id":"/docs/api/authentication","content":"Authentication\n\nA session token is required to make requests to the REST API endpoints or over the websocket protocol. You can obtain a session token by signing a cryptographic challenge using an Ethereum private key.\n\n\n\nAuthenticating options\n\nThe easiest way to authenticate is through the Streamr Client - it will handle the cryptographic signing for you. Client authentication instructions can be found in the repo readme.\n\nIf you prefer to use the REST API directly the you can use an Ethereum private key to authenticate by signing a challenge with it and providing your Ethereum public address for verification.\n\nUse the POST endpoint at /api/v1/login/challenge/YOUR-PUBLIC-ADDRESS to generate a random text called a challenge, which looks like the following: \n\n\n\nTo authenticate, you must provide a response before the challenge expires. You can do it with a POST to /api/v1/login/response. It must contain the challenge, the signature and the Ethereum address in the following format:\n\n\n\nThe signature must follow the convention described here. The secp256k1 ECDSA algorithm is applied on the keccak256 hash of a string derived from the challenge text:\n\nsign(keccak256(\"\\\\x19Ethereum Signed Message:\\\\n\" + len(challengeText) + challengeText)))\n\nIf the signature is correct, you will receive a session token.\n\n\n\nUsing the session token\n\nBy using one of the above authentication methods, you will obtain a session token response in the following format: \n\n\n\nYou can now use this session token to make authenticated requests by including an Authorization header on every HTTP request with content as follows:\n\nAuthorization: Bearer YOUR-SESSION-TOKEN\n\nThe session token's expiration will be reset on every request to prevent you from getting logged out while using the API. If the token expires, you can obtain a new one exactly as before.\n","section":"API","title":"Authentication"},"/docs/api/using-streams-via-api":{"id":"/docs/api/using-streams-via-api","content":"\n\nWork with streams via API\n\nWhile the Core UI can do just about everything you'd want to do with streams, sometimes the using the API directly is preferred.\n\nData output over HTTP\n\nEvents in streams can be queried via HTTP. Example using curl:\n\n\n\nThe following endpoint would return the 5 most recent messages in a stream (or to be more precise, the default partition 0 of a stream):\n\n\n\nThe HTTP API covers session management, data input, data output, and managing Streamr resources. The endpoints allow you to list, create, read, update and delete the resources. You best way to view all of streams endpoints is in the API explorer.\n","section":"API","title":"Work with streams via API"},"/docs/API-explorer":{"id":"/docs/API-explorer","content":"\n\nAPI Explorer\n\nThe API Explorer is a tool to investigate and test various endpoints on the Streamr API. You can read more about the tool here. Click the tile below to launch the API explorer in a new tab.\n\n","section":"API Explorer","title":"API Explorer"},"/docs/technical-notes":{"id":"/docs/technical-notes","content":"How to contribute\n\nContribute to these docs, or any of our open source projects is warmly welcomed!\nPlease get in touch on Discord, Reddit or email! Here is a guide on contributing to the Docs.\n\nStreamr protocol spec\n\nDocumentation coming soon\n\nRunning a private Streamr stack\n\nDocumentation coming soon\n","section":"Technical Notes","title":"Technical Notes"}}