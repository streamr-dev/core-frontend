{"/docs/welcome":{"id":"/docs/welcome","content":"\n\nStreamr Documentation\n\nWelcome to Streamr, the platform for real-time data on the decentralized web. Explore what you can do with Streamr below.\n\n\n\nKey Concepts\n\n\n\nStart with your use case\n\n\n\nExplore the project\n\n","section":"Welcome","title":"Welcome"},"/docs/learn/overview":{"id":"/docs/learn/overview","content":"\n\nOverview\n\nStreamr is an open source, crowdfunded, decentralized platform for real-time data. At its heart is the Streamr Network, which transports streams of messages from data publishers to subscribers, appearing to the user as a global publish/subscribe messaging service.\n\nIt is similar in functionality to message queues, enterprise messaging systems, MQTT brokers, Apache Kafka, or pub/sub cloud messaging services. The key features of such systems, including Streamr, are:\n\nPublishing messages in order to make them available to subscribers\n\nSubscribing to messages in order to process them as they occur\n\nStoring messages for later use\n\nYou can create and manage your streams using the Core user interface. In addition to the Network, the Streamr stack includes a Marketplace for data sharing and monetization.\n\nStreamr utilizes a companion blockchain, currently Ethereum and xDai. The blockchain provides users with secure digital identities, enables direct transfers of value in the form of a Streamr-specific cryptocurrency DATA, and provides a shared ground truth for the network nodes.\n\nWhy use Streamr?\n\nThe big difference to comparable data frameworks is that Streamr aims to be decentralized and peer-to-peer. Similar to cloud services, you get on-demand scalability, minimal up-front investment, and benefit from economies of scale. Unlike cloud services, there's no vendor lock-in, no monopolies, no proprietary code, and no need to trust a third party with your data. Decentralized networks are also secure by design, more resilient to attacks and disruptions due to their distributed and peer-to-peer nature. They also benefit from network effects— as adoption grows, the above points become stronger, a shared standard is formed across industries, and a lot of useful content becomes available from a single source.\n\nInstead of a centralized party, the Network is run by its community of users, and it relies on cryptography to remove the need for trust. This creates a permissionless and neutral network for real-time data, which is highly suitable for use cases such as data sharing, data monetisation, and the decentralized web, extending the capabilities of the underlying internet without compromising its open and decentralized nature.\n","section":"Learn","title":"Overview"},"/docs/learn/identity":{"id":"/docs/learn/identity","content":"\n\nIdentity\n\nYour Ethereum account is your Streamr account and identity - there's no email registration, simply login with your Web3 Ethereum wallet such as Metamask.\n\nStreamr supports ENS names to allow streams to have human readable names, for example mydomain.eth/traffic/helsinki. More on that in the Streams section.\n\nConnect your Ethereum Account\n\nThe easiest way to get started is through the free and open source Chrome browser extension, Metamask. Metamask is also available on Android and Apple mobile devices. The explainer video below will help you understand how to use Metamask.\n\n\n\nOnce you have your Ethereum account on Metamask, you can connect it to Streamr. A popup will ask you to sign a message with your Ethereum account to prove ownership, click Sign.\n\n","section":"Learn","title":"Identity"},"/docs/learn/use-cases":{"id":"/docs/learn/use-cases","content":"\n\nUse Cases\n\nThe Streamr network opens up a world of innovation by connecting unstoppable pub/sub real-time data transport to the vibrant ecosystem of decentralized applications.\n\nFor example, a stream can receive data from many sources (or publishers), and there can be several listeners who subscribe to a stream in many-to-one, one-to-many, or many-to-many applications. These are just a few examples. There is virtually no limit on the kind, format, or quantity of data you can feed into Streamr, even digital images, streaming video, or other domain-specific data could be pushed into a stream.\n\nData Monetisation\n\nBuy and sell access to ethically sourced data streams using Data Unions. Data Unions are a huge step forward in creating the fair data economy based on ethical first principles. The Streamr Network is idealogically aligned to this cause by providing a permissionlesss and community owned alternative to the data brokering monopolies that exist today.\n\nDevOps\n\nGather metrics from decentralized systems such as blockchain networks. Getting detailed real-time information about the state of nodes in your network is incredibly useful to diagnosing issues and improving performance.\n\nGaming\n\nThe Network is capable of being the real-time networking layer of massive multiplayer games. Light nodes can be run in the browser making for truly decentralized multiplayer experiences.\n\nIoT messaging\n\nPublish and broadcast messages from any kind of internet-connected device.\n\nSome common use cases include:\n\nSensory readings of speed and orientation\n\nGeolocation\n\nAmbient temperature and humidity \n\nSocial media messages\n\nStock market events\n\nMobile ad impressions\n\nNetworking middleware\n\nTransfer metadata for VoIP or WebRTC signalling.\n\nBlockchain networking\n\nDDoS resistant block transfer or broadcast signed transactions with low and predictable latency.\n","section":"Learn","title":"Use cases"},"/docs/learn/data-tokenomics":{"id":"/docs/learn/data-tokenomics","content":"\n\nDATA tokenomics\n\nThe DATA token is an ERC-20 token used for project governance, to incentivize the Network, to delegate stake on broker nodes, and for Marketplace payments. The token has also been bridged to the xDai sidechain with further multichain support on the horizon. \n\nHow it's used in the Streamr Network\n\nIn the Streamr Network, both data publishers and subscribers are nodes in a peer-to-peer network. Nodes involved in a stream of data connect to each other in a certain way – forming the stream’s topology – to perform the main function of the Streamr Network: the dissemination of messages published to that stream.\n\nSo every node that joins a stream both consumes data in that stream AND helps relay it onwards to other nodes interested in the stream. Since everyone who uses resources also contributes resources back to the network, can’t the system work without any token incentives, based on reciprocity alone?\n\nUnder perfect conditions perhaps, yes, but the real world is far from perfect. In practice, the reliability of message passing is reduced by the following\n\nChurn – Nodes joining and leaving the stream can add instability to the topology, which could disrupt message flow\n\nFree riders – In a decentralized network, there’s no way to enforce honest behaviour. Some nodes might selfishly consume messages but refuse to propagate them onwards\n\nMalicious nodes – Some nodes may intentionally try to disrupt the network\n\nNode failures – Nodes can crash, run out of memory, get overwhelmed with data, get disconnected, experience packet loss, etc.\n\nSo, very roughly, what determines the quality of service in a stream’s topology is the ratio of honest, stable nodes vs. nodes that perform questionably. If your use case needs honest, stable nodes to make your data flows more robust, how do you incentivise good nodes to join? Well, you pay them. This forms the basis of the token economics (tokenomics).\n\nTraditional software products often have freemium and paid plans. Decentralized protocols usually have more of a grayscale spectrum as a result of being subject to true market conditions – you pay more for better service. Gas price on Ethereum is a good example: you bid a higher gas price to incentivise miners to execute your transaction faster. A similar economy is at play on Streamr: you pay less (or even nothing) if you’re happy with best-effort performance, while you can pay to incentivise nodes to make your stream more robust and secure.\n\nFor the sake of clarity, the Streamr Network tokenomics should not be confused with the transactions happening on the Streamr Marketplace. On the Network, people pay for infrastructure costs; for data delivery. On the Marketplace, people pay for access to data content. Here’s an analogue: when you order an item from an online store, someone (either you or the store) pays the postal service for package delivery. You also pay the online store for the item you ordered, or the package content. Note that you can very well use the Network for data delivery without using the Marketplace at all, just like you can send and receive packages without ordering stuff from online stores.\n\nThe roles in the Streamr tokenomics\n\nPublishers and Subscribers are already familiar roles in the Streamr Network. These roles are only related to the data flows in the network, meaning these roles could be seen as being one layer ‘below’ the tokenomics. In the below diagrams, data flows are shown in blue.\n\nThe introduction of token economics defines three new roles: Sponsor, Broker, and Delegator. These roles use DATA tokens to participate in the incentive mechanisms, and those value flows are shown in the diagrams below in orange.\n\nIt should be noted that the roles are independent of each other and can be mixed and matched by all actors depending on their goals, for example, the same person could be a Sponsor, Publisher, and a Delegator.\n\n\n\nPublisher\n\nA Publisher is simply a node through which certain data enters the network. The data usually originates in an adjacent application that interfaces with the Publisher node, with the goal of delivering that data to Subscribers via the network. Publisher nodes relay the messages to other nodes they are connected to.\n\nSubscriber\n\nA Subscriber is a node in the network that wants to receive messages from a stream. Just like Publishers, they also relay the messages to other nodes they are connected to. Subscribers may have a range of different motivations for joining a stream – there could be an adjacent application that wants the data, they could be Brokers who mine the stream by becoming Subscribers (see below), or they may even want to help the stream simply for charitable reasons.\n\n\n\nSponsor\n\nSponsors pay to secure the operation of a stream. They pay DATA tokens into a smart contract called a Bounty. Essentially, the Sponsor says “I want to spend X amount of DATA tokens over a period of time T to improve stream S”. The Bounty contract releases the funds over time to Brokers who are mining the Bounty (see below to learn about Brokers). It should be noted that a stream can have many Sponsors, and they could be anyone at all, including the Publisher(s), Subscribers, or a third party.\n\n\n\nBroker Node\n\nBroker nodes are the miners in the Streamr Network. They are nodes that constantly monitor which Bounties are available – Bounties are smart contracts on the public blockchain, so they are visible to everyone. Broker nodes choose the Bounties they want to start mining, stake DATA on them, and become Subscribers in the related streams. The promise of the Broker is: \"I am an honest and stable node, and I’ll join the stream topologies to help stabilise and secure them\". Brokers don’t subscribe to a stream because they’re interested in the data, they join because they want to earn a share of the DATA tokens flowing through a Bounty. The Broker can claim their rewards periodically to withdraw earned tokens from the Bounty contract.\n\n\n\nBrokers are expected to be honest, following the protocol rule of properly forwarding messages to other connected nodes. And they are also expected to be stable, with good uptime along with sufficient bandwidth and hardware resources to handle the traffic of the stream. If they fail to meet these standards, they could be kicked out of the Bounty and their stake could be slashed.\n\nThe amount of DATA tokens the Broker stakes on the Bounty determines the size of their share of the token flow. The Broker will generally stake on Bounties where they can earn the best available yield for their stake. Other Brokers in a Bounty are there to share the cake, so overcrowded Bounties may not offer the best yields, and some Brokers will decide to mine other Bounties instead. Like any open market, the market of servicing Bounties will always gravitate towards achieving equilibrium between supply and demand.\n\n\n\nDelegator\n\nDelegators are DATA token holders who don’t want to do mining themselves, but would rather earn yield on their tokens by supplying liquidity to Brokers. In exchange, they earn a share of the Broker’s rewards. Since Brokers need to stake tokens to mine Bounties, having access to tokens from Delegators enables them to earn more from Bounties, creating a win-win situation.\n\nDelegators select Brokers to stake on and deposit tokens into the Broker’s Stake Pool smart contract. The funds in the pool can then be used by the Broker for staking on Bounties.\n\nObservability and free riding\n\nWhile the above processes and roles may seem quite straightforward, one of the key challenges is preventing Brokers that don’t actually do the work (of joining the stream’s topology and relaying messages to connected peers) from earning Bounties.\n\nSince the Brokers place a stake on the Bounties, they could be slashed for not doing the work. The problem is proving to the smart contract that a particular Broker did not do the work or otherwise live up to its promises. There’s limited observability in the network, as basically only the peers connected to a node really know what the node is up to. On the other hand, only the tracker knows which nodes are connected to each other. By combining attestations from a Broker’s peers as well as the tracker, it could be shown with reasonable confidence that a Broker did/didn’t fulfil the requirements of servicing the Bounty – potentially leading to slashing the Broker or at least kicking them out of the Bounty.\n\nThen again, the peers or the tracker could be malicious and give false attestations in order to harm a particular node! As you probably realise by now, this is pretty complex. As is usually the case with decentralized systems, nothing is foolproof and every such system has some conditions under which it fails or becomes less reliable. Understanding those conditions well is the key to establishing what parameters work in the real world and what guarantees can be given about the system in practice. And indeed, much of the remaining work is exactly in this area.\n","section":"Learn","title":"DATA tokenomics"},"/docs/learn/network-explorer":{"id":"/docs/learn/network-explorer","content":"Network Explorer\n\nThe Network Explorer is an application that brings visibility to the stream topologies inside the Streamr Network.\n\nThe network is highly dynamic, with a regular cast of broker nodes, but also a constantly revolving number of light nodes appearing and disappearing. Being able to explore it helps node runners inspect their nodes and diagnose any issues.\n\nThe Network Explorer allows users to see three key metrics for the entire network: \n\nTraffic (messages per second)\n\nBandwidth (MB/s)\n\nLatency in MS (averaged across all nodes in the topology). \n\nNode search\n\nYou can search for areas, say all nodes in Helsinki, streams by path name or description, as well as specific nodes by generated name or Ethereum address. \n\nStream topology exploration\n\nBy searching or selecting a stream, the nodes participating in the stream overlay will be shown in both the results list, and on the geo map. Selecting a node in this list gives you access to all the metrics, and as the full tokenomics rolls out in Tatum milestone, will also give access to the node’s Ethereum address, and link out to its transaction history on Etherscan.\n","section":"Learn","title":"Network Explorer"},"/docs/learn/glossary":{"id":"/docs/learn/glossary","content":"Glossary\n\nBroker node\n\nBroker nodes are the miners in the Streamr Network. They are nodes that constantly monitor Bounties requesting data relaying support in return for DATA tokens.\n\nCore app\n\nA user interface for creating and managing streams. GitHub Repo.\n\nData Union\n\nA Data Union framework provides a way to collect and package an individuals's real-time data together with others' with rich consent and while distributing a fair share of the revenue back to the users when someone pays to access it.\n\nGap fill\n\nGap fill is a the mechanism of requesting resends of missing messages in a message chain to help achieve delivery completeness. Messages in Streamr streams are chained, allowing for gap detection (detecting missing messages). For example, the client may receive the following sequence (simplified):\n\nMessage 1: Previous message was null\n\nMessage 2: Previous message was Message 1\n\nMessage 5: Previous message was Message 4\n\nThe client can now detect that they missed one or more messages that came after Message 2 but before Message 5. They do a \"gap fill\" to fill the gap, i.e. request a resend of messages from Message 2 (exclusive) up to Message 4 (inclusive).\n\nLight node\n\nLight nodes are bundled inside an application that uses Streamr to publish and/or subscibe to streaming data. Light nodes are not extendable like Broker nodes and cannot 'mine' other streams for DATA tokens.\n\nStream\n\nA stream is simply a sequence of data points in time, i.e. an append only log. This is semantically equivalent to topics in traditional pub/sub networks. \n\nStorage node\n\nA Streamr network node that subscribes to data with a commitment to store the data and make it available for retrieval requests.\n\nTopology\n\nArrangement on nodes that participate in the dissemination of messages inside a stream.\n\nTracker\n\nTrackers are a type of Streamr node that build and maintain peer to peer stream topologies.\n","section":"Learn","title":"Glossary"},"/docs/learn/how-to-contribute":{"id":"/docs/learn/how-to-contribute","content":"\n\nHow To Contribute\n\nContributions to these docs, or any of our open source projects is warmly welcomed!\n\nYou can find others developing on Streamr, as well as get in touch with the Streamr core contributors: Discord\n\nYou can also reach out to the core team over email! Here is a guide on contributing to the Docs.\n","section":"Learn","title":"How to contribute"},"/docs/streamr-network/intro-to-streamr-network":{"id":"/docs/streamr-network/intro-to-streamr-network","content":"\n\nIntro to the Streamr Network\n\nThe Streamr Network is a peer-to-peer network for publishing and subscribing to data in real-time. Applications use it for decentralized messaging, for example sharing data across applications or broadcasting information to large audiences. The decentralized nature of the system makes the data transport scalable, robust, secure, tamper proof, and censorship resistant.\n\nThe Streamr Network consists of nodes that interconnect peer-to-peer using the Streamr protocol. Together, the nodes in the Network form a topic-based publish-subscribe messaging system. Topics in this messaging system are called streams. The job of the Network is to deliver published streams of messages to all subscribers of that stream. \n\nThe Streamr Network is a building block for decentralized applications - a message transport middleware, enabling any number of parties to distribute or exchange information without directly coupling or relying on a central server to broker data. Read more about various use cases.\n\nIntro to Streamr nodes\n\nApplications publish and subscribe to streams via Streamr nodes. In other words, nodes are the access points to the Streamr Network. To connect your application to streams, you interface it with a Streamr node.\n\nThere are two strategies for interfacing applications with Streamr nodes:\n\nLight nodes: the node is imported to your application as a library and runs locally as part of your application\n\nBroker nodes: the node runs separately, and your application connects to it remotely using one of the supported protocols\n\nWhich approach to choose depends on your use case. Here are some commonly used decision criteria:\n\nIf you are developing in JS, use light nodes. For other programming languages, use Broker nodes.\n\nIf your application runs on very limited CPU, memory, or bandwidth (such as battery-powered or embedded devices), use Broker nodes.\n\nIf you want the data to be cryptographically signed at the source, use light nodes.\n\nLight nodes\n\nLight nodes are Streamr nodes that run locally as part of your application instance. You use it exactly like any other library: you import it to your application and interface with it using function calls.\n\nThis is the most decentralized approach as it doesn't require you to host Streamr nodes separately, but on the other hand it requires a Streamr node implementation to exist for the programming language you're using. So far, the Streamr node has only been implemented in JS, meaning that light nodes can be used in web applications as well as Node.js-based applications.\n\nRead more about using a light node.\n\nBroker nodes\n\nBroker nodes are Streamr nodes that run externally to your application. You start up a node on a server, and interface with it remotely using one of the supported protocols. \n\nThe Broker node ships with plugins for HTTP, Websocket, and MQTT protocols. Libraries for these protocols exist in practically every programming language, meaning that you can conveniently publish and subscribe to data from the Streamr Network using any programming language.\n\nBroker nodes have a plugin architecture that allows them to perform other tasks in addition to (or instead of) serving applications, such as mining.\n\nLearn how to install a Broker node and connect applications to it.\n\nFurther reading\n\nMost readers of these docs will seek information about using the Streamr Network in their applications. To understand how the Network and nodes actually work under the hood, the technicalities are discussed at length in the the Network page. A stylish nutshell representation of the Network is available on the Network page of the project website.\n","section":"Streamr Network","title":"Intro to the Streamr Network"},"/docs/streamr-network/using-a-light-node":{"id":"/docs/streamr-network/using-a-light-node","content":"\n\nUsing a light node\n\nLight nodes are Streamr nodes that run locally as part of your application instance. You use it exactly like any other library: you import it to your application and interface with it using function calls.\n\nThe Streamr light node is packaged as a JavaScript library. It runs in Node.js as well as the browser. If you're developing in a programming language other than JS, run a Broker node instead and connect your application to it.\n\nImporting a light node\n\nThe StreamrClient library wraps a light node, which the library uses for publishing and subscribing to data. The library is available on npm as package streamr-client. This article contains quick usage instructions, but for more detailed instructions please refer to the streamr-client library itself.\n\nInstall the library using npm:\n\n\n\nWhen using Node.js, import the library with:\n\n\n\nThe current stable version of the Streamr Client is 5.x (at the time of writing, December 2021). The Brubeck era client, (currently available as an alpha build) is version 6.x and above. The developer experience of the Streamr Client in 5.x and 6.x is the same, however, the 6.x client also runs as a light node in the network, whereas the 5.x era client communicates to a Streamr run node remotely. When the Streamr Network transitions into the Brubeck era (ETA 2021) data guarantees of 5.x clients may need to be reassessed.\n\n\n\nCreate an instance of StreamrClient, authenticated with an Ethereum private key:\n\n\n\nLearn more about how Ethereum keys are used for identity on Streamr.\n\nSubscribing to real-time messages in a stream\n\nBy subscribing to a stream, your application gets immediately notified about new messages in the stream.\n\n\n\nPublishing messages to streams\n\nWhen you publish messages to a stream, they get delivered by the peer-to-peer network to all subscribing nodes.\n\n\n\nFor more detailed instructions, please refer to the streamr-client library itself.\n\nStaying safe\n\nDon't share your private key to anyone. If someone gets access to it, they can publish and subscribe as you, and steal any tokens you might have in that wallet! Read more about identity, keys, and wallets.\n","section":"Streamr Network","title":"Using a light node"},"/docs/streamr-network/installing-broker-node":{"id":"/docs/streamr-network/installing-broker-node","content":"\n\nSetting up a Broker node\n\nBroker nodes are Streamr nodes that run externally to your application. You start up a node on a server, and interface with it remotely using one of the supported protocols.\n\nThe Broker node ships with plugins for HTTP, Websocket, and MQTT protocols. Libraries for these protocols exist in practically every programming language, meaning that you can conveniently publish and subscribe to data from the Streamr Network using any programming language. Learn how to connect your applications to your node using one of these protocols.\n\nWhen applications use the Streamr Network via a Broker node, data signing, encryption, validation, and other complex cryptography happens at the node. This offloads processing from the application, and is also suitable for environments with limited hardware resources.\n\nTwo ways to run your node\n\nThe software comes in two flavours of packaging: a Docker image and an npm package.\n\nWhich method should you choose? If you have either Docker or Node.js (14.x or newer) already installed, use the one you know. Otherwise, try the Docker approach first, and if that doesn’t work for you, go for the npm approach.\n\nOnce you have either Docker or Node.js installed, the steps to download and start the node are very similar, regardless of whether you’re running Linux, macOS, or Windows (use PowerShell). You may need to adapt the commands for your platform or install OS-specific dependencies, if they are missing.\n\nThe configuration wizard\n\nAs part of both approaches, we show how to run the configuration wizard to initialize your node’s config file, which will be saved on your disk. The wizard will let you either generate or import an Ethereum private key for your node, as well as ask which plugins you want to enable.\n\nThe Docker approach\n\nIf you don’t have Docker, get it here. Once installed, you can download, configure, and start the Streamr Broker.\n\nStep 1: Set up a directory to be mounted into a running Docker container\n\nYou’ll need a place in the host operating system where the Broker configuration file will be stored. This directory will be mounted into the running Docker container so that it persists and remains accessible outside of Docker.\n\nCreate the directory with the command:\n\n\n\nStep 2: Configure your node with Docker and Config Wizard\n\nStart the config wizard with the below command. Docker will download the Broker image unless you have it already.\n\nLinux / macOS\n\n\n\nWindows PowerShell\n\n\n\nGenerate or Import Ethereum private key: generate one unless you have one you want to use with the node\n\nPlugins to enable: select the interface protocols you're planning to use and press 'enter'\n\nSelect ports for plugins: press 'enter' for each one to use the defaults\n\nPath to store the configuration: press 'enter' to use the default\n\nTowards the end, the wizard asks if you would like it to display your Ethereum private key. From here you should copy-paste it to a safe place! You can also find it later in the configuration file, which is saved by default to .streamrDocker/broker-config.json under your home directory.\n\nStep 3: Start the Broker Node using Docker\n\nStart the node with the below command:\n\nLinux / macOS\n\n\n\nWindows PowerShell\n\n\n\nYou should start to see logging similar to this:\n\n\n\nThe npm approach\n\nIf you don’t have Node.js, install it using nvm or manually from the Node.js site. The Broker requires at least Node.js version 14.x. Once installed, you can download, configure, and start the Streamr Broker.\n\nStep 1: Install the latest version using npm\n\nRun npm install -g streamr-broker to download and install the package. You may need administrative access to run this command.\n\n\n\nThere can be plenty of output from npm. If the installation fails with an error, you should address it before continuing.\n\nStep 2: Configure your node with streamr-broker-init\n\nRun streamr-broker-init to generate a configuration file using a step-by-step wizard. Answer the questions by using arrow keys and ‘enter’ to navigate.\n\nGenerate or Import Ethereum private key: generate one unless you have one you want to use with the node\n\nPlugins to enable: select the interface protocols you're planning to use and press 'enter'\n\nSelect ports for plugins: press 'enter' for each one to use the defaults\n\nPath to store the configuration: press 'enter' to use the default\n\nTowards the end, the wizard asks if you would like it to display your Ethereum private key. From here, you should copy-paste it to a safe place! You can also find it later in the configuration file, which is saved by default to .streamr/broker-config.json under your home directory.\n\nStep 3: Start the Broker node\n\nRun streamr-broker to start the node! You should start to see logging similar to this:\n\n\n\nStaying safe\n\nThe config file contains your node’s private key. If someone gets access to the private key, they can publish and subscribe as you, and steal any tokens you might have in your node's wallet! Read more about identity, keys, and wallets.\n\nKeeping up to date\n\nLearn how to keep your node up to date.\n\nUsing your Broker node\n\nNext, use your node to publish and subscribe data by connecting your application, or learn about mining.\n","section":"Streamr Network","title":"Installing a Broker node"},"/docs/streamr-network/updating-broker-node":{"id":"/docs/streamr-network/updating-broker-node","content":"\n\nUpdating a Broker node\n\nThis article shows how to update your existing Streamr Broker node to the latest version. If you are installing your node for the first time, follow installing a Broker node instead.\n\nUpdating to the latest version\n\nUpdates become available for both the NPM and Docker versions of the Broker node software. As with the installation guide, there are two sets of instructions here, for Docker and NPM. Note that there is no need to run the config wizard again.\n\nUpdating a node running on Docker\n\nStop the currently running Broker as follows:\n\nIdentify and record the container ID of your node by running docker ps\n\nThen, docker stop &lt;container_ID>\n\nNext, pull the latest version of the Broker node software,\n\n\n\nThen start the container as usual - or refer to the installation guide for the start command.\n\nUpdating a node via NPM\n\nStop your existing broker node process (Ctrl+C for example)\n\nThen, npm install -g streamr-broker\n\nStart the node using the streamr-broker command as usual.\n\nIf you have any problems updating with npm, you could try running npm doctor to diagnose the symptoms.\n\nThese instructions have been tested on Linux and macOS and may vary on Windows.\n","section":"Streamr Network","title":"Updating a Broker node"},"/docs/streamr-network/connecting-applications":{"id":"/docs/streamr-network/connecting-applications","content":"\n\nConnecting applications to a Broker node\n\nThe Broker node ships with interface plugins, which can be used to publish and subscribe to data from applications over off-the-shelf protocols HTTP, Websocket, and MQTT.\n\nConfiguration\n\nThe plugins are enabled and configured in the Broker config file. To generate a config file and enable the plugins you need, you can use the config wizard.\n\nAuthentication\n\nThe plugins expose ports and API endpoints which can be used to publish and subscribe to data using the identity of the Broker node. You will want to secure those ports, either by setting up a firewall and restricting access to the ports based on IP, or configuring API keys that only allow access if the API key is provided.\n\nThe API keys can be configured in the Broker config file, in a top-level field apiAuthentication:\n\n\n\nBy knowing any of the correct API keys, the applications are granted access to the node. The API keys are passed by the application in slightly different ways depending on which protocol is used.\n\nNote that the API keys grant access to publishing and subscribing via your node, while the node's private key grants access to your node's identity and assets. Never confuse API keys and the node's private key, and never send the private key over the internet.\n\nUsage\n\nThe configuration and usage of each of the plugins is documented here.\n","section":"Streamr Network","title":"Connecting applications"},"/docs/streamr-network/mining":{"id":"/docs/streamr-network/mining","content":"\n\nMining\n\nBroker nodes will be able to participate in mining via a mining plugin that is included with the Broker node. Mining means that the Broker node subscribes to selected incentivized streams and helps propagate the messages in those streams, essentially contributing bandwidth to the stream in exchange for earning DATA tokens from associated Bounty smart contracts.\n\nThe mining process and associated token economics are described at a high level on the DATA token page on the project website, as well as in the Tokenomics section of the docs.\n\nComing in Tatum\n\nThe full token economics along with the mining features will be launched in the Tatum milestone in 2022. \n\nIn the meanwhile, a simplified form of mining was possible in the Brubeck milestone incentivized testnets in late 2021. At the time of writing, mining incentives for the Brubeck mainnet had not yet been decided by the Streamr governance process. \n\n\n\nThis section will be updated once mining becomes available.\n\n","section":"Streamr Network","title":"Mining"},"/docs/streams/intro-to-streams":{"id":"/docs/streams/intro-to-streams","content":"\n\nIntro to streams\n\nA stream is simply a sequence of data points in time, i.e. an append only log. This is semantically equivalent to topics in traditional pub/sub networks.\n\nAll of the data in the Streamr network is contained inside individual streams. The data may originate, for example from machines on the factory floor, sensors in a smart city, in-house databases or systems, or from commercial streaming data feeds.\n\nStreams have the following properties:\n\nAny kind of real-time data can be stored in it.\n\nThe data will always be retrieved in the correct order.\n\nThe data is persisted on the Streamr network and identifiable by unique ID.\n\nExample stream\n\nHere’s an example of what a small part of a stream could look like. Each row shows one data point, and the columns correspond to the timestamp followed by two data fields, a measurement of the operating temperature and the number of rotations per minute (RPM).\n\n\n\nStream data fields\n\nA field is a kind of placeholder for an individual piece of data, from a single data point. Each data point contains at least one data field, but you can have as many fields per data point as required.\n\nFor example, here's a data point in a stock market stream.\n\n\n\nGiven the structure of this data point, the stream's fields could be configured as follows:\n\n\n\nData field types\n\nThere’s a number of built-in data types that can be used in a stream. These are:\n\nNumber is a numeric data type internally stored as a double precision (64-bit) float.\n\nBoolean is a logical data type with two possible values, True and False. In Streamr, a numeric value exactly equal to one represents logical truth. Anything else is interpreted as a logical falsehood.\n\nString is a sequence of zero or more alphabetical characters.\n\nObject is a collection of key-value pairs. Each key is a string, and the value can be of any built-in data type (even another object). Object is equivalent to Java's 'Map'.\n\nList is an ordered collection of zero or more elements. List is equivilent to an array.\n\nField types can be freely mixed in a single data point. And you can freely add new fields to an existing stream; you don’t have to know what fields you might eventually need. A single data point can be of any size within reason, and a stream can grow indefinitely when extended by new data points.\n","section":"Streams","title":"Intro to streams"},"/docs/streams/creating-streams":{"id":"/docs/streams/creating-streams","content":"\n\nCreating streams\n\nStreams are identified by a unique and immutable stream ID, which consists of a domain and a user-given path, just like an Internet URL. The domain is either an Ethereum address of the logged in user, or it can also be an ENS (Ethereum Name Service) name owned by the Ethereum address of the logged in user. All streams require a unique path in the format of domain/pathname and can contain single or multi-level paths.\n\nENS names allow streams to have human readable names, for example mydomain.eth/traffic/helsinki. If you haven’t used an ENS name before, you can easily create one with a small amount of ETH on ENS Domains. Your purchased addresses will automatically appear in the Core app for immediate usage. At a future date, the stream registry will live on the blockchain.\n\n\n\nPlease remember, you may need to escape the pathname slash depending on your coding environment. The Streamr client will escape the pathname slashes so also take care not to escape the pathname twice.\n","section":"Streams","title":"Creating streams"},"/docs/streams/managing-your-streams":{"id":"/docs/streams/managing-your-streams","content":"\n\nManaging your streams\n\nStreamr Core provides you with the tools to create, edit, share and delete your streams as well as view and inspect the streams you have subscribed to on the Marketplace.\n\nHead over to the Streams page to see an overview of your subscribed streams. The list includes streams you have created and streams that you have subscribe to on the Marketplace.\n\n\n\nThe stream listing page displays all the streams the current user has the right to publish or subscribe to. Clicking on a stream will open the stream editor. You may only edit streams that you have created or have explicit permission to edit.\n\nStream status\n\nTraffic light indicators can show you at a glance when data was last pushed to each stream. \n\nGreen: The stream is active \n\nGrey: The stream is inactive\n\nRed: There is a problem with the stream\n\nThe criteria for an inactive stream is defined in the stream editor.\n\nEditing a stream\n\nThe stream editor provides basic tools for setting up, inspecting and editing your stream. Below is a run-down of each stream editor section.\n\nDetails\n\nThe details section provides basic information about your stream.\n\nThe stream name is used to identify your stream in the Core app.\n\nThe stream description can be used to offer more information about your stream and the kind of data it contains.\n\nThe stream ID is the unique and immutable identifier for your stream.\n\n\n\nConfigure\n\nIn this section you can configure stream fields and their data types. All fields have a name and a data type. The Autodetect feature can be used to automatically deduce fields from the stream's last received message. It is possible to manually correct the data types if automatic detection is not suitable for your stream.\n\n\n\nYou can also optionally toggle on the requirement for all messages to be signed to enforce a level of verification if you choose.\n\nPreview\n\nThis section is used to preview data flowing into the stream. Use the live inspector to make sure your stream is receiving data and it is correctly formatted.\n\n","section":"Streams","title":"Managing your streams"},"/docs/streams/publish-and-subscibe":{"id":"/docs/streams/publish-and-subscibe","content":"\n\nPublish and Subscribe\n\nBring your data to Streamr in the way that works best for you — as a JS library within your app, or from any application/langauge via MQTT, HTTP or Websocket.\n\nPublish and Subscribe via JS library\n\nThe Streamr client library wraps a Streamr light node for publishing and subscribing to data, and contains convenience functions for creating and managing streams. You can insert a node into any application where JavaScript runs, including the browser.\n\nCheckout the docs section for Using a light node.\n\n\n\nThe current stable version of the Streamr Client is 5.x (at the time of writing, December 2021). The Brubeck era client, (currently available as an alpha build) is version 6.x and above. The developer experience of the Streamr Client in 5.x and 6.x is the same, however, the 6.x client also runs as a light node in the network, whereas the 5.x era client communicates to a Streamr run node remotely. When the Streamr Network transitions into the Brubeck era (ETA 2021) data guarantees of 5.x clients may need to be reassessed.\n\n\n\nPublish and subscribe via MQTT, HTTP or Websocket\n\nYou will need to run a Broker node and interface to it with either MQTT, HTTP or Websocket. Checkout the docs section for Connecting Applications. \n\nData preview\n\nInside the Core app, you can select the stream and monitor the data preview - your published messages will appear here in real-time.\n\n","section":"Streams","title":"Publish and subscribe"},"/docs/streams/access-control":{"id":"/docs/streams/access-control","content":"\n\nStream access control\n\nThe matrix below outlines the role types and permissions for streams.\n\n\n\nSharing streams in core\n\nWhen using the Core app, you can share streams with other Etheruem accounts using the Share sidebar. This sidebar can be accessed from the stream list item menu or the share button in the stream edit view.\n\n\n\nTo update and edit a stream's access control, follow these steps:\n\nChoose private or public stream\n\nType the Ethereum address of the user you want invite to share\n\nChoose the permissions for that user, either via the role chooser or build a custom role by clicking the checkboxes\n\nAdd, remove or adjust permissions for as many people as you want\n\nClick Save to finalise any changes button before you close the side bar\n\nGet a confirmation “Your permissions have been updated” notification\n","section":"Streams","title":"Access control"},"/docs/streams/storage":{"id":"/docs/streams/storage","content":"\n\nData storage\n\nThe data in the Streamr Network is stored in storage nodes. You can enable data storage on your streams to retain historical data in one or more geographic locations of your choice. You can also choose how long to store your stream’s historical data before auto-deletion.\n\n\n\nBy default, no storage nodes are selected. You can opt-in to storage by selecting a storage node. At the moment, there is only one available option: Streamr Germany. However, new options will be added as they become available.\n","section":"Streams","title":"Storage"},"/docs/streams/data-signing-and-verification":{"id":"/docs/streams/data-signing-and-verification","content":"Data signing and verification\n\nAuthenticity and integrity of events published on a stream can be guaranteed with digital signatures. Every stream's metadata has a boolean requiresSignedData that can be set by the stream's owner to let subscribers know whether they should expect signed or unsigned events.\n\nEvery message published to a stream has six fields that uniquely identify this message across time, all streams and all publishers:\n\nstreamId\n\nstreamPartititon\n\ntimestamp\n\nsequenceNumber\n\npublisherId\n\nmsgChainId\n\nMore details about these fields can be found in the protocol specification. All together they form the message ID. They must be signed along with the actual message  content to resist against replay attacks. So the payload to be signed for every message by every publisher is the following.\n\n\n\nThe signing algorithm follows the convention described here. The secp256k1 ECDSA algorithm is applied on the keccak256 hash of a string derived from the challenge text.\n\n\n\nOn the recipient side, every subscriber needs to verify signed events. If a received event is unsigned, the subscriber accepts the event if and only if the stream's boolean flag requiresSignedData is set to false. The signature verification is done in three steps:\n\nThe subscriber extracts from the event and the signature the Ethereum address that signed the message (using the EC recover operation).\n\nCheck that the address recovered in step 1 matches the address defined by publisherId\n\nCheck that this publisherId belongs to the set of valid publishers for that stream by querying the api/v1/streams/${id}/publishers endpoint.\n\nBoth signature computation and verification are implemented in the JavaScript and Java SDKs.\n","section":"Streams","title":"Data signing & verification"},"/docs/streams/end-to-end-encryption":{"id":"/docs/streams/end-to-end-encryption","content":"\n\nEnd-to-end encryption\n\nConfidentiality of events published on a stream can be guaranteed with end-to-end encryption. The publisher decides on a AES-256 symmetric group key and encrypts the messages in CTR mode before publishing them to the network. The subscribers must know this symmetric group key in order to decrypt the data.\n\nCurrently, the symmetric key must be shared between the publisher and the subscribers in a secure way outside of the Streamr Network. The publisher can pass group keys per stream as parameters and the subscriber can pass group keys per stream and per publisher as parameters. Later it will be possible to use a secure key-exchange protocol directly in the Streamr Network.\n\nIn order to prevent new subscribers to eavesdrop and then decrypt past messages published before the start of their subscription, the publisher can decide at any time to update the symmetric group key by sending a new key concatenated with an event and encrypted with the current key:\n\n\n\nBoth the Javascript and the Java SDKs support this key update mechanism. It can be triggered by calling the publish method with a new symmetric group key as parameter.\n\n\n\nThe current stable version of the Streamr Client is 5.x (at the time of writing, December 2021). The Brubeck era client, (currently available as an alpha build) is version 6.x and above. The developer experience of the Streamr Client in 5.x and 6.x is the same, however, the 6.x client also runs as a light node in the network, whereas the 5.x era client communicates to a Streamr run node remotely. When the Streamr Network transitions into the Brubeck era (ETA 2021) data guarantees of 5.x clients may need to be reassessed.\n\n","section":"Streams","title":"End-to-end encryption"},"/docs/streams/partitioning":{"id":"/docs/streams/partitioning","content":"\n\nPartitioning\n\nTo be precise, when messages are published to a stream, they are actually published to a partition within that stream. Partitions can be understood as sub-streams, or in other words, parts of a stream. One partition per stream is the default, which is sufficient for streams with moderate rates of data (approx. less than 100 msg/sec).\n\nWhen a stream needs to handle large data rates, partitions are used for sharding of the data. Sharding data simply means dividing a large volume of messages to multiple partitions, a bit like a large river can split the same amount of water to multiple smaller branches. Each partition shares the general properties of the parent stream, such as name, description, and user permissions, but the partitions behave independently when it comes to delivering and storing data in the Streamr Network, which allows for scalability.\n\n\n\nPartitions also enable subscribers to scale horizontally: a user consuming data from a stream could load balance the messages over a number of consuming processes, up to the number of partitions. So if a stream has 5 partitions, the user could start up to 5 independent subscribers on separate physical machines, with each subscriber receiving different messages (each process subscribes to a unique partition).\n\nPartitions are identified by a number which starts from zero. For example, a stream with only one partition contains the partition 0 and all of the stream's data flows through this partition. A stream with 5 partitions has partitions 0 through 4 - here the stream's data is distributed across these 5 partitions. The data publisher is free to choose the target partition for each message. If no partition is specified, the data goes to partition 0.\n\nWhile the data publisher is free to choose a target partition for a message arbitrarily, a common approach is to utilize a partition key. A partition key is a value chosen from the data which is used to determine the partition of the message. For example, a customer ID could be used as a partition key in an application that publishes customer interactions to a stream. This way, all messages from a particular customer always go to the same partition. This is useful because it keeps all the events related to a particular customer in a single and known partition instead of spreading them over all partitions.\n\n\n\nThe publish methods in the Streamr client usually take an optional partitionKey parameter. For example:\n\n\n\nInternally, the library maps the partitionKey to a partition number using a hash function (modulo the number of partitions in the stream):\n\n\n\nAt the time of writing, there are some limitations with multi-partition streams: The number of partitions can only be set when creating streams via the API, and the number cannot be changed afterwards.\n\n\n\nCurrently partitions don’t have well-defined rate limits, but future versions of the P2P network may enforce limits. For now, we recommend not exceeding around 100 msg/sec/partition.\n","section":"Streams","title":"Partitioning"},"/docs/marketplace/introduction-marketplace":{"id":"/docs/marketplace/introduction-marketplace","content":"\n\nIntroduction to the Marketplace\n\nThe Marketplace is an application that enables users to buy and sell access to real-time data content on the Streamr Network. The Marketplace is filled with both paid and free products, offering data producers an opportunity to either monetise their data or make it freely available to everyone. Products have time-based subscription periods, and the currency used on the Marketplace is the DATA token.\n\n\n\nThe Marketplace is an open source project that builds on the Streamr Network and the Ethereum blockchain. Ethereum is used to store a registry of data products, coordinate access to them, and to provide a secure ledger of value transactions. Products are published to the Marketplace smart contract, and the contract allows data buyers to directly transact with sellers using the DATA token, removing all traditionally present middlemen and their fees. All of the data on the Marketplace is delivered peer-to-peer via the Streamr Network.\n\nGet data from the Marketplace\n\nMany products on the Marketplace are free. To access the streams of a free product, simply click Subscribe on the product page. The product will appear immediately in the Subscriptions view of Core, and the streams will be available for your use in the Streams view of Core. You don't need any DATA or Ether to subscribe to a free product.\n\n\n\nSubscribing to paid products\n\nInteracting with paid products requires an Ethereum wallet address, and a small amount of Ether, in order to pay the gas fees required to subscribe or publish the product. Getting access to a paid product requires a payment of DATA to the product owner.\n\n\n\nClicking the Subscribe button initiates the subscription dialog which guides you through the contract transaction process. Gaining access to the streams inside the product happens automatically once the transaction has been completed which usually takes no longer than a few minutes. A dialog will pop up where you select the desired access period.\n\n\n\nThe marketplace uses smart contracts to withdraw tokens from your account. In order to allow the smart contract to execute the transfer, an allowance must be set to give permission to withdraw up to a certain amount of your tokens. This is a security measure for ERC20 tokens that means that the smart contract will only ever be able to transfer the amount of tokens that you approve.\n\n\n\nTo complete the the allowance step, confirm the transaction in Metamask. After setting the allowance, you will be asked to confirm the payment.\n\n\n\nFinally, confirm the transaction in Metamask to complete your subscription. While the transaction is being mined, you can either wait for it to complete or continue browsing the Marketplace. You will be notified after it has completed.\n\n\n\nYou may subscribe to products with any Web3 wallet.\n","section":"Marketplace","title":"Intro to the Marketplace"},"/docs/marketplace/creating-data-products":{"id":"/docs/marketplace/creating-data-products","content":"\n\nCreate a Product\n\nIn the Streamr Marketplace, you can buy and sell a variety of real-time data products, and if you have access to your own real-time data, you can make and sell your own within the Core app. A product is a single stream or bundle of real-time data streams either sold or made available for free on the Marketplace. These streams typically originate from sensors or applications. You can also create crowdsourced data products with Core, where they are called Data Unions.\n\nCore and the Marketplace support crypto token payments using Streamr's native token DATA, DAI or ETH. To create or subscribe to paid products, you will need an Ethereum wallet, some ETH for gas, and some DATA, ETH or DAI, if making subscriptions. Below we'll run through the basics of creating a product.\n\n\n\nCreate a product in Core\n\nCreating a product in Core is quite simple, but requires some preparation. Once you're ready, simply go to Core > Products and click Create Product But before you do, you should prepare the various things listed below. If you get stuck halfway through, you can click Save & Exit at any time, and Streamr will keep a draft of your product. When you come back, simply click on the draft product tile in Core > Products to continue.\n\nThe Product edit validator helps you to see what is required for publishing. If you see an orange ! icon there, it means you've skipped a section required. Once all the required sections have blue ticks, you're ready to publish.\n\n\n\nPrepare your streams\n\nYou need some real-time streams, added to Streamr. You can do this in Core > Streams by clicking Create Stream This will open the Stream editor, and create an empty stream container, with a unique ID. Then all you need to do is\n\nCopy the ID to use in your code to pipe data into Streamr\n\nTest whether data is flowing correctly by using the Preview section\n\nField names, type and order should be auto-configured by Streamr\n\nIf they aren't, you can manually name the fields, select a type, and drag to reorder them\n\nAdd your streams\n\nAll streams you have added to your Streamr account will show in the stream selector part of the Product Editor. Click to select as many streams as you like, but do consider how to best provide value to your buyers.\n\n\n\nCover images\n\nYou will need a good cover image. If you have a designer who can help, this is ideal, otherwise you can find many high quality free images at Unsplash.com or Reshot.com. Make sure your image is around 1000-1200 pixels on the long side so it is sharp even on large, high-dpi screens. Something thematically related to your data is good if you don't have custom imagery for it. If you upload the wrong one, just upload another and it will be replaced.\n\nDescription\n\nWrite a good description, be concise, but give enough details for buyers to understand the value of your data. You can use Markdown to format headlines and lists, but do remember to keep it simple. You can write as much as you like, but something around 400 words maximum is probably a good rule of thumb.\n\n\n\nPrice\n\nYou can make your product free or paid. For paid products, set price by minute, hour, day or week intervals. You can switch between viewing price in Streamr's DATA token or fiat currency for your convenience. You can also choose to fix price in fiat to protect against sudden shifts in the DATA price.\n\n\n\nDetails and Terms\n\nHere you can add contact details, choose a category, add your website for more information, as well as add some social media links. Social media is optional, but can help buyers feel more confident in buying from you as they can check your reputation online more easily. Terms allows you to state the terms you are offering your data on. You can choose from some multiple choice options, in addition to giving a link to a PDF or website which contains full terms of use..\n\nPublishing\n\nFor a paid product, you'll need a Web3 wallet, and a small amount of ethereum for gas fees, required to publish the product to the Marketplace smart contract. The Publish button will be enabled once required sections are filled, so click that, unlock your wallet and confirm the transaction. Your product will be published on the Marketplace once the ethereum blockchain has confirmed your transaction.\n\n","section":"Marketplace","title":"Creating data products"},"/docs/data-unions/intro-to-data-unions":{"id":"/docs/data-unions/intro-to-data-unions","content":"\n\nIntroduction to Data Unions\n\nThe Data Union framework is a data crowdsourcing and crowdselling solution. Working in tandem with the Streamr Network and Ethereum, the framework powers applications that enable people to earn by sharing valuable data.\n\nData Unions contain a collection of real-time data streams. A Data Union is listed on the Streamr Marketplace as a type of data product for sale. When a buyer subscribes to the product, the DATA revenue is automatically distributed among all of the data producers. The product can be bridged or exported to other data marketplaces at any time, usually as static files. \n\nData Unions may differ from each other based on their membership model, use cases, revenue structure or governance, but they also share some common components: a group of members contributing their data, an entity providing the application layer to manage the data and a discovery mechanism, or marketplace for the data.\n\nThe most valuable Data Unions will incentivize collection of datasets that may be otherwise difficult to source. Some examples include real-time health data, web user data, pollution monitoring, smart city data and more. Swash is the world's first Data Union - a browser extension that monetizes your browsing data. Streamr supports new Data Unions through the Data Fund.\n\nSmart Contracts\n\nData Unions are fully on-chain, currently on xDai, with a conduit to the Ethereum mainnet. Data Unions are typically deployed via the Core app and subsequently published on the Marketplace. They can run on any Ethereum-compatible sidechain for scalability and affordable cost of operation. The first supported sidechain is xDai, and other options may be added in the future.\n\nThere are numerous benefits of having Data Unions fully on-chain. First of all, the security of the system becomes as strong as the security of the underlying blockchain itself. Secondly, Data Union members and builders get to benefit from composability, network effects, and services available on the same blockchain, particularly DeFi platforms.\n\nThe underlying smart contracts are all open source. A more technical explanation of the framework can be found on the Data Unions GitHub repository.\n\n\n\nWhat you’ll need\n\nCreating a Data Union requires an Ethereum address to create, manage and receive revenue from the underlying smart contract. It also requires some sort of host application that enables your users to join and provide real-time data. For example, this can be a browser extension, a mobile app, or a publishing script on a hardware device.\n\nOnce the product has been published, you can view revenue and community metrics, as well as manage members via the Core app. Revenue from the marketplace subscriptions will be paid out to members in DATA tokens once they have begun accumulating in the Data Union smart contract.\n\nPre-flight Checklist\n\n\n\nLogin to Streamr with your Ethereum account\n\nHave an ETH balance at that address to deploy and publish the product\n\nCreated a name, description and cover image for the Marketplace listing\n\nHave an app with a community of users who will provide real-time data\n\n\n\nGeneral Flow\n\nUse the Core app to create a draft Data Union, and deploy the Data Union smart contract\n\nIntegrate the Data Unions Framework into your your app using the Streamr client\n\nAllow users to join the Data Union. You must have a minimum of  to publish, but the larger the number of members, the more valuable your product is likely to be\n\nPublish the Data Union to the Marketplace\n\nManage users and view revenue via the Core app\n\nAutomatically generated API documentation is also available here. These docs are generated from the repository TypeScript source code.\n","section":"Data Unions","title":"Intro to Data Unions"},"/docs/data-unions/creating-a-data-union":{"id":"/docs/data-unions/creating-a-data-union","content":"\n\nCreating a Data Union\n\nTo create a Data Union in Core, go to Core > Products, click Create and choose Data Union as the product type. Other than the sections below, the process is similar to creating a Data Product.\n\n\n\nDeploying a Data Union\n\nCreating a Data Union starts with deploying the Data Union smart contract. A Data Union is identified by the address of its smart contract. While the deployment transaction is an Ethereum mainnet transaction, the Data Union smart contract is deployed to the sidechain - currently xDai. The sidechain address is deterministic and can be found by reading the mainnet contract on Etherscan. Currently the Core UI shows the mainnet address, in the future it will show both the mainnet and sidechain addresses.\n\nThe account that deploys the contract is also the owner of that contract. Once all the required fields have been filled and the draft Data Union is ready to be deployed, click Continue to deploy the Data Union. The deploy dialogue will walk you through the deploy process.\n\nFor the mainnet contract deployment transaction, you'll need a Web3 wallet and a small amount of Ethereum for gas fees. The amount required is approximately 178k gas, not to be confused with gas price in Gwei which fluctuates based on network usage. The Data Union deployment might take a moment to register once the transaction has been mined. The progress indicator will show an estimate of the remaining time. You can either close the dialog and move on or wait for the process to complete after which you will be automatically redirected.\n\n\n\nMember authentication via shared secrets\n\nShared secrets allow new members to join the Data Union without explicit approval from the Data Union Admin, in order to streamline the on-ramp process. Users may still join the Data Union without a secret but they will have to be manually accepted by the Admin. Shared secret generation becomes available in the Data Union editor once you have deployed your Data Union.\n\nPublishing to the Marketplace\n\nA minimum of Continue from the action bar. Your Data Union will be published on the Marketplace once the Ethereum blockchain has confirmed your transaction.\n\nManaging the Data Union\n\nData Unions are listed along with Data Products in Core > Products. Data Unions are marked by a Data Union badge and a Members badge showing the current amount of approved members. Click the tile menu to access the Data Union stats and manage members.\n\nThe Stats view provides an overview of the Data Union as well as it's members and subscribers over time. The Members view allows you to manage manual member join requests (requests that did not contain a shared secret).\n\n\n\nAdmin fee\n\nAdmins are responsible for maintaining the Data Unions, including ensuring good data quality and removing members that are not contributing data as expected. They are incentivized by receiving an admin fee, a percentage of incoming revenue. Members agree to it by joining the Data Union.\n\nCreating a Data Union programmatically\n\nA Data Union is typically created in the Core app. It can also be achieved programmatically, via a client library. Deploying a Data Union requires gas.\n\nTo get a DataUnion instance, call streamr.getDataUnion(dataUnionAddress).\n\n\n\nTo deploy a new DataUnion, call deployDataUnion()\n\n\n\nA Data Union is identified by the address of its smart contract on the Ethereum Mainnet. After the smart contract has been created, the Admin may choose to create an shared secret:\n\n\n\nThe name parameter is simply an identifier for the secret. If it is not provided, a randomly generated one will be used. Note that the request must be authenticated using the Ethereum address of the Admin of the Data Union, as described in Data Unions Auth & Identity.\n\nThe shared secret allows new members to join the Data Union without explicit approval from the Data Union Admin, to streamline the member joining process.\n\nAfter the Data Union is deployed, it can be published on the Marketplace.\n\nObserving Data Unions\n\nThe Admin should make requests through the Streamr client. For example,\n\n\n\nThe returned stats object would look something like:\n\n\n\nOther relevant query functions:\n\n\n\nThe Streamr Core app also provides monitoring functions for Admins, showing subscriber numbers, total revenue, join requests and more.\n\nAutomatically generated API documentation is also available here. These docs are generated from the repository TypeScript source code.\n","section":"Data Unions","title":"Creating a Data Union"},"/docs/data-unions/roles-and-responsibilities":{"id":"/docs/data-unions/roles-and-responsibilities","content":"\n\nRoles and responsibilities\n\nEach Data Union has one Admin (owner), and potentially thousands or even millions of data producing members.\n\nAdmin\n\nAdmins have the power to add and remove members. They are responsible for maintaining their Data Unions, including ensuring good data quality and removing members that are not contributing data as they're expected to.\n\nAdmins are incentivized to perform this work by the Admin fee parameter, a fraction of the incoming Data Union revenue. Admins have control over this fee parameter, and members agree to it by joining the Data Union. Previous earnings are not affected by changes in the Admin fee.\n\nTypically, Admins are initially the creators of both the user application and the Data Union, though this role can be assigned to someone else or even performed by the members themselves via a DAO.\n\nMembers\n\nMembers are the people and/or devices that produce data into the data streams contained inside the Data Union. After joining, they start receiving a share of the revenue that accumulates in the Data Union contract. The main source of this revenue is likely to come from Marketplace subscriptions.\n\nMembers are identified by an Ethereum address, and they join the Data Union using the Streamr client.\n","section":"Data Unions","title":"Roles & responsibilities"},"/docs/data-unions/wallet-management":{"id":"/docs/data-unions/wallet-management","content":"\n\nWallet management\n\nMembers are identified by an Ethereum address, which is also their identity in the Streamr ecosystem, as Ethereum keys are used to authenticate to Streamr as well for signing datapoints.\n\nEthereum key generation & management\n\nEthereum addresses have an associated private key, which must be kept safe, as it grants access to earned funds. Similarly, losing it means losing funds.\n\nEthereum private keys are just randomly generated 256 bits (32 bytes). They are usually displayed in form of 64 hexadecimal characters. You can use any securely random method of generating those keys, but here’s how to do it using the Streamr client for JavaScript and easily get the associated address too:\n\n\n\nwhich returns an object of this form:\n\n\n\nThe data-producing application can generate the keys when it is launched for the first time, and store the information locally or the user may connect their existing wallet. The private key should always stay on the device and it should never be sent over the internet.\n\nStoring the private key in encrypted form is recommended. One way to approach this is to encrypt it using a user-defined password. If the key is stored encrypted, the key needs to be decrypted when the application starts. The decrypted version should be kept in memory, as it is continuously needed for signing data.\n","section":"Data Unions","title":"Wallet management"},"/docs/data-unions/join-and-parting-members":{"id":"/docs/data-unions/join-and-parting-members","content":"\n\nJoining and parting members\n\nMember joins\n\nA member can join a Data Union by calling join using the Streamr Client library. This call is answered by a centralized gatekeeping service, currently run by Streamr, but can be replaced by your own gatekeeping service. Joining does not incur a gas fee if the default client settings are used. \n\nThe typical way for a device or member to join the Data Union is via shared secrets. See Creating a Data Union for details on creating a shared secret. Calling join with a valid secret will allow the member to join immediately:\n\n\n\nRemoving a member\n\nTo remove (part) members, please refer to the Data Union Admin API documentation.\n","section":"Data Unions","title":"Joining and parting members"},"/docs/data-unions/withdrawing-earnings":{"id":"/docs/data-unions/withdrawing-earnings","content":"\n\nWithdrawing earnings\n\nMembership inside a Data Union offers a revenue share of funds that accumulate in the Data Union contract as well as data publishing rights to the collection of streams inside the Data Union.\n\nThe correct secret allows the member to join without manual approval from the Data Union Admin. If the secret is omitted, the Admin must login, find pending join requests in the Data Union Admin view of the product, and approve the requests manually.\n\nSimilar to deployDataunion, you should wait until the member has joined before querying the member’s stats. The Data Union member can check their earnings (minus earlier withdrawals) in every Data Union:\n\n\n\nAlso other interesting stats are available from the server:\n\n\n\nThe response would be something like:\n\n\n\nEarnings in DATA token accumulate on the Data Union smart contract. Every active member has a claim to a fraction of these funds, as determined by their join date and the parameters of the Data Union smart contract. That claim is asserted when they make a withdrawal transaction.\n\n\n\nCheckout the JS client docs for further details on the withdrawal options.\n\nDATA tokens can be withdrawn to the mainnet or sidechain, (currently xDai). Withdrawing to the sidechain is recommended and from here the tokens can be swapped to some other tokens using a DEX (decentralized token exchange) present on that sidechain. The transaction fees on sidechains are orders of magnitude cheaper than on Ethereum mainnet, making it much more feasible to move around even small amounts of value. On xDai, transactions currently cost only fractions of a cent, compared to transactions costing tens or even hundreds of dollars on mainnet. \n\nWithout support from the Data Union Admin, the member will require a (very) small amount of xDai token (the native token of the xDai chain) to withdraw their funds from the Data Union to an address on the sidechain.\n\nThe Data Unions framework also support gasless withdrawals via metatransactions. This means that Data Union Admins can optionally pay the transaction fees on behalf of members, potentially enabling a better user experience. DATA tokens can also to be directly deposited to a particular member’s balance in the Data Union, allowing Data Union Admins to run referral campaigns that pay out personalised rewards (as opposed to the equal revenue sharing among members, the core feature of Data Unions).\n\nMembers of Data Unions that require support with withdrawing should reach out to the Data Union Admin and not Streamr as the Admin is best positioned to assist in all matters of the Data Union. Data Union Admins are encouraged to reach out for support from Streamr. Currently, the best way is on the Dev channel, inside our Discord.\n","section":"Data Unions","title":"Withdrawing earnings"},"/docs/data-unions/ux-best-practices":{"id":"/docs/data-unions/ux-best-practices","content":"\n\nData Unions UX best practices\n\nIf you build a Data Union app or integrate Data Unions into an existing app, it needs to incorporate a simple crypto wallet because your users will receive revenue in DATA token. Below are a collection of features, suggestions and good usability practices you may want to include in your app.\n\nBalance, available balance and cumulative earnings\n\nBecause users can withdraw tokens from their primary Ethereum address to another wallet, showing both current total and cumulative earnings is a good idea, so users can know their historical earnings as well as the current balance.\n\n\n\nPrivate key handling\n\nBecause users may want to use another wallet for managing their funds, we strongly recommend offering private key access to all your users. Without this, they do not really have control of their own funds. When handling private keys, you need to allow users to access the private keys, but you should generally avoid displaying them on screen and keep them hidden from view.\n\nYou also need to inform your users about their responsibility for security, because it is entirely up to them. When onboarding, a good practice is to break the users flow of just blindly clicking onwards through key information. Using disabled, conditional buttons that require explicit agreement from the user will not solve all your problems, but might help to prevent some users from ignoring important warnings.\n\n\n\nWallet addresses\n\nProviding clear access and copy functionality to the user's wallet address is always good practice, so they can watch it via other applications, and check it with external services. When pasting addresses into wallet address fields, informing the user that the contents of the field match the clipboard, and also show the ETH & ERC-20 tokens held by that address helps to reduce user stress and avoids the common practice of double-checking addresses by copy-pasting them as text.\n\n\n\nFiat currency display\n\nAllowing your users to switch currency views between the DATA token and a standard fiat currency like USD is a good idea. If they use your app over a long time they might get accustomed to thinking in DATA, but don’t assume they will.\n\n","section":"Data Unions","title":"UX best practices"}}