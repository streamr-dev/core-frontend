{"/docs/module-reference/boolean#and":{"id":"/docs/module-reference/boolean#and","content":"And (Boolean). Implements the boolean AND operation: outputs 1 if both inputs equal 1, otherwise outputs 0.","section":"Boolean","title":"Canvas Module: And"},"/docs/module-reference/boolean#booleanconstant":{"id":"/docs/module-reference/boolean#booleanconstant","content":"Booleanconstant (Boolean). This module represents a constant boolean value i.e. true|false, that can be connected to any boolean input. The input will have that value during the whole execution.","section":"Boolean","title":"Canvas Module: Booleanconstant"},"/docs/module-reference/boolean#booleantonumber":{"id":"/docs/module-reference/boolean#booleantonumber","content":"Booleantonumber (Boolean). Converts `false` to `0` and `true` to `1`.","section":"Boolean","title":"Canvas Module: Booleantonumber"},"/docs/module-reference/boolean#equals":{"id":"/docs/module-reference/boolean#equals","content":"Equals (Boolean). Outputs 1 if the inputs are equal within the specified tolerance, that is, if abs(A-B) ≤ tolerance. Otherwise outputs 0.","section":"Boolean","title":"Canvas Module: Equals"},"/docs/module-reference/boolean#greaterthan":{"id":"/docs/module-reference/boolean#greaterthan","content":"Greaterthan (Boolean). Outputs 1 if A is greater than B (A>B). If equality is set to true, outputs 1 if A≥B. Otherwise outputs 0.","section":"Boolean","title":"Canvas Module: Greaterthan"},"/docs/module-reference/boolean#ifthenelse":{"id":"/docs/module-reference/boolean#ifthenelse","content":"Ifthenelse (Boolean). If the value at the if input is 1, then outputs the value present at the then input. Otherwise outputs the value at else input.","section":"Boolean","title":"Canvas Module: Ifthenelse"},"/docs/module-reference/boolean#lessthan":{"id":"/docs/module-reference/boolean#lessthan","content":"Lessthan (Boolean). Outputs 1 if A is less than B (A<B). If equality is set to true, outputs 1 if A≤B. Otherwise outputs 0.","section":"Boolean","title":"Canvas Module: Lessthan"},"/docs/module-reference/boolean#not":{"id":"/docs/module-reference/boolean#not","content":"Not (Boolean). Implements the boolean NOT operation: outputs 0 if the input equals 1, otherwise outputs 1.","section":"Boolean","title":"Canvas Module: Not"},"/docs/module-reference/boolean#or":{"id":"/docs/module-reference/boolean#or","content":"Or (Boolean). Implements the boolean OR operation: outputs 1 if at least one of the inputs equal 1, otherwise outputs 0.","section":"Boolean","title":"Canvas Module: Or"},"/docs/module-reference/boolean#samesign":{"id":"/docs/module-reference/boolean#samesign","content":"Samesign (Boolean). Outputs 0 unless both inputs have the same sign. If both inputs are positive, the output is 1. If both are negative, the output is -1.","section":"Boolean","title":"Canvas Module: Samesign"},"/docs/module-reference/boolean#xor":{"id":"/docs/module-reference/boolean#xor","content":"Xor (Boolean). Implements the boolean XOR operation: outputs true if one of the inputs equal true, otherwise outputs false.","section":"Boolean","title":"Canvas Module: Xor"},"/docs/module-reference/custom-modules#javamodule":{"id":"/docs/module-reference/custom-modules#javamodule","content":"Javamodule (Custom-modules). This module allows you to implement custom functionality by writing code in the Java programming language directly in your browser.  Click the Edit code button to open the code editor. The code you write will be dynamically compiled and executed.  See the User Guide for more information on programmable modules.","section":"Custom-modules","title":"Canvas Module: Javamodule"},"/docs/module-reference/input#button":{"id":"/docs/module-reference/input#button","content":"Button (Input). The button module outputs the given value everytime the button is pressed. Module can be used any time, even during a run.","section":"Input","title":"Canvas Module: Button"},"/docs/module-reference/input#switcher":{"id":"/docs/module-reference/input#switcher","content":"Switcher (Input). The module ouputs even 1 or 0 depending of the value of the switcher. The value can be changed during a run.","section":"Input","title":"Canvas Module: Switcher"},"/docs/module-reference/input#textfield":{"id":"/docs/module-reference/input#textfield","content":"Textfield (Input). The module outputs the value of the text field every time 'send' is pressed.","section":"Input","title":"Canvas Module: Textfield"},"/docs/module-reference/integrations#http-request":{"id":"/docs/module-reference/integrations#http-request","content":"Http-request (Integrations). This module sends inputs as HTTP request to given URL, and returns server response. Headers, query params and body should be Maps. Body can also be List or String. Request body format can be changed in Options. Default is JSON. Server is expected to return JSON formatted documents. HTTP Request is asynchronous by default. Synchronized requests block the execution of the whole canvas until they receive the server response, but otherwise they work just like any other module; asynchronous requests on the other hand work like streams in that they activate modules they're connected to only when they receive data from the server. If a data path branches, and one branch passes through the HTTP Request module and another around it, if they also converge in a module, that latter module may experience multiple activations due to asynchronicity. This also means that server responses may arrive in different order than they were sent. If this kind of behaviour causes problems, you can try to fix it by changing sync mode to synchronized in Options. However, data throughput WILL be lower, and external servers may freeze your canvas simply by responding very slowly or not at all. For simple data paths and somewhat stable response times, the two sync modes will yield precisely the same results.","section":"Integrations","title":"Canvas Module: Http-request"},"/docs/module-reference/integrations#mqtt":{"id":"/docs/module-reference/integrations#mqtt","content":"Mqtt (Integrations). Listen to MQTT messages, output them as strings. If message is JSON, a JsonParser module can be used to transform the string into a map, and GetMultiFromMap module to extract values from the map.Examples:Connecting to MQTT service without certificateGive URL address asmqtt://service.comortcp://service.comAdd topic and username and password if needed.Connecting to MQTT with certificateGive URL address asssl://service.comAdd topic and username and password if needed.Select certificate type to be .crt and paste your certificate to text area.","section":"Integrations","title":"Canvas Module: Mqtt"},"/docs/module-reference/integrations#simple-http":{"id":"/docs/module-reference/integrations#simple-http","content":"Simple-http (Integrations). There is no documentation for this module at this time.","section":"Integrations","title":"Canvas Module: Simple-http"},"/docs/module-reference/integrations#sql":{"id":"/docs/module-reference/integrations#sql","content":"Sql (Integrations). The result is a list of map objects, e.g. [{\"id\":0, \"name\":\"Me\"}, {\"id\":1, \"name\":\"You\"}]","section":"Integrations","title":"Canvas Module: Sql"},"/docs/module-reference/integrations#binarybetting":{"id":"/docs/module-reference/integrations#binarybetting","content":"Binarybetting (Integrations). BinaryBetting Ethereum contract","section":"Integrations","title":"Canvas Module: Binarybetting"},"/docs/module-reference/integrations#ethereumcall":{"id":"/docs/module-reference/integrations#ethereumcall","content":"Ethereumcall (Integrations). Call Ethereum smart contract.First, connect Ethereum contract into contract input. You can write your own using SolidityModule, or pick a template such as PayByUse.Second, choose the function you want to call from the dropdown. There are two kinds of functions calls:- constant function calls that return results directly, and- transactions that return values through events that the function call invokes.The contract must be deployed before this module can activate.","section":"Integrations","title":"Canvas Module: Ethereumcall"},"/docs/module-reference/integrations#getcontractat":{"id":"/docs/module-reference/integrations#getcontractat","content":"Getcontractat (Integrations). Ethereum contract that has been deployed in the blockchain","section":"Integrations","title":"Canvas Module: Getcontractat"},"/docs/module-reference/integrations#getevents":{"id":"/docs/module-reference/integrations#getevents","content":"Getevents (Integrations). Get events sent out by given contract in the given transaction","section":"Integrations","title":"Canvas Module: Getevents"},"/docs/module-reference/integrations#paybyuse":{"id":"/docs/module-reference/integrations#paybyuse","content":"Paybyuse (Integrations). PayByUse Ethereum contract","section":"Integrations","title":"Canvas Module: Paybyuse"},"/docs/module-reference/integrations#soliditycompiledeploy":{"id":"/docs/module-reference/integrations#soliditycompiledeploy","content":"Soliditycompiledeploy (Integrations). Compile and deploy Ethereum smart contract. Edit the code in text window, close window and then contract will be compiled. Enter constructor args and initial ETH (if applicable) and press deploy. Deployed address will be displayed in bottom text field. You can connect the contract output to SendEthereumTransaction module.","section":"Integrations","title":"Canvas Module: Soliditycompiledeploy"},"/docs/module-reference/integrations#verifysignature":{"id":"/docs/module-reference/integrations#verifysignature","content":"Verifysignature (Integrations). Given message and signature get Ethereum address of signee.","section":"Integrations","title":"Canvas Module: Verifysignature"},"/docs/module-reference/list#addtolist":{"id":"/docs/module-reference/list#addtolist","content":"Addtolist (List). Insert an item into an arbitrary position of a List. Unless adding to the very end of a list, items starting from index are all shifted to the right to allow insertion of new item.","section":"List","title":"Canvas Module: Addtolist"},"/docs/module-reference/list#appendtolist":{"id":"/docs/module-reference/list#appendtolist","content":"Appendtolist (List). Append an item to the end of a List.","section":"List","title":"Canvas Module: Appendtolist"},"/docs/module-reference/list#buildlist":{"id":"/docs/module-reference/list#buildlist","content":"Buildlist (List). Build a fixed-sized list from values at inputs.","section":"List","title":"Canvas Module: Buildlist"},"/docs/module-reference/list#constantlist":{"id":"/docs/module-reference/list#constantlist","content":"Constantlist (List). This module allows you to manually enter a constant List object.","section":"List","title":"Canvas Module: Constantlist"},"/docs/module-reference/list#containsitem":{"id":"/docs/module-reference/list#containsitem","content":"Containsitem (List). Checks whether a list contains an item.","section":"List","title":"Canvas Module: Containsitem"},"/docs/module-reference/list#flattenlist":{"id":"/docs/module-reference/list#flattenlist","content":"Flattenlist (List). Flattens lists inside a list, e.g. [1, [2,3], [4, 5], 6, [7, 8], 9] -> [1, 2, 3, 4, 5, 6, 7, 8, 9]. If deep = true, flattening will be done recursively. E.g. [1, [2, [3, [4, 5, [6]]], 7], 8, 9] -> [1, 2, 3, 4, 5, 6, 7, 8, 9]. Otherwise only one level of flattening will be perfomed.","section":"List","title":"Canvas Module: Flattenlist"},"/docs/module-reference/list#foreachitem":{"id":"/docs/module-reference/list#foreachitem","content":"Foreachitem (List). Execute a sub-canvas for each item of input lists. The exported inputs and outputs of sub-canvas canvas appear as list inputs and list outputs. The input lists are iterated element-wise, and the sub-canvas is executed every time a value is available for each input list. If input list sizes vary, the sub-canvas is executed as many times as the smallest list is of size. After the input lists have been iterated through, and the sub-canvas activated accordingly, lists of produced values are sent to output lists. The output numOfItems indicates how many times the sub-canvas was executed, i.e., the size of the smallest input list. You may want to look into the module RepeatItem when using this module to repeat parameter values etc.","section":"List","title":"Canvas Module: Foreachitem"},"/docs/module-reference/list#getfromlist":{"id":"/docs/module-reference/list#getfromlist","content":"Getfromlist (List). Fetch item from a list by index.Indexing starts from zero, so the first item has index 0, second has index 1 etc.Negative index counts from end of list, so that last item in the list has index -1, second-to-last has index -2 etc.","section":"List","title":"Canvas Module: Getfromlist"},"/docs/module-reference/list#headlist":{"id":"/docs/module-reference/list#headlist","content":"Headlist (List). Retrieves the first (a maximum of limit) items of a list.","section":"List","title":"Canvas Module: Headlist"},"/docs/module-reference/list#indexesofitem":{"id":"/docs/module-reference/list#indexesofitem","content":"Indexesofitem (List). Finds indexes of all occurrences of an item in a list.","section":"List","title":"Canvas Module: Indexesofitem"},"/docs/module-reference/list#indexofitem":{"id":"/docs/module-reference/list#indexofitem","content":"Indexofitem (List). Finds the index of the first occurrence of an item in a list.","section":"List","title":"Canvas Module: Indexofitem"},"/docs/module-reference/list#indices":{"id":"/docs/module-reference/list#indices","content":"Indices (List). Generates a list from [0,n-1] according to the size n of the given input list.","section":"List","title":"Canvas Module: Indices"},"/docs/module-reference/list#listsize":{"id":"/docs/module-reference/list#listsize","content":"Listsize (List). Determine size of list.","section":"List","title":"Canvas Module: Listsize"},"/docs/module-reference/list#listtoevents":{"id":"/docs/module-reference/list#listtoevents","content":"Listtoevents (List). Split input list into separate events. They will be sent out as separate events, one item at a time.Each event causes activation of all modules where the output item is sent to.","section":"List","title":"Canvas Module: Listtoevents"},"/docs/module-reference/list#mergelist":{"id":"/docs/module-reference/list#mergelist","content":"Mergelist (List). Merge two lists (head + tail) together to form a singe list. Merging is simply done by adding items of tail to the end of head to form a single list.","section":"List","title":"Canvas Module: Mergelist"},"/docs/module-reference/list#range":{"id":"/docs/module-reference/list#range","content":"Range (List). Generates a sequence of numbers increasing/decreasing according to a specified step. When from < to a growing sequence is produced. Otherwise (from > to) a decreasing sequence is produced. The sign of parameter step is ignored, and is automatically determined by the inequality relation between from and to. Parameter to acts as an upper bound which means that if sequence generation goes over to, the exceeding values are not included in the sequence. E.g., from=1, to=2, seq=0.3 results in [1, 1.3, 1.6, 1.9], with 2.1 notably not included.","section":"List","title":"Canvas Module: Range"},"/docs/module-reference/list#removefromlist":{"id":"/docs/module-reference/list#removefromlist","content":"Removefromlist (List). Remove an item from a list by index. Given an invalid index, this module simply outputs the original input list.","section":"List","title":"Canvas Module: Removefromlist"},"/docs/module-reference/list#repeatitem":{"id":"/docs/module-reference/list#repeatitem","content":"Repeatitem (List). Make a list out of an item by repeating it times times.","section":"List","title":"Canvas Module: Repeatitem"},"/docs/module-reference/list#reverselist":{"id":"/docs/module-reference/list#reverselist","content":"Reverselist (List). Reverses a list.","section":"List","title":"Canvas Module: Reverselist"},"/docs/module-reference/list#shufflelist":{"id":"/docs/module-reference/list#shufflelist","content":"Shufflelist (List). Shuffle the items of a list.","section":"List","title":"Canvas Module: Shufflelist"},"/docs/module-reference/list#sortlist":{"id":"/docs/module-reference/list#sortlist","content":"Sortlist (List). Sort a list.","section":"List","title":"Canvas Module: Sortlist"},"/docs/module-reference/list#sublist":{"id":"/docs/module-reference/list#sublist","content":"Sublist (List). Extract a sub list from a list. This module is strict about correct indexing. If given incorrect indices, instead of a sub list being produced, an error will be produced in output error.","section":"List","title":"Canvas Module: Sublist"},"/docs/module-reference/list#taillist":{"id":"/docs/module-reference/list#taillist","content":"Taillist (List). Retrieves the last (a maximum of limit) items of a list.","section":"List","title":"Canvas Module: Taillist"},"/docs/module-reference/list#unique":{"id":"/docs/module-reference/list#unique","content":"Unique (List). Removes duplicate items from a list resulting in a list of unique items. The first occurrence of an item is kept and subsequent occurrences removed.","section":"List","title":"Canvas Module: Unique"},"/docs/module-reference/map#buildmap":{"id":"/docs/module-reference/map#buildmap","content":"Buildmap (Map). Build a new Map from given inputs. Number of inputs is specified via module options (wrench icon). The names of input are used as map keys so make sure to change them!","section":"Map","title":"Canvas Module: Buildmap"},"/docs/module-reference/map#collectfrommaps":{"id":"/docs/module-reference/map#collectfrommaps","content":"Collectfrommaps (Map). Given a list/map of maps, selects from each an entry according to parameter selector, and then returns a list/map of the collected entry values. In case a map does not have an entry for selector, or the value is null, that entry will be simply skipped in the resulting output. Map entry selector supports dot and array notation for selecting from nested maps and lists, e.g. \"parents[1].name\" would return [\"Homer\", \"Fred\"] for input [{name: \"Bart\", parents: [{name: \"Marge\"}, {name: \"Homer\"}]}, {name: \"Pebbles\", parents: [{name: \"Wilma}, {name: \"Fred\"}]}]","section":"Map","title":"Canvas Module: Collectfrommaps"},"/docs/module-reference/map#constantmap":{"id":"/docs/module-reference/map#constantmap","content":"Constantmap (Map). This module allows you to enter a constant Map object, which is a set of key-value pairs. It can be connected to any Map input in Streamr - for example, to set headers on the HTTP module.","section":"Map","title":"Canvas Module: Constantmap"},"/docs/module-reference/map#containsvalue":{"id":"/docs/module-reference/map#containsvalue","content":"Containsvalue (Map). Determine whether a map contains a value.","section":"Map","title":"Canvas Module: Containsvalue"},"/docs/module-reference/map#countbykey":{"id":"/docs/module-reference/map#countbykey","content":"Countbykey (Map). Keeps count of the occurrences of keys.","section":"Map","title":"Canvas Module: Countbykey"},"/docs/module-reference/map#filtermap":{"id":"/docs/module-reference/map#filtermap","content":"Filtermap (Map). Filter incoming maps by retaining entries with specified keys.","section":"Map","title":"Canvas Module: Filtermap"},"/docs/module-reference/map#foreach":{"id":"/docs/module-reference/map#foreach","content":"Foreach (Map). This module allows you to reuse a Canvas saved into the Archive as a module in your current Canvas.A separate Canvas instance will be created for each distinct key, which enables ForEach-like behavior to be implemented. The canvas instances will also retain state as expected.Any parameters, inputs or outputs you export will be visible on the module. You can export endpoints by right-clicking on them and selecting \"Toggle export\".","section":"Map","title":"Canvas Module: Foreach"},"/docs/module-reference/map#getfrommap":{"id":"/docs/module-reference/map#getfrommap","content":"Getfrommap (Map). Retrieve a value from a map by key.","section":"Map","title":"Canvas Module: Getfrommap"},"/docs/module-reference/map#getmultifrommap":{"id":"/docs/module-reference/map#getmultifrommap","content":"Getmultifrommap (Map). Get multiple values from a Map.  The names of outputs are used as map keys so make sure to change them!","section":"Map","title":"Canvas Module: Getmultifrommap"},"/docs/module-reference/map#headmap":{"id":"/docs/module-reference/map#headmap","content":"Headmap (Map). Retrieve first (n=limit) entries of a map.","section":"Map","title":"Canvas Module: Headmap"},"/docs/module-reference/map#keystolist":{"id":"/docs/module-reference/map#keystolist","content":"Keystolist (Map). Retrieve first (n=limit) entries of a map.","section":"Map","title":"Canvas Module: Keystolist"},"/docs/module-reference/map#mapsize":{"id":"/docs/module-reference/map#mapsize","content":"Mapsize (Map). Determine the number of entries in a map.","section":"Map","title":"Canvas Module: Mapsize"},"/docs/module-reference/map#mergemap":{"id":"/docs/module-reference/map#mergemap","content":"Mergemap (Map). Merge rightMap onto leftMap resulting in a single map. In case of conflicting keys, entries of rightMap will replace those of leftMap.","section":"Map","title":"Canvas Module: Mergemap"},"/docs/module-reference/map#newmap":{"id":"/docs/module-reference/map#newmap","content":"Newmap (Map). Emit a map everytime trigger receives a value.","section":"Map","title":"Canvas Module: Newmap"},"/docs/module-reference/map#puttomap":{"id":"/docs/module-reference/map#puttomap","content":"Puttomap (Map). Put a key-value-entry into a map.","section":"Map","title":"Canvas Module: Puttomap"},"/docs/module-reference/map#removefrommap":{"id":"/docs/module-reference/map#removefrommap","content":"Removefrommap (Map). Remove an entry for a map by key.","section":"Map","title":"Canvas Module: Removefrommap"},"/docs/module-reference/map#sortmap":{"id":"/docs/module-reference/map#sortmap","content":"Sortmap (Map). Sorts a map.","section":"Map","title":"Canvas Module: Sortmap"},"/docs/module-reference/map#sumbykey":{"id":"/docs/module-reference/map#sumbykey","content":"Sumbykey (Map). Keeps aggregated sums of received key-value-pairs by key.","section":"Map","title":"Canvas Module: Sumbykey"},"/docs/module-reference/map#tailmap":{"id":"/docs/module-reference/map#tailmap","content":"Tailmap (Map). Retrieve last (n=limit) entries of a map.","section":"Map","title":"Canvas Module: Tailmap"},"/docs/module-reference/map#valuestolist":{"id":"/docs/module-reference/map#valuestolist","content":"Valuestolist (Map). Retrieves the values of a map.","section":"Map","title":"Canvas Module: Valuestolist"},"/docs/module-reference/streams#createstream":{"id":"/docs/module-reference/streams#createstream","content":"Createstream (Streams). Create a new stream.","section":"Streams","title":"Canvas Module: Createstream"},"/docs/module-reference/streams#getorcreatestream":{"id":"/docs/module-reference/streams#getorcreatestream","content":"Getorcreatestream (Streams). Find existing stream by name, or create a new stream if a stream by that name doesn't exist yet. If a stream is found, fields and description inputs are ignored.","section":"Streams","title":"Canvas Module: Getorcreatestream"},"/docs/module-reference/streams#searchstream":{"id":"/docs/module-reference/streams#searchstream","content":"Searchstream (Streams). Search for a stream by name","section":"Streams","title":"Canvas Module: Searchstream"},"/docs/module-reference/text#concatenate":{"id":"/docs/module-reference/text#concatenate","content":"Concatenate (Text). Concatenates (appends) the given strings. For example if input A is \"foo\" and input B is \"bar\", the output is \"foobar\".","section":"Text","title":"Canvas Module: Concatenate"},"/docs/module-reference/text#constanttext":{"id":"/docs/module-reference/text#constanttext","content":"Constanttext (Text). This module represents a constant text value that can be connected to any input that accepts text.","section":"Text","title":"Canvas Module: Constanttext"},"/docs/module-reference/text#contains":{"id":"/docs/module-reference/text#contains","content":"Contains (Text). Tests whether the input string contains the substring given as the search parameter. If it does, 1 is sent out. Otherwise the output is 0.","section":"Text","title":"Canvas Module: Contains"},"/docs/module-reference/text#endswith":{"id":"/docs/module-reference/text#endswith","content":"Endswith (Text). Tests whether the input string ends with the substring given as the search parameter. If it does, 1 is sent out. Otherwise the output is 0.","section":"Text","title":"Canvas Module: Endswith"},"/docs/module-reference/text#formatnumber":{"id":"/docs/module-reference/text#formatnumber","content":"Formatnumber (Text). Format a number into a string with a specified number of decimal places.","section":"Text","title":"Canvas Module: Formatnumber"},"/docs/module-reference/text#jsonparser":{"id":"/docs/module-reference/text#jsonparser","content":"Jsonparser (Text). JSON string should fulfill the JSON specification.","section":"Text","title":"Canvas Module: Jsonparser"},"/docs/module-reference/text#randomstring":{"id":"/docs/module-reference/text#randomstring","content":"Randomstring (Text). Generate fixed-length random strings from an equiprobable symbol pool. Allowed symbols can be configured from module settings.","section":"Text","title":"Canvas Module: Randomstring"},"/docs/module-reference/text#regex":{"id":"/docs/module-reference/text#regex","content":"Regex (Text). Module for analyzing text with a Regular Expression (Regex) pattern. Pattern is given in java format, without the starting and ending slashes.","section":"Text","title":"Canvas Module: Regex"},"/docs/module-reference/text#replace":{"id":"/docs/module-reference/text#replace","content":"Replace (Text). Searches the input text by the search parameter, and if it is found, replaces it with the replaceWith parameter and outputs the result.","section":"Text","title":"Canvas Module: Replace"},"/docs/module-reference/text#split":{"id":"/docs/module-reference/text#split","content":"Split (Text). Splits the text by a given separator and outputs a list with the results Examples: - Separator: \" \"(empty space),Text: \"Two Words\" Output: Two, Words - Output: Two, Words","section":"Text","title":"Canvas Module: Split"},"/docs/module-reference/text#startswith":{"id":"/docs/module-reference/text#startswith","content":"Startswith (Text). Tests whether the input string starts with the substring given as the search parameter. If it does, 1 is sent out. Otherwise the output is 0.","section":"Text","title":"Canvas Module: Startswith"},"/docs/module-reference/text#stringtemplate":{"id":"/docs/module-reference/text#stringtemplate","content":"Stringtemplate (Text). For template syntax, see StringTemplate cheatsheet.Values of the args map are added as substitutions in the template. For example, incoming map {name: \"Bernie\", age: 50} substituted into template \"Hi, <name>!\" would produce string \"Hi, Bernie!\"Nested maps can be accessed with dot notation: {name: \"Bernie\", pet: {species: \"dog\", age: 3}} substituted into \"What a cute <pet.species>!\" would result in \"What a cute dog!\".Lists will be smashed together: {pals: [\"Sam\", \"Herb\", \"Dud\"]} substituted into \"BFF: me, <pals>\" results in \"BFF: me, SamHerbDud\". Separator must be explicitly given: \"BFF: me, <pals; separator=\", \">\" gives \"BFF: me, Sam, Herb, Dud\".Transforming list items can be done with { x | f(x) } syntax, e.g. {pals: [\"Sam\", \"Herb\", \"Dud\"]} substituted into \"<pals: { x | Hey <x>! }> Hey y'all!\" results in \"Hey Sam! Hey Herb! Hey Dud! Hey y'all!\".","section":"Text","title":"Canvas Module: Stringtemplate"},"/docs/module-reference/text#stringtonumber":{"id":"/docs/module-reference/text#stringtonumber","content":"Stringtonumber (Text). Parse a number from the input string.Examples of valid floating-point numbers:- \"1\"- \"3.14159\"- \"-.234e4\" (outputs -2340)- \"+3.e1\" (outputs 30)","section":"Text","title":"Canvas Module: Stringtonumber"},"/docs/module-reference/text#textequals":{"id":"/docs/module-reference/text#textequals","content":"Textequals (Text). Tests whether the input string equals with the string given as the search parameter. If it does, 1 is sent out. Otherwise the output is 0.","section":"Text","title":"Canvas Module: Textequals"},"/docs/module-reference/text#textlength":{"id":"/docs/module-reference/text#textlength","content":"Textlength (Text). Ouputs the length of the input text (all characters including).","section":"Text","title":"Canvas Module: Textlength"},"/docs/module-reference/text#tolowercase":{"id":"/docs/module-reference/text#tolowercase","content":"Tolowercase (Text). Outputs the input text in lower case.","section":"Text","title":"Canvas Module: Tolowercase"},"/docs/module-reference/text#touppercase":{"id":"/docs/module-reference/text#touppercase","content":"Touppercase (Text). Outputs the input text in upper case.","section":"Text","title":"Canvas Module: Touppercase"},"/docs/module-reference/text#trim":{"id":"/docs/module-reference/text#trim","content":"Trim (Text). Removes the whitespace in front of and behind the input text. E.g.  \"         example with a space       \" -> \"example with a space\"","section":"Text","title":"Canvas Module: Trim"},"/docs/module-reference/text#valueastext":{"id":"/docs/module-reference/text#valueastext","content":"Valueastext (Text). Transforms the input value (which can be any value) into text.","section":"Text","title":"Canvas Module: Valueastext"},"/docs/module-reference/time-and-date#clock":{"id":"/docs/module-reference/time-and-date#clock","content":"Clock (Time-and-date). Tells the time and date at fixed time intervals (by default every second). Outputs the time either in string notation of given format or as a timestamp (milliseconds from 1970-01-01 00:00:00.000).The time interval can be chosen with parameter unit and granularly controlled via parameter rate. For example, unit=minute and rate=2 will tell the time every other minute.","section":"Time-and-date","title":"Canvas Module: Clock"},"/docs/module-reference/time-and-date#dateconversion":{"id":"/docs/module-reference/time-and-date#dateconversion","content":"Dateconversion (Time-and-date). Takes a date as an input in either in Date object, timestamp(ms) or in string notation. If the input is in text form, is the given format used. Example: Parameters: - Format <- \"yyyy-MM-dd HH:mm:ss\"- Timezone <- Europe/Helsinki  Inputs: - Date in <- \"2015-07-15 13:06:13\" or 1436954773474 Outputs:  - Date out -> 2015-07-15 13:06:13- ts -> 1436954773474- dayOfWeek -> \"Wed\"- years -> 2015- months -> 7- days -> 15- hours -> 13- minutes -> 6- seconds -> 13- milliseconds -> 0","section":"Time-and-date","title":"Canvas Module: Dateconversion"},"/docs/module-reference/time-and-date#scheduler":{"id":"/docs/module-reference/time-and-date#scheduler","content":"Scheduler (Time-and-date). Outputs a certain value at a certain time. E.g. Every day from 10:00 to 14:00 the module outputs value 1 and otherwise value 0. If more than one rule are active at the same time, the value from the rule with the highest priority (the highest rule in the list) is sent. If no rule is active, the default value will be sent out.","section":"Time-and-date","title":"Canvas Module: Scheduler"},"/docs/module-reference/time-and-date#timebetweenevents":{"id":"/docs/module-reference/time-and-date#timebetweenevents","content":"Timebetweenevents (Time-and-date). Tells the time between two consecutive events in milliseconds.","section":"Time-and-date","title":"Canvas Module: Timebetweenevents"},"/docs/module-reference/time-and-date#timeofday":{"id":"/docs/module-reference/time-and-date#timeofday","content":"Timeofday (Time-and-date). Outputs 1 if the current time of day (in the time zone your user account is set to) is between startTime and endTime (both inclusive). At other times outputs 0.","section":"Time-and-date","title":"Canvas Module: Timeofday"},"/docs/module-reference/time-and-date#timeofevent":{"id":"/docs/module-reference/time-and-date#timeofevent","content":"Timeofevent (Time-and-date). Get timestamp for the event currently being processed. Similar to Clock, but instead of generating events, this module is triggered manually through input trigger.","section":"Time-and-date","title":"Canvas Module: Timeofevent"},"/docs/module-reference/time-series#modwt":{"id":"/docs/module-reference/time-series#modwt","content":"Modwt (Time-series). This module implements a realtime maximal overlap discrete wavelet transform (MODWT). A number of different wavelets are available.  Note that, like all filters, the MODWT introduces increasing amounts of delay with higher levels of smoothing. No additional delay is added to any level - this means that a multi-level decomposition is not aligned at a given time. Reconstructing the original signal would require adding delay to all but the last level.","section":"Time-series","title":"Canvas Module: Modwt"},"/docs/module-reference/time-series#movingaverage":{"id":"/docs/module-reference/time-series#movingaverage","content":"Movingaverage (Time-series). This module calculates the simple moving average (MA, SMA) of values arriving at the input. Each value is assigned equal weight. The moving average is calculated based on a sliding window of adjustable length.","section":"Time-series","title":"Canvas Module: Movingaverage"},"/docs/module-reference/time-series#movingaverageexp":{"id":"/docs/module-reference/time-series#movingaverageexp","content":"Movingaverageexp (Time-series). Smooths the incoming time series by calculating an exponential moving average (EMA) - EMA(t) = a x in(t) + (1-a) x EMA(t-1)- a = \\(2 \\over \\text{length} + 1\\)","section":"Time-series","title":"Canvas Module: Movingaverageexp"},"/docs/module-reference/time-series#arima":{"id":"/docs/module-reference/time-series#arima","content":"Arima (Time-series). Evaluates an ARIMA prediction model with given parameters. Check the module options to set the number of autoregressive and moving average parameters. Model fitting is not (yet) implemented.","section":"Time-series","title":"Canvas Module: Arima"},"/docs/module-reference/time-series#randomnumber":{"id":"/docs/module-reference/time-series#randomnumber","content":"Randomnumber (Time-series). Generate random numbers between [min, max] with uniform probability.","section":"Time-series","title":"Canvas Module: Randomnumber"},"/docs/module-reference/time-series#randomnumbergaussian":{"id":"/docs/module-reference/time-series#randomnumbergaussian","content":"Randomnumbergaussian (Time-series). Generate random numbers from normal (Gaussian) distribution with mean mean and standard deviation sd.","section":"Time-series","title":"Canvas Module: Randomnumbergaussian"},"/docs/module-reference/time-series#abs":{"id":"/docs/module-reference/time-series#abs","content":"Abs (Time-series). Outputs the absolute value (positive value with original sign stripped) of the input.","section":"Time-series","title":"Canvas Module: Abs"},"/docs/module-reference/time-series#add":{"id":"/docs/module-reference/time-series#add","content":"Add (Time-series). Adds together two or more numeric input values.","section":"Time-series","title":"Canvas Module: Add"},"/docs/module-reference/time-series#changeabsolute":{"id":"/docs/module-reference/time-series#changeabsolute","content":"Changeabsolute (Time-series). Outputs the difference between the received value and the previous received value, or in(t) - in(t-1).","section":"Time-series","title":"Canvas Module: Changeabsolute"},"/docs/module-reference/time-series#changelogarithmic":{"id":"/docs/module-reference/time-series#changelogarithmic","content":"Changelogarithmic (Time-series). Outputs the logarithmic difference (log return) between the received value and the previous received value, or log[in(t)] - log[in(t-1)].","section":"Time-series","title":"Canvas Module: Changelogarithmic"},"/docs/module-reference/time-series#changerelative":{"id":"/docs/module-reference/time-series#changerelative","content":"Changerelative (Time-series). Outputs the received value divided by the previous received value, or in(t) / in(t-1). If the previous received value is zero, the result is undefined and no output is produced.","section":"Time-series","title":"Canvas Module: Changerelative"},"/docs/module-reference/time-series#count":{"id":"/docs/module-reference/time-series#count","content":"Count (Time-series). Counts the number of incoming events.","section":"Time-series","title":"Canvas Module: Count"},"/docs/module-reference/time-series#divide":{"id":"/docs/module-reference/time-series#divide","content":"Divide (Time-series). This module calculates the quotient of its two input values. If the input B is zero, the result is not defined and thus no output is produced.","section":"Time-series","title":"Canvas Module: Divide"},"/docs/module-reference/time-series#expression":{"id":"/docs/module-reference/time-series#expression","content":"Expression (Time-series). Evaluate arbitrary mathematical expressions containing operators, variables, and functions. Variables introduced in an expression will automatically appear as inputs. See https://github.com/uklimaschewski/EvalEx#supported-operators for further detail about supported features.","section":"Time-series","title":"Canvas Module: Expression"},"/docs/module-reference/time-series#invert":{"id":"/docs/module-reference/time-series#invert","content":"Invert (Time-series). Outputs the multiplicative inverse (reciprocal) of the input (1/in, in^-1).","section":"Time-series","title":"Canvas Module: Invert"},"/docs/module-reference/time-series#linearmapper":{"id":"/docs/module-reference/time-series#linearmapper","content":"Linearmapper (Time-series). Linearly transforms a range of incoming (x) values to a range of outgoing (y) values. For example, this could be used to transform the input range of -1...1 (xMin...xMax) into an output range of 0...1000 (yMin...yMax).  Incoming values outside the x range will just output the min/max y value.","section":"Time-series","title":"Canvas Module: Linearmapper"},"/docs/module-reference/time-series#lognatural":{"id":"/docs/module-reference/time-series#lognatural","content":"Lognatural (Time-series). Outputs the natural logarithm of the input value.","section":"Time-series","title":"Canvas Module: Lognatural"},"/docs/module-reference/time-series#max":{"id":"/docs/module-reference/time-series#max","content":"Max (Time-series). Outputs the greater one of the two input values. For finding the maximum in a window of values, see the Max (window) module.","section":"Time-series","title":"Canvas Module: Max"},"/docs/module-reference/time-series#min":{"id":"/docs/module-reference/time-series#min","content":"Min (Time-series). Outputs the lesser one of the two input values. For finding the minimum in a window of values, see the Min (window) module.","section":"Time-series","title":"Canvas Module: Min"},"/docs/module-reference/time-series#modulo":{"id":"/docs/module-reference/time-series#modulo","content":"Modulo (Time-series). Calculates the remainder of two values. Outputs ( divisor mod divider). E.g. - 3 mod 2 = 1","section":"Time-series","title":"Canvas Module: Modulo"},"/docs/module-reference/time-series#multiply":{"id":"/docs/module-reference/time-series#multiply","content":"Multiply (Time-series). This module calculates the product of two numeric input values.","section":"Time-series","title":"Canvas Module: Multiply"},"/docs/module-reference/time-series#negate":{"id":"/docs/module-reference/time-series#negate","content":"Negate (Time-series). Outputs the negated input value -1 * in.","section":"Time-series","title":"Canvas Module: Negate"},"/docs/module-reference/time-series#roundtostep":{"id":"/docs/module-reference/time-series#roundtostep","content":"Roundtostep (Time-series). Rounds incoming values to given precision/step. The direction of rounding can be set with the mode parameter.","section":"Time-series","title":"Canvas Module: Roundtostep"},"/docs/module-reference/time-series#sign":{"id":"/docs/module-reference/time-series#sign","content":"Sign (Time-series). Outputs the sign of the input: -1 if the input is negative, 0 if the input is zero, and 1 if the input is positive.","section":"Time-series","title":"Canvas Module: Sign"},"/docs/module-reference/time-series#squareroot":{"id":"/docs/module-reference/time-series#squareroot","content":"Squareroot (Time-series). Calculates the square root of the input.","section":"Time-series","title":"Canvas Module: Squareroot"},"/docs/module-reference/time-series#subtract":{"id":"/docs/module-reference/time-series#subtract","content":"Subtract (Time-series). This module calculates the difference of its two input values.","section":"Time-series","title":"Canvas Module: Subtract"},"/docs/module-reference/time-series#sum":{"id":"/docs/module-reference/time-series#sum","content":"Sum (Time-series). Calculates the (optionally rolling) sum of incoming values. For an infinite sum, enter a windowLength of 0.","section":"Time-series","title":"Canvas Module: Sum"},"/docs/module-reference/time-series#correlation":{"id":"/docs/module-reference/time-series#correlation","content":"Correlation (Time-series). Calculates (Pearson's) correlation between two input variables in a sliding window of length windowLength.","section":"Time-series","title":"Canvas Module: Correlation"},"/docs/module-reference/time-series#covariance":{"id":"/docs/module-reference/time-series#covariance","content":"Covariance (Time-series). Calculates the covariance of two input variables in a sliding window of length windowLength.","section":"Time-series","title":"Canvas Module: Covariance"},"/docs/module-reference/time-series#geometricmean":{"id":"/docs/module-reference/time-series#geometricmean","content":"Geometricmean (Time-series). Calculates the geometric mean of incoming values in a sliding window of length windowLength. At least minSamples values must be received before an output is produced.","section":"Time-series","title":"Canvas Module: Geometricmean"},"/docs/module-reference/time-series#kurtosis":{"id":"/docs/module-reference/time-series#kurtosis","content":"Kurtosis (Time-series). Calculates the kurtosis (or fourth standardized moment) of a distribution of values in a sliding window. Kurtosis is a measure of the \"peakedness\" of a distribution.  Note that at least 4 samples is required to calculate kurtosis.","section":"Time-series","title":"Canvas Module: Kurtosis"},"/docs/module-reference/time-series#max-(window)":{"id":"/docs/module-reference/time-series#max-(window)","content":"Max-(window) (Time-series). Calculates the maximum value in a sliding window of length windowLength. At least minSamples values must be received before an output is produced.","section":"Time-series","title":"Canvas Module: Max-(window)"},"/docs/module-reference/time-series#min-(window)":{"id":"/docs/module-reference/time-series#min-(window)","content":"Min-(window) (Time-series). Calculates the minimum value in a sliding window of length windowLength. At least minSamples values must be received before an output is produced.","section":"Time-series","title":"Canvas Module: Min-(window)"},"/docs/module-reference/time-series#percentile":{"id":"/docs/module-reference/time-series#percentile","content":"Percentile (Time-series). Calculates the value below which a given percentage of values fall in a sliding window of observations.","section":"Time-series","title":"Canvas Module: Percentile"},"/docs/module-reference/time-series#populationvariance":{"id":"/docs/module-reference/time-series#populationvariance","content":"Populationvariance (Time-series). Calculates the non-bias-corrected population variance. See the Variance module or bias-corrected variance.","section":"Time-series","title":"Canvas Module: Populationvariance"},"/docs/module-reference/time-series#skewness":{"id":"/docs/module-reference/time-series#skewness","content":"Skewness (Time-series). Calculates the skewness (or third standardized moment) of a distribution of values in a sliding window. Skewness is a measure of the asymmetry of a distribution.","section":"Time-series","title":"Canvas Module: Skewness"},"/docs/module-reference/time-series#spearmansrankcorrelation":{"id":"/docs/module-reference/time-series#spearmansrankcorrelation","content":"Spearmansrankcorrelation (Time-series). Calculates Spearman's Rank correlation between two input variables in a sliding window of length windowLength.","section":"Time-series","title":"Canvas Module: Spearmansrankcorrelation"},"/docs/module-reference/time-series#standarddeviation":{"id":"/docs/module-reference/time-series#standarddeviation","content":"Standarddeviation (Time-series). Calculates the standard deviation in a sliding window of the input time series.","section":"Time-series","title":"Canvas Module: Standarddeviation"},"/docs/module-reference/time-series#sumofsquares":{"id":"/docs/module-reference/time-series#sumofsquares","content":"Sumofsquares (Time-series). Calculates the sum of squared input values in a sliding window of length windowLength. At least minSamples values are collected before producing output.","section":"Time-series","title":"Canvas Module: Sumofsquares"},"/docs/module-reference/time-series#univariatelinearregression":{"id":"/docs/module-reference/time-series#univariatelinearregression","content":"Univariatelinearregression (Time-series). Performs a least-squares linear regression on a sliding window of input data. The model is y = slope*X + intercept.","section":"Time-series","title":"Canvas Module: Univariatelinearregression"},"/docs/module-reference/time-series#variance":{"id":"/docs/module-reference/time-series#variance","content":"Variance (Time-series). Calculates the bias-corrected sample variance (with N-1 in the denominator). Use the PopulationVariance module for the non-bias-corrected population variance.","section":"Time-series","title":"Canvas Module: Variance"},"/docs/module-reference/time-series#barify":{"id":"/docs/module-reference/time-series#barify","content":"Barify (Time-series). This is a utility for moving from event time to wall-clock time. This module outputs new values every barLength seconds. You would use this module to sample a time series every 60 seconds, for example.","section":"Time-series","title":"Canvas Module: Barify"},"/docs/module-reference/time-series#delay":{"id":"/docs/module-reference/time-series#delay","content":"Delay (Time-series). This module will delay the received values by a number of events. For example, if the  delayEvents parameter is set to 1, the module will always output the previous value received.  The module will not produce output until the delayEvents+1th event, at which point the first received value will be output. For example, if the parameter is set to 2, the following sequence would be produced:   InputOutput 1(no value) 2(no value) 31 42 ......","section":"Time-series","title":"Canvas Module: Delay"},"/docs/module-reference/time-series#flexbarify":{"id":"/docs/module-reference/time-series#flexbarify","content":"Flexbarify (Time-series). Similar to the Barify module, which creates open-high-low-close bars equally long in time, this module creates bars equally long in an arbitrary variable passed into the valueLength input.  Incoming valueLength is summed for the current bar until barLength is reached, at which point the outputs are sent and the bar is reset.  Note that if multiple bars would be filled on the same event, only one is output. To avoid this situation you may want to keep barLength substantially larger than incoming valueLength.","section":"Time-series","title":"Canvas Module: Flexbarify"},"/docs/module-reference/time-series#passthrough":{"id":"/docs/module-reference/time-series#passthrough","content":"Passthrough (Time-series). This module just sends out whatever it receives.","section":"Time-series","title":"Canvas Module: Passthrough"},"/docs/module-reference/time-series#fourzones":{"id":"/docs/module-reference/time-series#fourzones","content":"Fourzones (Time-series). This module waits for the input signal to reach either the highTrigger or lowTrigger level. Either 1 or -1 is output respectively. The triggered value is kept until it is set back to 0 at the corresponding release level.  If you set mode to exit, the output will trigger when exiting the trigger level instead of entering it.","section":"Time-series","title":"Canvas Module: Fourzones"},"/docs/module-reference/time-series#peak":{"id":"/docs/module-reference/time-series#peak","content":"Peak (Time-series). Attempts to detect upward turns below lowZone (outputs 1) and downward turns below highZone (outputs -1).  For an upward turn to be registered, the change between subsequent input values must be larger than threshold. For a downward turn the change must be less than -threshold.","section":"Time-series","title":"Canvas Module: Peak"},"/docs/module-reference/time-series#sampleif":{"id":"/docs/module-reference/time-series#sampleif","content":"Sampleif (Time-series). This module can be used to sample values from one timeseries upon events from another timeseries, just like the Sampler module.  However the triggerIf value must be equal to 1 for the value at value input to be sent out. Trigger events with other values than 1 will produce no effect.","section":"Time-series","title":"Canvas Module: Sampleif"},"/docs/module-reference/time-series#sampler":{"id":"/docs/module-reference/time-series#sampler","content":"Sampler (Time-series). This module can be used to sample values from one timeseries upon events from another timeseries.  An event arriving at the trigger input will cause the module to send out whatever value the value input has. The trigger is the only driving input.","section":"Time-series","title":"Canvas Module: Sampler"},"/docs/module-reference/time-series#threezones":{"id":"/docs/module-reference/time-series#threezones","content":"Threezones (Time-series). This module outputs -1, 0 or +1 depending on whether the input value is below lowZone, between lowZone and highZone, or above highZone respectively.","section":"Time-series","title":"Canvas Module: Threezones"},"/docs/module-reference/time-series#zerocross":{"id":"/docs/module-reference/time-series#zerocross","content":"Zerocross (Time-series). This module is used to detect when a time series crosses the zero line. It outputs -1 when below zero (minus threshold) and +1 when above zero (plus threshold).","section":"Time-series","title":"Canvas Module: Zerocross"},"/docs/module-reference/utils#canvas":{"id":"/docs/module-reference/utils#canvas","content":"Canvas (Utils). This module allows you to reuse a Canvas saved into the Archive as a module in your current Canvas. This enables reuse and abstraction of functionality and helps keep your Canvases tidy and modular.  Any parameters, inputs or outputs you export will be visible on the module. You can export endpoints by right-clicking on them and selecting \"Toggle export\".","section":"Utils","title":"Canvas Module: Canvas"},"/docs/module-reference/utils#comment":{"id":"/docs/module-reference/utils#comment","content":"Comment (Utils). Just a text box for comments. Commenting what you build is a good idea, as it helps you and others understand what is going on.","section":"Utils","title":"Canvas Module: Comment"},"/docs/module-reference/utils#constant":{"id":"/docs/module-reference/utils#constant","content":"Constant (Utils). This module represents a constant numeric value that can be connected to any numeric input. The input will have that value during the whole execution.","section":"Utils","title":"Canvas Module: Constant"},"/docs/module-reference/utils#email":{"id":"/docs/module-reference/utils#email","content":"Email (Utils). The Email module can be used to send notifications to your email address. Just like any module, it activates when an event is received at any driving input. The number of inputs can be set in module options, and the values at the inputs will be included in the email content. The inputs can be renamed to give them more descriptive names. When running against historical data, emails are not actually sent. Instead, a notification is shown representing the would-be email. Emails are capped at one per minute to avoid accidental self-spamming. Here's an example of email content:  Message: (your custom message)  Event Timestamp: 2014-11-18 10:30:00.124  Input Values: value1: 7357 value2: test value","section":"Utils","title":"Canvas Module: Email"},"/docs/module-reference/utils#exportcsv":{"id":"/docs/module-reference/utils#exportcsv","content":"Exportcsv (Utils). Generates a CSV (Comma-Separated Values) file from event data that flows into this module’s inputs. The file download link becomes available once the canvas has been started, and then stopped. You may wish to connect the inputs of this module to a `stream` module with real-time data flowing.","section":"Utils","title":"Canvas Module: Exportcsv"},"/docs/module-reference/utils#filter":{"id":"/docs/module-reference/utils#filter","content":"Filter (Utils). Only lets the incoming value through if the value at pass is 1. If this condition is not met, no event is sent out.","section":"Utils","title":"Canvas Module: Filter"},"/docs/module-reference/utils#label":{"id":"/docs/module-reference/utils#label","content":"Label (Utils). Displays a text representation of the input received in real-time. This module can take any data type and is often used to debug your canvas or display a single piece of data.","section":"Utils","title":"Canvas Module: Label"},"/docs/module-reference/utils#listastable":{"id":"/docs/module-reference/utils#listastable","content":"Listastable (Utils). Display contents of a list as a table. If it's a list of maps, break maps into columns","section":"Utils","title":"Canvas Module: Listastable"},"/docs/module-reference/utils#mapastable":{"id":"/docs/module-reference/utils#mapastable","content":"Mapastable (Utils). Display the entries of a map as a table.","section":"Utils","title":"Canvas Module: Mapastable"},"/docs/module-reference/utils#merge":{"id":"/docs/module-reference/utils#merge","content":"Merge (Utils). Merges two event streams into one. Whatever arrives at inputs A or B is sent out from the single output. The inputs and the output can be connected to all types of endpoints. A runtime error may occur if there is a type conflict.","section":"Utils","title":"Canvas Module: Merge"},"/docs/module-reference/utils#movingwindow":{"id":"/docs/module-reference/utils#movingwindow","content":"Movingwindow (Utils). Provides a moving window (list) for any types of values. Window size and behavior can be set via parameters.","section":"Utils","title":"Canvas Module: Movingwindow"},"/docs/module-reference/utils#ratelimit":{"id":"/docs/module-reference/utils#ratelimit","content":"Ratelimit (Utils). The RateLimit module lets through n messages in t milliseconds. Then module just blocks the rest which do not fit in the window.","section":"Utils","title":"Canvas Module: Ratelimit"},"/docs/module-reference/utils#requireall":{"id":"/docs/module-reference/utils#requireall","content":"Requireall (Utils). Simply passes the values of inputs to corresponding outputs, but only if all inputs receive a value on the same event. If one or more inputs do not receive a value on an event, none of the values are sent forward.","section":"Utils","title":"Canvas Module: Requireall"},"/docs/module-reference/utils#sendtostream":{"id":"/docs/module-reference/utils#sendtostream","content":"Sendtostream (Utils). Capable of pushing data from your canvas into a selected stream. The module will reveal its inputs based on the fields configured on your selected stream. To select your stream click into the value input inside the module and select from the dropdown menu containing all the streams you have permission to access. Ensure that your selected stream has some fields configured, otherwise the module will not show any inputs.","section":"Utils","title":"Canvas Module: Sendtostream"},"/docs/module-reference/utils#table":{"id":"/docs/module-reference/utils#table","content":"Table (Utils). Displays a table of events arriving at the inputs along with their timestamps. The number of inputs can be adjusted in module options. Every input corresponds to a table column. Very useful for debugging and inspecting values. The inputs can be connected to all types of outputs.","section":"Utils","title":"Canvas Module: Table"},"/docs/module-reference/utils#constantcolor":{"id":"/docs/module-reference/utils#constantcolor","content":"Constantcolor (Utils). This module represents a constant color value, that can be connected to any color input. The input will have that value during the whole execution.","section":"Utils","title":"Canvas Module: Constantcolor"},"/docs/module-reference/utils#gradient":{"id":"/docs/module-reference/utils#gradient","content":"Gradient (Utils). Generates an RGBA color string based on the combination of its inputs. The `Min Value` input correlates to the `Min Color` input. The `Max Value` input correlates to the `Max Color` input. The color output is determined by the `in` input in relation to these boundary values. For example, `Min Value = 0` `In = 0` `Min Color = Output Color` (e.g. White) Where, `Max Value = 1` `In = 1` `Max Color = Output Color` (e.g. Black) Where, `In = 0.5` Output color will be grey (rgba(128,128,128,1))","section":"Utils","title":"Canvas Module: Gradient"},"/docs/module-reference/visualizations#chart":{"id":"/docs/module-reference/visualizations#chart","content":"Chart (Visualizations). This module is the main tool for visualizing time series. The chart is updated on fly as new data becomes available. You can zoom the chart by dragging over the area you want to zoom to. To pan the chart while zoomed, use the navigator below the chart. Individual series can be toggled on or off by clicking on the series name in the legend. Also note that the chart module can be resized by dragging from its lower right corner.  Each input series is drawn on y-axis 1 by default. You can edit y-axis assignments by clicking the button beside the input endpoint.  The number of inputs is adjustable in the module options (the wrench icon). Other options include ignoring data points outside a certain time of day.  The module can also produce a downloadable CSV file containing whatever data points are sent to the chart. To use this feature, run in CSV export mode by selecting that option from the Run button dropdown menu.","section":"Visualizations","title":"Canvas Module: Chart"},"/docs/module-reference/visualizations#heatmap":{"id":"/docs/module-reference/visualizations#heatmap","content":"Heatmap (Visualizations). Displays a colored heatmap overlay on top of a geographical map.","section":"Visualizations","title":"Canvas Module: Heatmap"},"/docs/module-reference/visualizations#map-(geo)":{"id":"/docs/module-reference/visualizations#map-(geo)","content":"Map-(geo) (Visualizations). This module displays a world map. Markers can be drawn on the map at WGS84 coordinates given to the inputs latitude and longitude as decimal numbers (degrees). Markers also have an id. To draw multiple markers, connect the id input. Coordinates for the same id will move the marker, and coordinates for a new id will create a new marker.In module options, you can enable directional markers to expose an additional heading input, which controls marker heading (e.g. vehicles on the street or ships at sea). Other options include marker coloring, autozoom behavior etc.","section":"Visualizations","title":"Canvas Module: Map-(geo)"},"/docs/module-reference/visualizations#map-(image)":{"id":"/docs/module-reference/visualizations#map-(image)","content":"Map-(image) (Visualizations). This module displays a map based on an user-defined image. The image is loaded from a URL given in module options. The map automatically scales x and y coordinates between 0..1 to image dimensions. This means that regardless of image size in pixels (x,y) = (0,0) is the top left corner of the image, and (1,1) is the bottom right corner.Markers also have an id. To draw multiple markers, connect the id input. Coordinates for the same id will move the marker, and coordinates for a new id will create a new marker.In module options, you can enable directional markers to expose an additional heading input, which controls marker heading (e.g. direction in which people are facing in a space). Other options include marker coloring, autozoom behavior etc.","section":"Visualizations","title":"Canvas Module: Map-(image)"},"/docs/streams/intro-to-streams":{"id":"/docs/streams/intro-to-streams","content":"\n\nIntro to streams\n\nAll of the data in the Streamr network is contained inside individual streams. A stream is simply a sequence of data points in time. The data may originate, for example from machines on the factory floor, sensors in a smart city, in-house databases or systems, or from commercial streaming data feeds.\n\nStreams have the following properties:\n\nAny kind of real-time data can be stored in it.\n\nThe data will always be retrieved in the correct order.\n\nThe data is persisted on the Streamr network and identifiable by unique ID.\n\nSome common use cases for streams:\n\nSensory readings of speed and orientation\n\nGeolocation\n\nAmbient temperature and humidity \n\nSocial media messages\n\nStock market events\n\nMobile ad impressions\n\nThese are just a few examples. There is virtually no limit on the kind, format, or quantity of data you can feed into Streamr, even digital images, streaming video, or other domain-specific data could be pushed into a stream.\n\nStreams implement a publish-subscribe paradigm, or pub/sub for short. A stream can receive data from many sources (or publishers), and there can be several listeners who subscribe to a stream. There are several variations on the possible pub/sub topologies, such as many-to-one, one-to-many, or many-to-many. Streamr supports all of these.\n\nIf you want to try it out already, you can dive into our tutorial on building a simple pub/sub system with Streamr.\n\nExample stream\n\nHere’s an example of what a small part of a stream could look like. Each row shows one data point, and the columns correspond to the timestamp followed by two data fields, a measurement of the operating temperature and the number of rotations per minute (RPM).\n\n\n\nStream data fields\n\nA field is a kind of placeholder for an individual piece of data, from a single data point. Each data point contains at least one data field, but you can have as many fields per data point as required.\n\nFor example, here's a data point in a stock market stream.\n\n\n\nGiven the structure of this data point, the stream's fields could be configured as follows:\n\n\n\nData field types\n\nThere’s a number of built-in data types that can be used in a stream. These are:\n\nNumber is a numeric data type internally stored as a double precision (64-bit) float.\n\nBoolean is a logical data type with two possible values, True and False. In Streamr, a numeric value exactly equal to one represents logical truth. Anything else is interpreted as a logical falsehood.\n\nString is a sequence of zero or more alphabetical characters.\n\nObject is a collection of key-value pairs. Each key is a string, and the value can be of any built-in data type (even another object). Object is equivalent to Java's 'Map'.\n\nList is an ordered collection of zero or more elements. List is equivilent to an array.\n\nField types can be freely mixed in a single data point. And you can freely add new fields to an existing stream; you don’t have to know what fields you might eventually need. A single data point can be of any size within reason, and a stream can grow indefinitely when extended by new data points.\n","section":"Streams","title":"Intro to streams"},"/docs/streams/using-streams-in-core":{"id":"/docs/streams/using-streams-in-core","content":"\n\nWork with streams in Core\n\nStreamr Core provides you with the tools to create, edit, share and delete your streams as well as view and inspect the streams you have purchased on the Marketplace.\n\nOverview of your streams\n\nHead over to the Streams page to see an overview of your subscribed streams. The list includes streams you have created and streams that you have purchased on the Marketplace.Using streams in Core\n\n\n\nThis stream listing page gives an indication for when data was last pushed to each stream and uses traffic light indicators show the health of each stream, at a glance. Green shows a stream receiving data, while red indicates no data flowing. Clicking on a stream will open the stream editor. You may only edit streams that you have created or have explicit permission to edit.\n\nBy clicking on the more options icon you may access advanced features for each stream, such as stream sharing and code snippets. A new stream can be created by the clicking the Create Stream button.\n\nEditing a stream\n\nThe stream editor provides basic tools for setting up, inspecting and editing your stream. Below is a run-down of each stream editor section.\n\nDetails\n\nThe details section provides basic information about your stream.\n\nThe stream name is used to identify your stream in the Core app.\n\nThe stream description can be used to offer more information about your stream and the kind of data it contains.\n\nThe stream ID is the unique identifier for your stream and is needed when interacting with the Streamr SDKs.\n\n\n\nConfigure\n\nIn this section you can configure stream fields and their data types. All fields have a name and a data type. The Autodetect feature can be used to automatically deduce fields from the stream's last received message. It is possible to manually correct the data types if automatic detection is not suitable for your stream.\n\n\n\nYou can also optionally toggle on the requirement for all messages to be signed to enforce a level of verification if you choose.\n\nPreview\n\nThis section is used to preview data flowing into the stream. Use the live inspector to make sure your stream is receiving data and it is correctly formatted.\n\n\n\nAPI Access\n\nHere you can manage API keys for your stream. Keys generated here grant access to only this stream and can have either read or write access. These keys can also be removed if for example, the key has been compromised.\n\n\n\nHistorical Data\n\nThis section contains the stream's historical data storage settings and includes tools to add or remove historical data from the stream.\n\n\n\nYou can add new data to the stream by uploading a CSV file and you can delete existing historical data from the stream by choosing an inclusive date range.\n\nThe historical data storage period determines how many days your data is retained before it will be removed automatically from the Streamr network. The default period is 365 days.\n","section":"Streams","title":"Streams in Core"},"/docs/streams/using-streams-via-sdk":{"id":"/docs/streams/using-streams-via-sdk","content":"\n\nWork with streams via SDKs\n\nThe easiest way to work with streams is to use the JavaScript client, which works in Node.js as well as the browser. See the SDKs section for the official and community-maintained client libraries available for various languages.\n\nAuthentication\n\nWhen reading from or writing to streams, you need to provide a session token or an API key, or login with an Ethereum account. To read more about API keys or obtaining a session token, refer to the Authentication section of the API docs.\n\nCreating a client instance with API key\n\nJavascript\n\n\n\nJava\n\n\n\nSubscribing to real-time events in a stream\n\nBy subscribing to Streams, your application gets immediately notified about new events in the stream.\n\nJavaScript\n\n\n\nJava\n\n\n\nPublishing events to Streams\n\nJavaScript\n\n\n\nJava\n\nEvents in Streams are key-value pairs, represented in Java as Map objects. Below is an example of creating an event payload and publishing it into a Stream.\n\n","section":"Streams","title":"Streams via SDKs"},"/docs/streams/using-streams-via-api":{"id":"/docs/streams/using-streams-via-api","content":"\n\nWork with streams via API\n\nWhile the Core UI can do just about everything you'd want to do with streams, sometimes the using the API directly is preferred.\n\nData output over HTTP\n\nEvents in streams can be queried via HTTP. Example using curl:\n\n\n\nThe following endpoint would return the 5 most recent messages in a stream (or to be more precise, the default partition 0 of a stream):\n\n\n\nThe HTTP API covers session management, data input, data output, and managing Streamr resources such as Canvases, Streams, and Dashboards. The endpoints allow you to list, create, read, update and delete the resources, as well as execute resource-specific actions such as start and stop Canvases. You best way to view all of streams endpoints is in the API explorer.\n","section":"Streams","title":"Streams via API"},"/docs/streams/data-signing-and-verification":{"id":"/docs/streams/data-signing-and-verification","content":"Data signing and verification\n\nAuthenticity and integrity of events published on a stream can be guaranteed with digital signatures. Every stream's metadata has a boolean requiresSignedData that can be set by the stream's owner to let subscribers know whether they should expect signed or unsigned events.\n\nEvery message published to a stream has six fields that uniquely identify this message across time, all streams and all publishers:\n\nstreamId\n\nstreamPartititon\n\ntimestamp\n\nsequenceNumber\n\npublisherId\n\nmsgChainId\n\nMore details about these fields can be found in the protocol specification. All together they form the message ID. They must be signed along with the actual message  content to resist against replay attacks. So the payload to be signed for every message by every publisher is the following.\n\n\n\nThe signing algorithm follows the convention described here. The secp256k1 ECDSA algorithm is applied on the keccak256 hash of a string derived from the challenge text.\n\n\n\nOn the recipient side, every subscriber needs to verify signed events. If a received event is unsigned, the subscriber accepts the event if and only if the stream's boolean flag requiresSignedData is set to false. The signature verification is done in three steps:\n\nThe subscriber extracts from the event and the signature the Ethereum address that signed the message (using the EC recover operation).\n\nCheck that the address recovered in step 1 matches the address defined by publisherId\n\nCheck that this publisherId belongs to the set of valid publishers for that stream by querying the api/v1/streams/${id}/publishers endpoint.\n\nBoth signature computation and verification are implemented in the JavaScript and Java SDKs.\n","section":"Streams","title":"Data signing & verification"},"/docs/streams/end-to-end-encryption":{"id":"/docs/streams/end-to-end-encryption","content":"End-to-end encryption\n\nDocumentation coming soon\nConfidentiality of events published on a stream can be guaranteed with end-to-end encryption. The publisher decides on a AES-256 symmetric group key and encrypts the messages in CTR mode before publishing them to the network. The subscribers must know this symmetric group key in order to decrypt the data.\n\nCurrently, the symmetric key must be shared between the publisher and the subscribers in a secure way outside of the Streamr Network. In both the Javascript and the Java SDKs, the publisher can pass group keys per stream as parameters and the subscriber can pass group keys per stream and per publisher as parameters. Later it will be possible to use a secure key-exchange protocol directly in the Streamr Network.\n\nIn order to prevent new subscribers to eavesdrop and then decrypt past messages published before the start of their subscription, the publisher can decide at any time to update the symmetric group key by sending a new key concatenated with an event and encrypted with the current key:\n\n\n\nBoth the Javascript and the Java SDKs support this key update mechanism. It can be triggered by calling the publish method with a new symmetric group key as parameter.\n","section":"Streams","title":"End-to-end encryption"},"/docs/streams/partitioning":{"id":"/docs/streams/partitioning","content":"\n\nPartitioning\n\nTo be precise, when messages are published to a stream, they are actually published to a partition within that stream. Partitions can be understood as sub-streams, or in other words, parts of a stream. One partition per stream is the default, which is sufficient for streams with moderate rates of data (approx. less than 100 msg/sec).\n\nWhen a stream needs to handle large data rates, partitions are used for sharding of the data. Sharding data simply means dividing a large volume of messages to multiple partitions, a bit like a large river can split the same amount of water to multiple smaller branches. Each partition shares the general properties of the parent stream, such as name, description, and user permissions, but the partitions behave independently when it comes to delivering and storing data in the Streamr Network, which allows for scalability.\n\n\n\nPartitions also enable subscribers to scale horizontally: a user consuming data from a stream could load balance the messages over a number of consuming processes, up to the number of partitions. So if a stream has 5 partitions, the user could start up to 5 independent subscribers on separate physical machines, with each subscriber receiving different messages (each process subscribes to a unique partition).\n\nPartitions are identified by a number which starts from zero. For example, a stream with only one partition contains the partition 0 and all of the stream's data flows through this partition. A stream with 5 partitions has partitions 0 through 4 - here the stream's data is distributed across these 5 partitions. The data publisher is free to choose the target partition for each message. If no partition is specified, the data goes to partition 0.\n\nWhile the data publisher is free to choose a target partition for a message arbitrarily, a common approach is to utilize a partition key. A partition key is a value chosen from the data which is used to determine the partition of the message. For example, a customer ID could be used as a partition key in an application that publishes customer interactions to a stream. This way, all messages from a particular customer always go to the same partition. This is useful because it keeps all the events related to a particular customer in a single and known partition instead of spreading them over all partitions.\n\n\n\nThe publish methods in the Streamr SDKs usually take an optional partitionKey parameter. For example, in the JS client:\n\n\n\nInternally, the library maps the partitionKey to a partition number using a hash function (modulo the number of partitions in the stream):\n\n\n\nAt the time of writing, there are some limitations with multi-partition streams: The number of partitions can only be set when creating streams via the API, and the number cannot be changed afterwards. When using multi-partition streams on canvases, the canvases always subscribe to all partitions in a stream.\n\n\n\nCurrently partitions don’t have well-defined rate limits, but future versions of the P2P network may enforce limits. For now, we recommend not exceeding around 100 msg/sec/partition.\n","section":"Streams","title":"Partitioning"},"/docs/streams/integration-patterns":{"id":"/docs/streams/integration-patterns","content":"Patterns for data integration\n\nThere are three distinct patterns for connecting data to Streamr, each with their own advantages and disadvantages.\n\nPushing from the source\n\nGood Simplicity \nGood Latency \nMedium Applicability\n\nIn this pattern, the data points are sent directly to Streamr by the source as soon as new data becomes available (for example, a sensor produces a new measurement).\n\nThis is the recommended pattern. However, depending on the circumstances, it may not always be available. It requires that you have control over the system that produces the data and can decide where it gets sent.\n\nFor example, if you are an IoT device manufacturer, you could add support for Streamr directly into your devices or gateways, enabling all your end users to easily connect their data to Streamr.\n\nVarious industrial data sources usually have good configurability for connecting the data anywhere you need to. However, consumer grade devices such as connected cars, phones, Fitbits, and others often force you to send your data to the manufacturer’s cloud, from where they might serve it back to you via an API. In these cases, you can use one of the bridging patterns in this post (see options two and three).\n\nFor a real-world example, here’s how to connect measurements from any number of Ruuvi IoT tags to Streamr. The devices transmit data over Bluetooth Low Energy to a gateway computer which runs this node.js script. A separate stream is created for each found Ruuvi device, and the measurements are produced to the appropriate stream as they occur.\n\nBridging from a streaming source\n\nMedium Simplicity \nGood Latency \nMedium Applicability\n\nThis pattern is useful when you don’t have direct control over the source, but a streaming API or some other kind of listener hook is available for the data. These allow you to be notified whenever new data occurs, enabling you to immediately forward the event to Streamr. Data that is typically available via these kinds of APIs are news feeds, financial market data and social media feeds.\n\nBridging by polling a source\n\nMedium Simplicity \nMedium Latency \nGood Applicability\n\nMost cloud services handing out data at least offer a request-response-based API, which can be used if neither of the above push-based options are available. In this case there is no way to get notified when new data is available, which means that the API needs to be repeatedly queried. This is called polling.\n\nIt’s not an optimal way to serve real-time data, because:\n\nData can be missed: multiple value changes in between subsequent requests are not observed.\n\nIt places an unnecessary load on the API server, as requests are made “just in case” regardless of whether the data has actually changed or not.\n\nAn average latency of half the polling interval is introduced.\n\nFor more information and examples on using these integration patters, please see this deep dive blog post. Please note that the examples used an older version of streamr-client and you should confirm with the official docs on the best practices. \n","section":"Streams","title":"Integration Patterns"},"/docs/canvases/intro-to-canvases":{"id":"/docs/canvases/intro-to-canvases","content":"\n\nIntro to canvases\n\nA Streamr canvas is a microservice which consumes and acts upon real-time data. A canvas contains one or more streams (these provide the data) and one or more modules (these do the processing). Streams and modules are connected in the configuration that you'll design. The connections determine how the data flows through the canvas.\n\n\n\nHere's a few examples of specific things you can do;\n\nRefine real-time data by routing it through different modules. The built-in module library  includes arithmetic and logical operations. There are also functions for smoothing, sampling, and aggregating streaming data.\n\nChain modules together so that the output from one operation flows as an input to another. This is one way to build arbitrarily complex streaming analytics. If you want to keep things tidy, you can encapsulate the complexity and reuse the abstracted result.\n\nVisualise the data by directing it to a charting module. The chart shows the new data in real-time as new events arrive or streaming analytics are computed.\n\nCommunicate with the outside world by sending text messages or emails when specific conditions are satisfied. You can embed realtime data, refined data, or natural language in the messages.\n\nSave refined data in another stream. When you do this, the saved data are instantly accessible as new events. The refined data can be streamed from the platform to external data consumers.\n\nPost events in HTTP format to external RESTful services. There's a wide range of popular and useful services out there, and you can use any one of them easily from Streamr.\n\nControl external devices. As an example, you can override manual controls and make a remotely operated drone return to base when it's about to go out of range or running low on battery. Because the control interface is likely to be machine specific, this is one case where you'd be looking at coding a custom module in Java.\n\nSubscribe to a stream in external web pages and applications. You'll receive every event as soon as it’s available.\n\nThere is an extensive collection of built-in modules as a source of building blocks. You can abstract modules and re-use them later, and you can code custom modules in Java.\n\nWhen you're ready to build a canvas, you’ll typically start by adding one or more data streams to the canvas workspace. You’ll then create the processing logic by adding modules to the canvas and connecting the streams and modules together. You can do all this interactively by dragging and dropping streams and modules from the module browser to the workspace and then drawing connections between them.\n","section":"Canvases","title":"Intro to canvases"},"/docs/canvases/using-canvases-in-core":{"id":"/docs/canvases/using-canvases-in-core","content":"\n\nUsing canvases in Core\n\nTo create a new canvas, click Create Canvas on the Core > Canvases view. You'll see all of your canvases along with their running state on the canvases listing page. Click on a canvas preview tile to open it in the editor. You can also search and sort your canvases by their name, when they were modified, or from their running state. Hover your mouse over the canvas preview tile to discover extra things you can do with your canvas such as sharing it with friends or the public.\n\n\n\nCanvas Modes\n\nYou can run your canvas in one of two ways - historical or realtime mode. There's a natural iterative workflow where you first build a perhaps rudimentary version of a canvas, test it with historical data where possible, refine the design based on the test findings, and repeat until you're happy to run it in real-time.\n\n\n\nRealtime mode\n\nRealtime mode (default) is used in production where you want to react to data points as they arrive. Real-time data can flow from streams or can be generated from modules connected to the outside world, e.g. a HTTP API GET request.\n\nWhen you run a canvas in real-time mode, it will listen to real-time events arriving in the subscribed streams, and process them as soon as they're available. When the canvas is running you won't be able to edit it, if you need to make changes, you'll need to stop the canvas and then restart it.\n\n\n\nA live canvas keeps running until you explictly tell it to stop. When you stop a canvas, its internal state is saved on the disk. If you later restart the canvas, it will gracefully resume from the point where it stopped. It will not, however, process any events that occurred when it was not running.\n\nHistorical mode\n\nHistorical mode is a playback of what has happened in a past date range. A playback can be extremely useful when you’re testing, refining, or demonstrating the functionality of a canvas.\n\nA canvas run in historical mode consumes a playback of past events stored in the subscribed streams. The playback is a simulation of what has happened in the past. You may run the canvas in historical mode provided the streams inside the canvas contain some historical data.\n\n\n\nYou can specify the time period (the start date and the end date) for the historical playback period as well as the speed of playback. By default, playback events are processed sequentially but at a much faster pace compared to the actual history. You can easily change the playback speed for the historical run. Click on the arrow menu icon, connected to the Run button to choose your desired playback speed.\n\nThe playback starts when you press the Run button.\n\n\n\nReusing canvases as modules\n\nYou can easily reuse a canvas as a component of another canvas. This is done via abstraction, where you encapsulate a canvas as a module. You can then use the new module when you build additional canvases.\n\nTo create an abstraction, you'll need to expose — or export — inputs and outputs. The exported endpoints will show up as endpoints of the abstracted canvas.\n","section":"Canvases","title":"Using Canvases"},"/docs/canvases/modules-basics":{"id":"/docs/canvases/modules-basics","content":"\n\nUsing modules - basics\n\nA module is close akin to what you'd call a function, subroutine, procedure, or a method in various programming languages. In Streamr, modules are specialised computation units for handling streaming real-time data. A module processes its inputs as soon as it is activated by the arrival of a new event. The module may have one or more outputs, or it may take care of some side effect instead.\n\n\n\nA module has an internal state, and it can and typically will update that state when it is executed. How this is done depends on the particular module. The statefulness is an important feature and one the key ingredients in real-time stream processing.\n\nYou'll find all the built-in components in the module browser. If you already know the name of the module you need, type its name in the search box, then select the right module or stream, or drag it into your workspace. You can hide and show the browser using the + button on the toolbar.\n\n\n\nInputs, outputs, and parameters\n\nA module can have inputs, outputs, and parameters. Whilst a module does not need to have any inputs or outputs, useful modules will typically allow for either incoming or outgoing data (and usually both).\n\nWhen placed on a canvas, the inputs are shown as circular connectors along the left-hand side of the module. The outputs are shown as connectors along the right-hand side.\n\nMany modules have parameters which control their operation. Module parameters can be hardcoded, but their values are typically not immutable. If a parameter can be modified at run-time, there is an associated parameter editable input inside the module.\n\n\n\nAs an example, the RoundToStep module has three inputs, two parameters, and one output. The first two inputs correspond to the module’s parameters, i.e. precision and mode. The last input is a numeric value which will be rounded with the specified precision in the direction specified by the mode. The module output is equal to the rounded input. Inputs, outputs, and parameters can be renamed by double clicking on them and typing new text. Renaming has no bearing on functionality.\n\n\n\nAdding streams\n\nWhen you place a stream on the canvas, you effectively subscribe to a real-time data source. To add a stream, just start typing its name in module browser search. The stream name will autocomplete as you type. Real-time events are now available at the output endpoints.\n\n\n\nYou can move modules around on the workspace as you wish, the placement of a module has no impact on functionality. For clarity, you may want to design the canvas so that module placement reflects the data flow from the input streams through the modules.\n\nAs a simple example, here's a canvas consisting of one stream and a chart module connected together. When you run the canvas, the events flow from the stream to the chart, and the chart draws the data points as they arrive.\n\n\n\nSending data to a stream\n\nUse the SendToStream module if you want to send data that has been generated inside the canvas, into a stream. Inside the module, start typing the name of your stream and it will autocomplete for you. Remember to configure the fields of your stream before using this module as the module's inputs are defined by it's fields. Learn more about fields in the streams docs.\n\n\n\nConnecting modules\n\nA data flow between two modules — or a data flow between a stream and a module — is created by drawing a connection from an outgoing endpoint (port) to an incoming endpoint. You can create as many outgoing connections as you wish. You can only have one incoming connection per an endpoint.\n\nAlong with inputs and outputs, there are also parameters. Parameters are just inputs with default values. Because a parameter has a default value, there is no need for an incoming connection in the corresponding endpoint.\n\n\n\nYou can only connect endpoints with compatible data types. As you hold your mouse down, compatible connections will glow green and incompatible connections glow red. For instance, you cannot create a connection which feeds string events to an endpoint where numerical events are expected. There are conversion modules such as StringToNumber which can help when you get stuck with the wrong data type.\n\nAll connections are unidirectional, i.e. the data always flows from an output to one or more inputs in one direction only. The modules form a directed graph. Feedback loops are discouraged, but you can create them if you really want.\n\n\n\nYou can alter the endpoint of an existing connection by dragging it to another input endpoint. If you instead drop the endpoint in an empty area in the workspace, the connection is cleared. Right clicking on top of a module port will bring up a pop-up menu with the option to disconnect all incoming connections to the module.\n","section":"Canvases","title":"Modules basics"},"/docs/canvases/modules-advanced":{"id":"/docs/canvases/modules-advanced","content":"\n\nUsing modules - advanced\n\nThe design and layout of the services you create with modules and canvases can be as complex as you choose. You can of course design a simple sequential work flow, and in many cases it will be perfectly adequate. In other cases the flow of data may involve merging data pathways, branches and even loops. Go ahead, be adventurous, but also bear in mind Streamr's abstraction capabilities. Reusing existing canvases will help you manage the development process and keep things tidy and neat.\n\n\n\nModule logic rules\n\nAny non-boolean events are automatically converted to logical truth values if a boolean input is required. \n\nNumbers exactly equal to zero are deemed to be False, and any non-zero values True.\n\nAn empty string (\"\") is False, a non-empty string is True. \n\nAn empty list is False, a non-empty list is True. \n\nAn empty Map is False, and anything else is True.\n\n\n\nModule activation\n\nComputation in Streamr is entirely event-based. Any module will execute immediately when activated by incoming events. When new events arrive in the input stream, the data automatically flows through the canvas. This inherently asynchronous process allows for fast and continuous in-memory processing of large volumes of realtime data.\n\nA module processes its inputs as soon as it is activated. This happens when the following conditions are both satisfied; every input has a value and an event arrives at one of the driving inputs.\n\n\n\nAt least one endpoint in any module is designated as a driving input by default. To change the default settings, hover on top of a module and you’ll see a number of additional controls. You can make any input a driver by clicking on the associated DR icon (a toggle button) next to an input connector. A module with no driving inputs will never activate.\n\nLastly, note the NR icon next to each output connector. This is a non-repeat button, and if it’s on, the module suppresses any output that would be an exact replica of the last outgoing event. This covers the use case where you’re only interested in events that represent something new.\n\n\n\nState and methods\n\nEvery Streamr module can have a state. If present, the state persists between module activations and even when a live service is stopped and later restarted. Whilst a module does not need to have a state, there are many streaming data operations which simply cannot be implemented without one.\n\nThe state of a module is kept in its instance variables (aka member variables or member fields). Each instance of JavaModule has its own variables, and these are visible and acccessible in that one instance only. You can use any of the valid Java data types for the instance variables. Here's some examples of valid declarations:\n\n\n\nAny manipulation of the module state and the generation of module output is handled by JavaModule's methods. There are three methods that you need to override and implement. They are the following:\n\ninitialize(): This method is called once when a specific JavaModule is activated. This is where you define and initialise the instance variables (i.e. the module state).\n\nsendOutput(): This is where you read the incoming events, perform arbitrary calculations, and send events downstream. You can see and alter the module state here.\n\nclearState(): This is where you reset the module state. Any module must be able to reset itself to its initial state on request. This is typically done by reinitialising the instance variables.\n","section":"Canvases","title":"Modules advanced"},"/docs/products/create-product":{"id":"/docs/products/create-product","content":"\n\nCreate a Product\n\nIn the Streamr Marketplace, you can buy and sell a variety of real-time data products, and if you have access to your own real-time data, you can make and sell your own within the Core app. A product is a single stream or bundle of real-time data streams either sold or made available for free on the Marketplace. These streams typically originate from sensors or applications. You can also create crowdsourced data products with Core, where they are called Data Unions.\n\nCore and the Marketplace support crypto token payments using Streamr's native token DATA, DAI or ETH. To create or purchase paid products, you will need an Ethereum wallet, some ETH for gas, and some DATA, ETH or DAI, if making purchases. Below we'll run through the basics of creating a product.\n\n\n\nCreate a product in Core\n\nCreating a product in Core is quite simple, but requires some preparation. Once you're ready, simply go to Core > Products and click Create Product But before you do, you should prepare the various things listed below. If you get stuck halfway through, you can click Save & Exit at any time, and Streamr will keep a draft of your product. When you come back, simply click on the draft product tile in Core > Products to continue.\n\nThe Product edit validator helps you to see what is required for publishing. If you see an orange ! icon there, it means you've skipped a section required. Once all the required sections have blue ticks, you're ready to publish.\n\n\n\nPrepare your streams\n\nYou need some real-time streams, added to Streamr. You can do this in Core > Streams by clicking Create Stream This will open the Stream editor, and create an empty stream container, with a unique ID. Then all you need to do is\n\nCopy the ID to use in your code to pipe data into Streamr\n\nTest whether data is flowing correctly by using the Preview section\n\nField names, type and order should be auto-configured by Streamr\n\nIf not, manually name fields, select type and drag-to-order them \n\nAdd historical data to a stream by uploading a CSV file\n\nAdd your streams\n\nAll streams you have added to your Streamr account will show in the stream selector part of the Product Editor. Click to select as many streams as you like, but do consider how to best provide value to your buyers.\n\n\n\nCover images\n\nYou will need a good cover image. If you have a designer who can help, this is ideal, otherwise you can find many high quality free images at Unsplash.com or Reshot.com. Make sure your image is around 1000-1200 pixels on the long side so it is sharp even on large, high-dpi screens. Something thematically related to your data is good if you don't have custom imagery for it. If you upload the wrong one, just upload another and it will be replaced.\n\nDescription\n\nWrite a good description, be concise, but give enough details for buyers to understand the value of your data. You can use Markdown to format headlines and lists, but do remember to keep it simple. You can write as much as you like, but something around 400 words maximum is probably a good rule of thumb.\n\n\n\nPrice\n\nYou can make your product free or paid. For paid products, set price by minute, hour, day or week intervals. You can switch between viewing price in Streamr's DATA token or fiat currency for your convenience. You can also choose to fix price in fiat to protect against sudden shifts in the DATA price.\n\n\n\nDetails and Terms\n\nHere you can add contact details, choose a category, add your website for more information, as well as add some social media links. Social media is optional, but can help buyers feel more confident in buying from you as they can check your reputation online more easily. Terms allows you to state the terms you are offering your data on. You can choose from some multiple choice options, in addition to giving a link to a PDF or website which contains full terms of use..\n\nPublishing\n\nFor a paid product, you'll need a web3 wallet, and a small amount of ethereum for gas fees, required to publish the product to the Marketplace smart contract. The Publish button will be enabled once required sections are filled, so click that, unlock your wallet and confirm the transaction. Your product will be published on the Marketplace once the ethereum blockchain has confirmed your transaction.\n\n","section":"Data Products","title":"Create a Product"},"/docs/data-unions/intro-to-data-unions":{"id":"/docs/data-unions/intro-to-data-unions","content":"\n\nIntroduction to Data Unions\n\nAs a general concept, a Data Union is a structure that allows separate entities who generate data to pool their data in order to achieve a common goal, typically to increase its value. Data Unions may differ from each other based on the membership model, use cases, revenue structure and governance, but also share some common components: a group of members contributing their data, an entity providing the application layer to manage the data and a discovery mechanism or marketplace for the data.\n\nStreamr implements this idea with its Data Unions Framework, which allows admins to create crowdsourced data products that combine real-time data from many members into a single, more valuable dataset. \n\nA Data Union Product is an Ethereum smart contract, created and deployed via the Core app and published on the Marketplace. Most revenue from a Data Union flows to its members, but the admin can set a percentage fee they receive in return for creating and managing the union. For more information on structure, see Data Union Framework Roles.\n\n\n\nWhat you’ll need\n\nCreating a Data Union requires a Streamr account, with a connected Ethereum address, to create, manage and receive revenue from the underlying smart contract. It also requires a host application that enables your users to join and provide real-time data. \n\nOnce the product is published, you can view revenue and community size and manage members via the Core app. Revenue from marketplace subscriptions will be paid out to members in the Streamr token, DATA, once it has accumulated in the smart contract.\n\nThe most valuable Data Unions will incentivize collection of datasets otherwise difficult to source. Some examples could include real-time health data, web user data, pollution monitoring, smart city data and more. \n\nPre-flight Checklist\n\n\n\nCreated a Streamr account\n\nConnected an Ethereum address to your account\n\nHave an ETH balance at that address to deploy and publish the product\n\nCreated a name, description and cover image for the Marketplace listing\n\nHave an app with a community of users who will provide real-time data\n\n\n\nGeneral Flow\n\nUse the Core app to create and deploy a draft Data Union smart contract\n\nConnect the smart contract to your app\n\nAdd users and publish to the Marketplace\n\nYou must have a minimum of  to publish, but the larger the number\n  of members, the more valuable your product is likely to be\n\nManage users and view revenue via the Core app\n\nGet Started\n\nIf you want to get started now, you should learn how to Build a Data Union with Core. If this is your first time, learn how to Create a Product with Core first. For an in-depth guide to connecting your app to a Data Union, check out our Data Unions Integration Guide.\n","section":"Data Unions","title":"Intro to Data Unions"},"/docs/data-unions/create-data-union-with-core":{"id":"/docs/data-unions/create-data-union-with-core","content":"\n\nBuild a Data Union with Core\n\nTo create a Data Union in Core, go to Core > Products, click Create and choose Data Union as the product type. Other than the sections below, the process is similar to creating a Data Product. If you haven’t made one before, please check out Creating a Data Product before proceeding with this article.\n\n\n\nConnect an Ethereum identity\n\nIn order to manage your data union, you need to connect your Ethereum address to your Streamr account. This is required before deploying your Data Union. Note that this won't be shown if you have already connected an Ethereum address.\n\nAdmin fee\n\nAdministrators are responsible for maintaining the Data Unions, including ensuring good data quality and removing members that are not contributing data as expected. They are incentivized by receiving an admin fee, a percentage of incoming revenue. Members agree to it by joining the Data Union.\n\nShared secrets\n\nShared secrets are only available once you have deployed your product, and provide access control for your product. It allows new members to join the Data Union without explicit approval from the Data Union admin, in order to streamline the on-ramp process. Users may still join the Data Union without a secret but they will have to be manually accepted.\n\nDeploying a Data Union\n\nCreating a Data Union starts with deploying the Data Union smart contract. A Data Union is identified by the address of its smart contract. The admin who deployes the contract then becomes the owner of the contract as well. Once all the required fields have been filled and the draft Data Union is ready to be deployed, click Continue to deploy the Data Union. The deploy dialogue will walk you through the deploy process.\n\nFor the contract deployment transaction, you'll need a web3 wallet, and a small amount of Ethereum for gas fees. The Data Union deployment might take a moment to register once the transaction has been mined. The progress indicator will show an estimate of the remaining time. You can either close the dialog and move on or wait for the process to complete after which you will be automatically redirected.\n\n\n\nPublishing a Data Union\n\nA minimum of  is needed to publish the Data union. Once enough members have joined the Data Union, you can publish the Data Union by clicking Publish from the action bar. Your Data Union will be published on the Marketplace once the Ethereum blockchain has confirmed your transaction.\n\nManaging the Data Union\n\nData Unions are listed along with Data products in Core > Products. Data Unions are marked by a Data Union badge and a Members badge showing the current amount of approved members. Click the tile menu to access the Data Union stats and manage members.\n\nThe Stats view provides an overview of the Data Union as well as it's members and subscribers over time, while the Members view allows you to manage join requests.\n\n","section":"Data Unions","title":"Create a DU with Core"},"/docs/data-unions/framework-roles":{"id":"/docs/data-unions/framework-roles","content":"Data Unions Framework Roles\n\nThe Data Union framework allows app developers to aggregate and monetise the real-time data their app users create whilst sharing revenue with them. The data from many different users are pooled into products offered on the Streamr Marketplace. \n\nThis process is called crowdselling. When someone subscribes to the product, the revenues, in DATA, are automatically distributed among the Data Union members — the individual data producers. The framework defines various roles, which we’ll describe next.\n\nMembers\n\nMembers are the people and devices that produce data (via the data-producing application) into the data streams associated with the Data Union. After joining, they  start receiving a share of revenue from the Data Union Products sold on the Marketplace. \n\nMembers are identified by an Ethereum address, and they join the Data Union by doing a simple HTTP request as described in the Work with Data Unions page.\n\nAdministrator\n\nAdministrators have the power to add and remove members. They are responsible for maintaining the products on the Marketplace, including ensuring good data quality and removing members that are not contributing data as they're expected to. \n\nThe Administrators are incentivized to perform this work by the adminFee, a fraction of incoming revenue. Administrators can set the adminFee, and members agree to it by joining the Data Union. Already incurred earnings are of course not affected by changes in the adminFee.\n\nTypically, Administrators are initially the creators of the data-producing application and the Data Union Product, though this role can be assigned to someone else or even performed by the members themselves via a DAO.\n\nOperator and Validators\n\nTechnically, the scalable revenue sharing used in Data Unions is based on Monoplasma, an off-chain token distribution system. Each Data Union has a corresponding Operator,  who runs a particular piece of software to keep track of balances. This is similar to Ethereum clients doing the bookkeeping for the DATA tokens in the blockchain.\n\nOperators watch the Ethereum blockchain to detect token transfers into the Data Union contract. They also watch a Streamr stream to keep track of members joining/parting the Data Union. The actions of the Operator are fully transparent and can be verified by Validators, and anyone can run a Validator.\n\nSmart Contract\n\nThe DataunionVault smart contract holds the incoming revenue. It releases the revenues belonging to a member requesting them with a proof of earnings. A member can query its earnings (and the proof) from the Operator or any of the Validators. Getting the proof and validating is fast, no transactions needed.\n\nThe DataunionVault holds all the out-standing revenue shares belonging to the Data Union members, and anyone following the Ethereum blockchain and the public Streamr stream (the Operator and the Validators) can know how those tokens are distributed among members, as well as produce proofs.\n\nTo withdraw tokens from the DataunionVault onto their own on-chain account, a member can query a proof from the Operator (or a Validator) and submit it to the smart contract by doing a normal Ethereum transaction (which requires ETH to pay for the gas). The smart contract verifies the proof and releases the tokens.\n\nThe Streamr API provides an easy way to query the Operator of each Data Union, although any Validator could be queried instead.\n\nThe Administrator is the owner of the smart contract as well as the Marketplace product.\n","section":"Data Unions","title":"Framework Roles"},"/docs/data-unions/auth-and-identity":{"id":"/docs/data-unions/auth-and-identity","content":"Data Unions Authentication and Identity\n\nMembers are identified by an Ethereum address, which is also their identity in the Streamr ecosystem, as Ethereum keys can be used to authenticate to the Streamr API as well as to sign data.\n\nEthereum key generation & management\n\nEthereum addresses have an associated private key, which must be kept safe, as it grants access to earned funds. Similarly, losing it means losing funds.\n\nEthereum private keys are just randomly generated 256 bits (32 bytes). They are usually displayed in form of 64 hexadecimal characters. You can use any securely random method of generating those keys, but here’s how to do it using the Streamr SDK for JavaScript and easily get the associated address too:\n\n\n\nwhich returns an object of this form:\n\n\n\nThe data-producing application should generate the keys when it is launched for the first time, and store the information locally. The private key should always stay on the device and it should never be sent over the internet.\n\nStoring the private key in encrypted form is recommended. One way to approach this is to encrypt it using a user-defined password. If the key is stored encrypted, the key needs to be decrypted when the application starts. The decrypted version should be kept in memory, as it is continuously needed for signing data.\n\nAuthenticating to the Streamr API\n\nThe Ethereum key created above can be used to authenticate to the Streamr API as well as to sign data. The private key is never sent over the internet; instead a challenge generated by the server is signed with the key, and this signature is used to authenticate the user. The mechanism is the same as when signing Ethereum transactions.\n\nThe easiest way to handle authentication is to use the Streamr SDKs. Here’s how to initialize a StreamrClient instance with a private key:\n\n\n\nAll requests made to the Streamr API via the client instance will now be automatically authenticated.\n","section":"Data Unions","title":"Auth & Identity"},"/docs/data-unions/create-and-monitor":{"id":"/docs/data-unions/create-and-monitor","content":"\n\nCreate and monitor Data Unions\n\nCreating a Data Union product\n\nCreating a Data Union product is most easily handled by using the Core app. See Creating a Data Union with Core for more details. Otherwise, it can be handled this way, but it is somewhat complicated.\n\nStart by deploying the DataunionVault smart contract. This is done by the Data Union admin who then becomes the owner of the contract as well.\n\n\n\nThe reason for the await is that deployDataunion returns when the DataunionVault deploy transaction is sent, but not yet mined. await contract.deployed() can be used to wait until mining is done, await contract.isReady() will wait until Data Union Server has noticed the contract and it’s actually ready to use through StreamrClient.\n\nA Data Union is identified by the address of its smart contract. After the smart contract has been created, the admin may choose to create an app secret (dataunionAddress is the smart contract address):\n\n\n\nIf the secret is not provided, it will be randomly generated. Note that the request must be authenticated using the Ethereum address of the Administrator of the Data Union, as described in Data Unions Auth & Identity.\n\nThe idea of an app secret is that it allows new members to join the Data Union without explicit approval from the Data Union admin, to streamline the on-ramp process.\n\nAfter the DataunionVault is set up, it’s time to create the actual product. This is most easily done using Streamr Core, but can also be done through the HTTP API.\n\nTo create a Data Union product instead of a regular one, add “type”: “dataunion” to the POST /products body.\n\nObserving Data Unions\n\nThe admin UI might need info on what’s going on in the Data Union\n\n\n\nThe returned stats object would look something like:\n\n\n\nOther relevant query functions:\n\n\n\nThe Streamr Core app also provides monitoring functions for Admins, showing subscriber numbers, total revenue, join requests and more. Create a Data Union with Core provides more information.\n","section":"Data Unions","title":"Create & Monitor"},"/docs/data-unions/join-and-withdraw":{"id":"/docs/data-unions/join-and-withdraw","content":"\n\nJoin and withdraw funds from Data Unions\n\nJoining Data Unions\n\nJoining the Data Union requires no transaction. The request must be authenticated with their Ethereum address, see Data Unions Auth & Identity.\n\n\n\nThe correct secret allows the member to join without manual approval from the Data Union administrator. If the secret is omitted, the admin must log in, find pending joinRequests in the Data Union admin view of the product, and approve the requests manually.\n\nSimilar to deployDataunion, you should wait until the member has joined before querying the member’s stats. The Data Union member can check their earnings (minus earlier withdrawals) in every Data Union:\n\n\n\nThe two numbers refer to the number of tokens actually withdrawable right now, and the total number of tokens that will be withdrawable after the Operator commits the earnings to the blockchain.\n\nAlso other interesting stats are available from the server:\n\n\n\nResponse would be something like:\n\n\n\nHere the earnings refer to “total lifetime earnings”. recordedEarnings are those that the Operator has committed to the smart contract, and frozenEarnings are those that are not yet available for withdraw (giving Validators time to validate new blocks). The difference of the two is  withdrawableEarnings, which doesn’t account for earlier withdrawals. The earnings figure is the most current number, and the difference of earnings and recordedEarnings are the newest revenue share that is still in the hand of the Operator, not yet committed.\n\nWithdrawing earnings\n\nWhen the member wants to withdraw their earnings, that happens through an Ethereum transaction to the smart contract:\n\n\n\nBefore withdrawing (or in the UI) it may be interesting to show also that the proof provided by the server has been verified from the DataunionVault contract in blockchain. This verification doesn’t require making a transaction, so it should be as fast as making \na couple HTTP calls:\n\n","section":"Data Unions","title":"Join & Withdraw"},"/docs/data-unions/ux-best-practices":{"id":"/docs/data-unions/ux-best-practices","content":"\n\nData Unions UX best practices\n\nIf you build a Data Unions based app, it needs to incorporate a simple crypto wallet, because your users will receive revenue in Streamr’s ERC-20 token, DATA. Below are a collection of features, suggestions and good usability practices you may want to include  in your app.\n\nBalance, available balance and cumulative earnings\n\nBecause users can withdraw tokens from their primary Ethereum address to another wallet, showing both current total and cumulative earnings is a good idea, so users can know their historical earnings as well as the current balance.\n\nDue to an anti-fraud measure, earnings are made available to the user with a 48hr time lag, so showing both a total balance and available balance is good practice. You may wish to offer a tooltip or other information to your users informing them of the reason for this lag.\n\n\n\nPrivate key handling\n\nBecause users may want to use another wallet for managing their funds, we strongly recommend offering private key access to all your users. Without this, they do not really have control of their own funds. When handling private keys, you need to allow users to access the private keys, but you should generally avoid displaying them on screen and keep them hidden from view.\n\nYou also need to inform your users about their responsibility for security, because it is entirely up to them. When building onboarding, good practice is to break users flow of just blindly clicking onwards through key information. Using disabled, conditional buttons that require explicit agreement from the user will not solve all your problems, but might help to prevent some users from ignoring your warnings.\n\n\n\nWallet addresses\n\nProviding clear access and copy functionality to the user's wallet address is always good practice, so they can watch it via other applications, and check it with external services. When pasting addresses into wallet address fields, informing the user that the contents of the field match the clipboard, and also show the ETH & ERC-20 tokens held by that address helps to reduce user stress and avoids the common practice of double-checking addresses by copy-pasting them as text.\n\n\n\nFiat currency display\n\nAllowing your users to switch currency views between DATA and a standard fiat currency like USD is a good idea. If they use your app over a long time they might get accustomed to thinking in DATA, but don’t assume they will.\n\n","section":"Data Unions","title":"UX Best Practices"},"/docs/tutorials/building-pub-sub":{"id":"/docs/tutorials/building-pub-sub","content":"\n\nBuilding a simple pub/sub system\n\nBefore proceeding with this tutorial, we assume you have got your API key or connected your Ethereum account and that you have also created your first stream.\n\nPublish to a stream\n\nThe easiest way to push data to a stream is to use the one of our SDKs, currently available in Javascript, Java and a community contributed version in Python. Client libraries for other languages are on the roadmap. Here is an example of publishing data to a stream using Streamr Javascript client.\n\n\n\nYou can also try it locally in your browser. Just open this JS Bin or GitHub Gist, and replace MY-STREAM-ID and MY-API-KEY with your stream ID and API key. Your browser will start producing data to your stream! If you were successful, you should see something like this in your stream editor preview.\n\n\n\nAdditionally, you can interact with the Streamr API using any HTTP library of your choice. You will find all the details in the API section, but here’s a brief rundown. You’ll be making a HTTP POST request to a URL, which contains your stream ID.\n\n\n\nThe body of the request will be your data payload in JSON. Add your API key to the HTTP headers as follows.\n\n\n\nThis is how a test request would look in the fabulous Postman app, with the URL and Authorization header set.\n\n\n\nAll the different authorization options are explained in the: API docs.\n\nSubscribe to data\n\nAlong with publishing data to a stream, this is best done with one of our SDKs. Here is the given example from the Streamr JavaScript client readme.\n\n","section":"Tutorials","title":"Simple pub/sub"},"/docs/tutorials/building-custom-canvas-module":{"id":"/docs/tutorials/building-custom-canvas-module","content":"\n\nBuilding a custom canvas module\n\nYou can easily extend Streamr by writing custom modules in the Java programming language. When a custom module is activated in a canvas, your code is executed as if the module were a part of the built-in machinery. As an alternative to custom code, you can also do abstraction, i.e. reuse existing canvases as modules.\n\nThe Java module is the module to use for custom code. Start by creating a new canvas or by opening an existing canvas in the editor. Then insert a JavaModule on the workspace, click on the Edit Code button, and a code editor will open in a resizable pop-up window. This is what you'll see:\n\n\n\nThe Java editor contains a code template that you need to fill in with the appropriate components. A custom module consists of inputs, parameters, outputs, an optional state, and a few specific methods. For the magic to happen, you'll need to specify the inputs and outputs and override the relevant methods.\n\nThe custom module's inputs correspond to the endpoints that receive incoming events. On the canvas, they are shown as small circles on the left-hand side of a module. The outputs correspond to the endpoints which send out computed values after module activation. The output endpoints are shown as small circles on the right-hand side of a module.\n\nInputs and outputs are defined in the beginning of the code template. To help you get started, there's two lines of commented code near the top.\n\n\n\nIf you uncomment those lines (as we've done above), you will get a module with one numerical input and one numerical output. If you want to see the result on the canvas, first click Apply, then Close.\n\n\n\nIn this example, the inputs belong to the TimeSeriesInput class and the outputs to the TimeSeriesOutput class. The first argument of an input or output constructor is always this, a reference to the current module. The second argument is there for the display name, i.e. a visual label for the endpoint. The variable name on the left-hand side of the assignment can be any valid variable name in Java.\n\nThe input and output variables must be unique within a module, but the display names are only labels with no deeper meaning. They don’t have to be unique, and an empty string is a valid name. A common convention is to make the display name equal to the variable name, but this is not a requirement.\n\nYou're not limited to numerical endpoints. These are the possible choices for an input event:\n\n\n\nThese are the possible choices for an output event:\n\n\n\nParameters are just inputs with default values. Because a parameter has a default value, there is no need for an incoming connection in the corresponding endpoint. If there is a connection, however, the custom module should take any parameter changes into account at run-time. Possible parameter types are listed below.\n\n\n\nThere’s no limitations on the number of incoming and outgoing connections. An an example, the following code would give you three inputs (one of which is a parameter) and two outputs:\n\n\n\nCustom module example\n\nFor the sake of illustration, let's create a new JavaModule. It will be similar to the built-in Sum, but instead of keeping a running sum, we'll calculate a running product of successive numerical events.\n\nWe'll start with the module inputs and outputs. We only need one numerical input and one output here, so we'll just uncomment the relevant lines:\n\n\n\nIn this example the module state is equal to the current value of the cumulative product. We'll call the state product and initialise it by the assignment product = 1 in the initialize method. As discussed, we also need to reset the module to its initial state on request. Let's just redo the initial assignment when the clearState method is called.\n\n\n\nAll that's left to do is to write the code to multiply the product by the new incoming event, save the state, and submit the output.\n\n\n\nThe code in a JavaModule is compiled and validated when you click the Apply button. Unless there's syntax errors in the code, the module is now ready to use. An easy way to generate an input is to connect the Clock module to a Count module, into a SendToStream module. This will input an incrementing number, for every clock tick, 1,2,3 etc. \n\nThis is what the output looks like with sample input data:\n\n","section":"Tutorials","title":"Custom modules"},"/docs/core/intro-to-core":{"id":"/docs/core/intro-to-core","content":"\n\nIntroduction to Core\n\nStreamr Core is the collection of open source applications developed and supported by Streamr that help you create, process, visualise and sell your real-time data. It allows you to create real-time data streams from your devices, build and test real-time processes with them, grab free or paid data streams from our Marketplace, or build your own products and sell them. It keeps track of all of your resources and earnings and makes it all available in one easy to use interface.\n\nMain user interface\n\nThe main interface to the Core app contains a number of elements, including user profile, view switcher, main view panel (list or tile), create button, filter and sort controls,  quick help button and the app menu. The main views in the app are Streams, Canvases, Dashboards, Products, Purchases and Transactions. There is also a Settings view accessed through the menu at top right (which shows the intials of your currently signed in account).\n\n\n\nCreate buttons\n\nFour of the main views offer create functions; Streams, Canvases, Dashboards and Products. Creating a stream or product will take you into the relevant create flow. For more on this, see Working with Streams or Working with Products. \n\nIn the case of canvases, these are built within the powerful Core visual programming editor. For more on this see Working with Canvases. Dashboards are also a unique case, because dashboards are basically view-only versions of the visualisation modules from canvases, so they have their own UI allowing you to add modules from your canvases and arrange the dashboard tiles sizes and layout. For more, see Working with Dashboards.\n\nUser profile\n\nYou can set or edit your profile image (useful in future iterations of the Marketplace), username, email address  and ethereum address by either going to the Settings menu (at upper right with your initials) or by clicking on your profile image.\n\nFilter and sort\n\nLive filter works to filter your current Core view by keyword. It works on either tile or list views. Just click the search icon to open the filter. Sort is a contextual function, offering different options depending on which Core view you are in.\n\n\n\nQuick help\n\nThe quick help menu gives you fast access to the these docs and the main Streamr Telegram group so give it a try if you need some quick answers.\n\n\n\nTile and List submenus\n\nBoth tile (canvases, dashboards, products, purchases) and list views (streams and transactions) offer per-item functions, accessed via a meatball menu from top right of tiles and right hand end of list views. Simply mouseover the item to see the menu.\n\n\n\nSharing resources in Core\n\nAll of the main resources types created and used within Core can be shared with others - streams, canvases and dashboards. In the case of canvases and dashboards, they can be shared from either their tile menu or from within their editing environments. Look for the share icon in the bottom toolbar. Streams can only be shared from the main Streams view via the submenu.\n\n\n\nWhen you share a resource, you can share it either privately or publicly. A private share means the link is only accessible to the users whose email address it has been shared with. A public share means anyone with the link — and importantly, anyone using the public API — can access your resource. \n\nTo share any resource, click share, then paste in the email address of the person you want to share it with, and click +. Select the access level you want to give them (view only, can edit or can share) and hit Save to confirm.\n\n","section":"Core","title":"Intro to Core"},"/docs/marketplace/introduction-marketplace":{"id":"/docs/marketplace/introduction-marketplace","content":"\n\nIntroduction to the Marketplace\n\nThe Marketplace is an application that enables users to buy and sell access to real-time data content on the Streamr Network. The Marketplace is filled with both paid and free products, offering data producers an opportunity to either monetise their data or make it freely available to everyone. Products have time-based subscription periods, and the currency used on the Marketplace is the DATA token.\n\n\n\nThe Marketplace is an open source project that builds on the Streamr Network and the Ethereum blockchain. Ethereum is used to store a registry of data products, coordinate access to them, and to provide a secure ledger of value transactions. Products are published to the Marketplace smart contract, and the contract allows data buyers to directly transact with sellers using the DATA token, removing all traditionally present middlemen and their fees. All of the data on the Marketplace is delivered peer-to-peer via the Streamr Network.\n\nGet data from the Marketplace\n\nMany products on the Marketplace are free. To access the streams of a free product, simply click the Add to my purchases on the product page. The product will appear immediately in the Purchases view of Core, and the streams will be available for your use both in the Streams view of Core and also directly within any canvases you create — just search for it’s name in the Module search panel. You don't need any DATA or Ether to purchase a free product.\n\n\n\nPurchasing paid products\n\nInteracting with paid products requires an Ethereum wallet address, and a small amount of Ether, in order to pay the gas fees required to purchase or publish the product. Getting access to a paid product requires a payment of DATA to the product owner.\n\n\n\nClicking the Purchase button initiates the purchase dialog which guides you through the contract transaction process. Gaining access to the streams inside the product happens automatically once the transaction has been completed which usually takes no longer than a few minutes. A dialog will pop up where you select the desired access period.\n\n\n\nThe marketplace uses smart contracts to withdraw tokens from your account. In order to allow the smart contract to execute the transfer, an allowance must be set to give permission to withdraw up to a certain amount of your tokens. This is a security measure for ERC20 tokens that means that the smart contract will only ever be able to transfer the amount of tokens that you approve.\n\n\n\nTo complete the the allowance step, confirm the transaction in Metamask. After setting the allowance, you will be asked to confirm the payment.\n\n\n\nFinally, confirm the transaction in Metamask to complete your purchase. While the transaction is being mined, you can either wait for it to complete or continue browsing the Marketplace. You will be notified after it has completed.\n\n\n\nNote that while you may purchase products with any Web3 wallet, the purchases will not be visible until you link the account to your profile.\n","section":"Marketplace","title":"Intro to the Marketplace"},"/docs/sdk/overview":{"id":"/docs/sdk/overview","content":"\n\nSoftware Development Kits\n\nThere are both official and unofficial Software Development Kits (SDKs) available for building software that interacts with the Streamr platform. Using an SDK provides an effortless and reliable way to use Streamr from your software projects. The SDKs take care of the small details required to interact with Streamr through intuitive API libraries, allowing a developer to focus on their task at hand.\n\nCurrently, we provide official SDKs for JavaScript (browser and Node.js) and Java. There is also a community-built SDK for Python in the works. The range of features each of these SDKs provide may vary, so be sure to check the documentation of the specific SDK for more information. If your programming language or software environment of choice does not have an SDK available, you can still interact with Streamr using our JSON-based HTTP API.\n\nIn addition to the SDKs, there is the Command Line Interface (CLI) tool for interacting with Streamr. The CLI tool is a thin wrapper around the Streamr Javascript Client, which does the heavy lifting, while the tool concentrates on CLI concerns: parsing and passing arguments, stdin/stdout, errors, and so forth.\n\n\n\nHow to contribute\n\nContribute to these docs, or any of our open source projects is warmly welcomed!\nPlease get in touch on Telegram, Reddit or email! Here is a guide on contributing to the Docs.\n","section":"SDKs","title":"Overview"},"/docs/sdk/javascript-sdk":{"id":"/docs/sdk/javascript-sdk","content":"\n\nJavaScript SDK\n\nThe JavaScript client library is available on npm to be integrated in your applications to interact with the Streamr API. The code and a comprehensive documentation are available on GitHub. Here is an example of how to create an authenticated client, publish and subscribe data using the JavaScript library.\n\n","section":"SDKs","title":"JavaScript"},"/docs/sdk/java-sdk":{"id":"/docs/sdk/java-sdk","content":"\n\nJava SDK\n\nThe Java client library is available on Maven Central which means it can be easily imported in your Java or Scala project. A comprehensive documentation and the code are available on GitHub. Here is an example of how to create an authenticated client, publish and subscribe data using the Java library.\n\n","section":"SDKs","title":"Java"},"/docs/sdk/python-sdk":{"id":"/docs/sdk/python-sdk","content":"\n\nPython SDK\n\nThe Python client library is available at this GitHub repo. If you are interested in contributing to this library, feel free to reach out via our community dev forum or submit directly a pull request.\n\n\n\nThis library is entirely community contributed and still work in progress. Core functionality like authentication via user API key, publish and subscribe data have been implemented. However, there are some other features available in our official libraries mentioned above that are still missing: Ethereum authentication, message verification, end-to-end encryption and historical data request.\n\n\n\nHere is an example of how to create an authenticated client, publish and subscribe data using the Python library.\n\n","section":"SDKs","title":"Python"},"/docs/api/api-overview":{"id":"/docs/api/api-overview","content":"\n\nAPI overview\n\nStreamr provides a set of APIs for easy integration with other systems. The APIs cover Authentication, data input, data output, and managing various resources within Streamr (such as streams, canvases, products, and dashboards).\n\nThere are RESTful HTTP endpoints that can be accessed using any HTTP library with ease. You can explore these endpoints using the API Explorer. You can expect:\n\nPredictable resource-oriented URL endpoints\n\nForm-encoded request bodies\n\nJSON-encoded responses\n\nStandard HTTP response codes, authentication, and verbs.\n\nThere are two APIs for requesting data from Streamr into external applications: the websocket-based streaming API, and the HTTP API. For efficiently publishing and subscribing to data in real-time, using the websocket API is recommended.\n\nThe streaming API can be used to control external applications using real-time events from Streamr. For example, you could push real-time stock prices into a mobile app, or update player positions in a multiplayer game. Or you could implement a thermostat by controlling warming or cooling based on a temperature measurement. The streaming API pushes new events to subscribed clients immediately when they become available.\n\nUsing a client library is recommended for most tasks and integrations:\n\n\n\nIf you'd like to contribute a client library and get it listed here, check out our section on contributing.\n\nAPI behaviour\n\nThe body of the request should be a JSON object, encoded in UTF-8, containing the key-value pairs representing your data.\n\nResponse codes\n\n\n\nData output over websocket\n\nThe websocket protocol is easiest to use with one of the available client libraries. If there isn't a client library available for your language, you can dive into the details of the websocket protocol.\n","section":"API","title":"API overview"},"/docs/api/authentication":{"id":"/docs/api/authentication","content":"Authentication\n\nA session token is required to make requests to the REST API endpoints or over the websocket protocol. You can obtain a session token by authenticating with either of these three methods:\n\nSigning a cryptographic challenge using an Ethereum private key\n\nUsing a permanent secret API key\n\nUsing a username and a password\n\nOnce you get a session token using one of the above methods, see the section on using it.\n\n\n\nAuthenticating with Ethereum\n\nYou can use an Ethereum private key to authenticate by signing a challenge with it and providing your Ethereum public address for verification.\n\nUse the POST endpoint at /api/v1/login/challenge/YOUR-PUBLIC-ADDRESS to generate a random text called a challenge, which looks like the following: \n\n\n\nTo authenticate, you must provide a response before the challenge expires. You can do it with a POST to /api/v1/login/response. It must contain the challenge, the signature and the Ethereum address in the following format:\n\n\n\nThe signature must follow the convention described here. The secp256k1 ECDSA algorithm is applied on the keccak256 hash of a string derived from the challenge text:\n\nsign(keccak256(\"\\\\x19Ethereum Signed Message:\\\\n\" + len(challengeText) + challengeText)))\n\nIf the signature is correct, you will receive a session token.\n\n\n\nAuthenticating with an API key\n\nAny number of API keys can be attached to your user. You can manage your API keys on your profile page.\n\nWhen reading from or writing to Streams, you can use a Stream-specific anonymous key instead of your user key to avoid exposing it. Anonymous keys can be managed on the details page of a Stream.\n\nTo obtain a session token using an API key, send a POST request to the /api/v1/login/apikey endpoint with a JSON body like the one below:\n\n\n\nAuthenticating with a username and a password\n\nYou can manage your username and password from your profile page. To obtain a session token using your username and your password, send them as a POST request to the /api/v1/login/password endpoint with a JSON body in the following format:\n\n\n\nUsing the session token\n\nBy using one of the above authentication methods, you will obtain a session token response in the following format: \n\n\n\nYou can now use this session token to make authenticated requests by including an Authorization header on every HTTP request with content as follows:\n\nAuthorization: Bearer YOUR-SESSION-TOKEN\n\nThe session token's expiration will be reset on every request to prevent you from getting logged out while using the API. If the token expires, you can obtain a new one exactly as before.\n","section":"API","title":"Authentication"},"/docs/api/using-streams-via-api":{"id":"/docs/api/using-streams-via-api","content":"\n\nWork with streams via API\n\nWhile the Core UI can do just about everything you'd want to do with streams, sometimes the using the API directly is preferred.\n\nData output over HTTP\n\nEvents in streams can be queried via HTTP. Example using curl:\n\n\n\nThe following endpoint would return the 5 most recent messages in a stream (or to be more precise, the default partition 0 of a stream):\n\n\n\nThe HTTP API covers session management, data input, data output, and managing Streamr resources such as Canvases, Streams, and Dashboards. The endpoints allow you to list, create, read, update and delete the resources, as well as execute resource-specific actions such as start and stop Canvases. You best way to view all of streams endpoints is in the API explorer.\n","section":"API","title":"Work with streams via API"}}