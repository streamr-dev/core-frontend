import ScrollableAnchor from 'react-scrollable-anchor'
import cx from 'classnames'
import { Link } from 'react-router-dom'

import CodeSnippet from '$shared/components/CodeSnippet'
import { CreateStreamButton } from '$userpages/components/StreamPage/List'
import { formatPath } from '$shared/utils/url'
import links from '$shared/../links'

import CreateStreamDialog from './images/visualEditor/streams/createStreamDialog.png'
import EditStreamDetails from './images/visualEditor/streams/editStreamDetails.png'
import MyFirstStreamViewPage from './images/visualEditor/streams/myFirstStreamViewPage.png'
import ConfigureMyFirstStream from './images/visualEditor/streams/configureMyFirstStream.png'
import CSVConfig from './images/visualEditor/streams/CSVConfig.png'
import DropCSVHere from './images/visualEditor/streams/dropCSVHere.png'
import SampleTwitterData from './images/visualEditor/streams/sampleTwitterData.png'
import TwitterStreamView from './images/visualEditor/streams/twitterStreamView.png'
import SubscribingToStream from './images/visualEditor/streams/subscribingToStream.png'

import RoundToStep from './images/visualEditor/modules/roundToStep.png'
import TablePopup from './images/visualEditor/modules/tablePopup.png'
import TableModuleOptions from './images/visualEditor/modules/tableModuleOptions.png'
import AndModule from './images/visualEditor/modules/andModule.png'
import InitialValueDialog from './images/visualEditor/modules/initialValueDialog.png'

import MyFirstStreamOnCanvas from './images/visualEditor/canvases/myFirstStreamOnCanvas.png'
import BlankCanvasWithArrow from './images/visualEditor/canvases/blankCanvasWithArrow.png'
import HideControlBarButton from './images/visualEditor/canvases/hideControlBarButton.png'
import NewServiceWithArrow from './images/visualEditor/canvases/newServiceWithArrow.png'
import OpenServiceWithArrow from './images/visualEditor/canvases/openServiceWithArrow.png'
import SaveServiceWithArrow from './images/visualEditor/canvases/saveServiceWithArrow.png'
import AddTwitterStream from './images/visualEditor/canvases/addTwitterStream.png'
import ModuleBrowser from './images/visualEditor/canvases/moduleBrowser.png'
import ConnectingStreamToModule from './images/visualEditor/canvases/connectingStreamToModule.png'
import StartHistoricalRun from './images/visualEditor/canvases/startHistoricalRun.png'
import PlaybackOptions from './images/visualEditor/canvases/playbackOptions.png'
import StartRealtimeRun from './images/visualEditor/canvases/startRealtimeRun.png'
import StopRealtimeRun from './images/visualEditor/canvases/stopRealtimeRun.png'

import ModuleOnCanvas from './images/visualEditor/extensions/moduleOnCanvas.png'
import ModuleExampleOnCanvas from './images/visualEditor/extensions/moduleExampleOnCanvas.png'

import {
  JavaModule,
  InputsAndOutputs,
  InputsAndOutputsExample,
  JavaModuleDeclarations,
  DefiningInputsAndOutputs,
  ClearState,
  IncomingEvent 
} from './code/visualEditor.js'

import docsStyles from '$docs/components/DocsLayout/docsLayout.pcss'
import localStyles from '$docs/components/VisualEditorPage/visualEditorPage.pcss'

# Visual Editor

<ScrollableAnchor id="introduction"><div>

## Introduction

Streamr is a cloud-based platform for creating and managing microservices that process events in real-time data streams.  It abstracts the complexity of the underlying stream processing technology and provides a user-friendly front end, saving you time and money along the way.

There’s many things you can do with Streamr. For instance, you’ll be able to monitor real-time industrial processes, ingest and visualise sensory data from IoT devices, calculate streaming analytics, follow and act on high-frequency financial market data, take automatic action when abnormal patterns are detected, extract information from social media traffic, track customer payments, orders, or deliveries, and automate various business processes. If you have a source of real-time data and you want to do useful things with it, Streamr is for you.

Streamr makes it easy to set up digital microservices for handling real-time data. In Streamr, such microservices are called **canvases**. There is a browser-based visual programming interface where you can quickly put a canvas together using modular building blocks. You can also code all or part of a canvas in Java if that's what you prefer. Streamr supports abstraction, and you'll be able to re-use  code and custom modules as your code base grows.

The platform is flexible and fast. Event streams can contain any kind of data in any format. The technology can handle millions of events per second and it copes with a practically unlimited number of live services in parallel. The underlying software runs (by default) in the cloud. Additional computing capacity is deployed automatically when required.

The development environment includes a playback mode where you can simulate the processing logic over days, weeks, months, or years of data over billions of events if needed. When you’re happy, you can launch your canvas live at a click of a button. In the live mode, a Streamr canvas listens to real-time events, processes the data, and takes the required action.

The secret sauce of Streamr is the hidden technology which makes creating and managing real-time microservices easy. Apart from the browser-based user interface and visual programming tools, Streamr takes care of the data flow, event propagation, message queues, load balancing, and other technical issues under the hood. It also manages your live canvases and stores the full event history on your behalf.

### Data live in streams

All real-time data in Streamr is stored in [streams](#streams). A stream is essentially a timestamped sequence of events. Each event may contain more than one field. You can create and work on dozens, hundreds, or thousands of streams. A stream is persistent, identified by a unique ID, and stored in the cloud.

Any kind of real-time data can be stored in a stream. The incoming data may consist of sensory readings of speed, geolocation, orientation, ambient temperature, humidity, and so forth. Or the data may contain social media messages, stock market events, mobile ad impressions, and so on.

There is no limit on the kind, format, or quantity of the data you feed into Streamr. The data may originate from machines on the factory floor, sensors in a smart city, in-house databases or systems, or from commercial streaming data feeds.

There are a few different ways to get data into a stream. Streamr has a simple HTTP API which allows you to push events in JSON format to a stream from any programming language. You can also batch load historical events using Streamr’s CSV loader. If the events originate in a database or in a third-party data feed, talk to us. We'll figure out what kind of adapter is needed.

Streams implement a publish-subscribe paradigm, or pub/sub for short. A stream can receive data from many sources (or publishers), and there can be several listeners who subscribe to a stream. There are several variations on the possible pub/sub topologies, such as many-to-one, one-to-many, or many-to-many.  Streamr supports all of these.

### Turn the data into action

You can build any kind of automatic real-time functionality with Streamr [canvases](#canvases) (i.e. microservices). We make it easy to create and manage your digital workforce. There is an extensive collection of built-in [modules](#modules) as a source of building blocks. You can abstract modules and re-use them later, and you can code custom modules in Java.

Here's a few examples of specific things you can do.

- Refine real-time data by routing it through different modules. The built-in module library includes arithmetic and logical operations. There are also functions for smoothing, sampling, and aggregating streaming data.
- Chain modules together so that the output from one operation flows as an input to another. This is one way to build arbitrarily complex streaming analytics. If you want to keep things tidy, you can encapsulate the complexity and reuse the abstracted result.
- Visualise the data by directing it to a charting module. The chart shows the new data in real-time as new events arrive or streaming analytics are computed.
- Communicate with the outside world by sending text messages or emails when specific conditions are satisfied. You can embed real-time data, refined data, or natural language in the messages.
- Save refined data in another stream. When you do that, the saved data are instantly accessible as new events. The refined data can be streamed from the platform to external data consumers.
- Post events in HTTP format to external RESTful services. There's a wide range of popular and useful services out there, and you can use any one of them easily from Streamr. 
- Control external devices. As an example, you can override manual controls and make a remotely operated drone return to base when it's about to go out of range or running low on battery. Because the control interface is likely to be machine specific, this is one case where you'd be looking at coding a custom module in Java.

Although we sometimes find it hard to admit, there's life outside Streamr. We're not jealous, though, and indeed make it easy to spread the word. Here's what you can do:

- Create dashboards which display live data sourced from Streamr.
- Embed live visualisation elements in external web pages by inserting a single line of HTML code.
- Subscribe to a stream in external web pages and applications. You'll receive every event as soon as it’s available.

### Who is Streamr for?

The short answer is that Streamr is for anyone who wants to create new, interesting, and valuable things on top of real-time data, and wants to do it quickly and with minimum fuss.

Streamr offers value to many different user groups. Domain experts and R&D teams can use Streamr for quick prototyping and exploration before building a production level offering. Streamr gives students, hobbyists, and enthusiasts a fully functional but affordable event processing platform in the cloud.

For corporations and organisations, Streamr is a tool for sharing and teamwork. The real-time data that you collect may be a treasure trove for innovation, but nothing will happen unless the data is available and usable. Streamr can be the spark which makes innovation happen: It brings the data into the open, and makes it easy to experiment with ideas for new products and services.

<hr />
</div></ScrollableAnchor>
<ScrollableAnchor id="streams"><div>

# Streams

All data in Streamr is stored in a stream. A stream is simply a sequence of events in time. You can add new data to the end of a stream, and a stream will give the data back to you in the correct order. 

You can store different kinds of data in the same stream.  The data may be numeric, but it can equally well consist of strings, collections of elementary data types, or associative arrays. Each event contains at least one data field, but you can have as many fields per event as required. The data are persistent and stored in the cloud.

The raison d'être for a stream is its capability to provide real-time inputs to Streamr [canvases](#canvases), and act as a recipient of real-time output from such canvases. You can also use a stream as a pub/sub-device, push data into it, and subscribe to the data elsewhere. 

In this chapter, we’ll show stream examples and describe the built-in data types. We'll then discuss how to do the following:

- Create or delete a stream.
- Edit stream details.
- Upload historical data.
- Push events to a stream.
- Subscribe to a stream.

### Stream examples

Here’s an example of what a small part of a stream could look like. Each row shows one event, and the columns correspond to the timestamp followed by two data fields: A measurement of the operating temperature and the number of rotations per minute (RPM).

Timestamp               | Temperature | RPM
:---------------------- |:------------|:----
2016-02-01 11:30:01.012 | 312.56      | 3550
2016-02-01 11:30:02.239 | 312.49      | 3549
2016-02-01 11:30:04.105 | 312.42      | 3543
2016-02-01 11:30:08.122 | 313.21      | 3565
2016-02-01 11:30:11.882 | 317.45      | 3602
...                     |             |

As an example of a more complicated event, here’s a data point in a stock market stream.

<CodeSnippet language='json' wrapLines>{
`{
    "Symbol": "PFFT",
    "EventType": 1,
    "OrderId": 6454321,
    "Direction": "Up",
    "Trade": {"Price": 118.55, "Size": 100},
    "Ask": [
            {"Price": 118.6, "Size": 22500},
            {"Price": 118.65, "Size": 18000},
            {"Price": 118.7, "Size": 13000},
            {"Price": 118.8, "Size": 8000},
            {"Price": 119, "Size": 45000}
            ],
    "Bid": [
            {"Price": 118.5, "Size": 16500},
            {"Price": 118.45, "Size": 11000},
            {"Price": 118.4, "Size": 14200},
            {"Price": 118.2, "Size": 19000},
            {"Price": 118, "Size": 50000}
           ]
}`
}</CodeSnippet>

### Working with streams

You can create new streams either manually in the user interface or by using the <Link to={formatPath(links.docs.api)}>API</Link>. Each stream is identified by a unique ID. There’s no technical limit on the total number of streams.

If you want to create a stream manually, go to the <kbd>Streams</kbd> tab.  There’s a button which looks like this:

<div className={docsStyles.centered}>
  <CreateStreamButton />
</div>

A click takes you to a dialog where you’ll fill in the stream name and an optional description.

<div className={cx(docsStyles.centered, localStyles.createStreamDialog)}>
  <img src={CreateStreamDialog} />
</div>

A new stream is created when you click the **Next** button.  You’ll be shown a stream view that includes the stream details (the name and description), API credentials, configured fields (there won’t be any yet), and a summary of stream history (there will be none yet). 


<div className={docsStyles.centered}>
  <img src={MyFirstStreamViewPage} />
</div>

If you want to delete a stream, first click on its name, and then click on the **Delete stream** button. You’ll be asked to confirm that you really want to go ahead. You can also delete a stream using the <Link to={formatPath(links.docs.api)}>API</Link>.

In order to read the stream from external applications using the HTTP API, you need to create <strong>Anonymous keys</strong> not bound to specific Streamr user. This way you can grant (and revoke) external applications and users the access to your stream. Choose a descriptive <strong>Key name</strong> (e.g. name of the external application, client, or customer you want to grant the access), select <strong>can read</strong> from the dropdown, and hit <strong>+</strong>. Copy the key to clipboard by clicking the copy icon. Revoke the access by clicking the trash bin icon.

In order to push data into the stream from external sources using the HTTP API, or let external application push data into your data stream, you need to create an anonymous key with <i>write permissions</i>. Choose a descriptive <strong>Key name</strong> (e.g. name of the external data producer), select <strong>can write</strong> from the dropdown, and hit <strong>+</strong>. For details on how to implement the data sender, see <a href="#pushing-events-section">Pushing events to a stream</a>.

<div className={docsStyles.centered}>
  <img src={EditStreamDetails} />
</div>

If you want to edit stream details, you need to be in the <kbd>Streams</kbd> tab. Click on the stream name, and then click on the **Edit info** button. You'll see a dialog where you can rename a stream or modify its description.

### Edit stream details

The stream view also includes the option of configuring the data fields.  If you’ll load real-time data through the API, you’ll need to configure the data fields now.  If you’ll first load historical data from a text file, you can skip this step.  We’ll be in many cases able to to autodetect the field types from the input.

If you want to configure the data fields manually, the Configure Fields button takes you to a setup dialog.  To add a new data field, click on the **+ Add Field** button, give the field a name and change the field type as appropriate.  Remember to save the changes when done.

<div className={docsStyles.centered}>
  <img src={ConfigureMyFirstStream} />
</div>

You can also rename a stream, edit the description, add data fields and specify the field types using the <Link to={formatPath(links.docs.api)}>API</Link>.

### Uploading historical data

Batches of historical events can be loaded into a stream by importing a CSV file. You need to be in the <kbd>Streams</kbd> tab to do this. When you click on an existing stream, you’ll see a History panel and a data drop.  This is where you can drop a text file with a batch of event history.

<div className={docsStyles.centered}>
  <img src={DropCSVHere} />
</div>

You can also pick a local file for import by manually by clicking on the data drop.  Either way, Streamr will parse the given CSV file and load the events into the stream.

As to the format, the CSV file should have the column names on the first row, and use either a comma or a semicolon as the separator.  One of the columns should be a timestamp, where the recommended format is either `"yyyy-MM-dd HH:mm:ss"` or `"yyyy-MM-dd HH:mm:ss.SSS”`.  Timestamps must be in a chronological order with earlier events first and the recent events last.

If Streamr cannot find the event timestamps or doesn’t understand the timestamp format, you will see a dialog box like the one below.  This is where you can manually select the timestamp column and specify the format.

<div className={docsStyles.centered}>
  <img src={CSVConfig} />
</div>

We’ll do our best to make sense of the data columns in the CSV file, but the autodetection of field types will not always work.  For instance, a column of telephone numbers may be interpreted as numbers even if you’d probably want to import them as strings.  In such cases, you’ll need to configure the fields manually as shown above.  Mind you, making changes that don’t make sense will cause runtime exceptions due to incompatible data types.

Let’s go ahead and upload some sample data.  We’ll import a text file which contains a collection of recent tweets found with the keywords `“augmented intelligence”`.  This is what the sample tweet data looks like, as at the time of writing, with only four columns and a subset of rows shown:

<div className={docsStyles.centered}>
  <img src={SampleTwitterData} />
</div>

The data file is called `“SampleTweets.csv”`, and you can download the latest version to your desktop from this [link](“SampleTweets.csv”) **TODO FIX THIS**. 

If you drag the the sample file to the data drop, the events are uploaded to the stream.  Once the process is complete, the stream view is updated to show the extent of the archived history. 

<div className={docsStyles.centered}>
  <img src={TwitterStreamView} />
</div>

### Built-in data types

There’s a number of built-in data types that can be used in a stream. These are the following:

- **Number**: A numeric data type internally stored as a double precision (64-bit) float.

- **Boolean**: A logical data type with two possible values, True and False.

- **String**: A sequence of zero or more alphabetical characters.

- **Map**: A collection of key-value pairs.

- **List**: An ordered collection of zero or more elements.

Map is the same as a dictionary or an associative array found in a number of programming languages. Each key is a string, and the value can be of any built-in data type (even a Map again).

Data types can be freely mixed in one event. And you can freely add new fields to an existing stream; you don’t have to know what fields you might eventually need. A single event can be of any size within reason, and a stream can grow indefinitely when extended by new events. 

There is no theoretical limitation as to the format or type of data in Streamr. Anything which can be expressed in digital form is fair game. It is perfectly possible to create streams which contain digital images, streaming video, or other domain-specific data. If your use case takes you beyond the built-in data types, come and talk to us about what you have in mind.

<div id="pushing-events-section" />

### Pushing events to a stream

Streamr has a simple <Link to={formatPath(links.docs.api)}>API</Link> which allows you to push events in JSON format to a stream. The events are immediately delivered to subscribers of the stream, including canvases which use the stream as well as any external applications listening to the stream via the API.

You can push events to a stream from any programming language, and there are also convenient client libraries for some languages. For details and usage examples please see the <Link to={formatPath(links.docs.api)}>API Documentation</Link>.

Instead of using the API, you can produce events to streams on a canvas using the SendToStream module. This is highly useful when you refine data using a canvas and want to produce the results to another stream.

## Subscribing to a stream

Subscribing to streams in order to use the data on canvases is trivially easy: just add the stream to a canvas. As a simple taster of how this works, here's a stream of social media messages connected to a **Table** module.

<div className={docsStyles.centered}>
  <img src={SubscribingToStream} />
</div>

You can also subscribe to a stream in any external application via our [API](https://api-explorer.streamr.com).

<hr />
</div></ScrollableAnchor>
<ScrollableAnchor id="modules"><div>

## Modules

Modules process the data emanating from event streams. All Streamr [canvases](#canvases) consist of streams (they provide the data) and modules (they process the data).

A module is close akin to what you'd call a function, subroutine, procedure, or a method in various programming languages. In Streamr, modules are specialised computation units for handling streaming real-time data. A module processes its inputs as soon as it is activated by the arrival of a new event. The module may have one or more outputs, or it may take care of some side effect instead. 

There’s no limitations on the number of module instances, i.e. on the number of of times the same module is used in a canvas or in different canvases.  Different instances of the same module are independent of each other (unless one feeds data to the other).

A module has an internal state, and it can and typically will update that state when it is executed. How this is done depends on the particular module. The statefulness is an important feature and one the key ingredients in real-time stream processing.

### Built-in modules

There's a number of built-in modules on the Streamr platform. They fall into the following categories:

- Visualisation.
- Filtering, sampling and aggregation.
- Stream operations.
- Time series operations.
- Arithmetics.
- Statistics.
- Logical operators.
- Time & date.
- Text processing.
- Utility modules.
- Extensions and abstraction.
- Connectivity.

For details on different modules, either see the individual module help in the Streamr editor or have a look at the ** TODO: module reference **.

### Inputs, outputs, and parameters

A module can have inputs, outputs, and parameters.  Whilst a module does not need to have any inputs or outputs, useful modules will typically allow for either incoming or outgoing data (and usually both).

When placed on a canvas, the inputs are shown as circular connectors along the left-hand side of the module.  The outputs are shown as connectors along the right-hand side.

<div className={docsStyles.centered}>
  <img src={RoundToStep} />
</div>

Many modules have parameters which control their operation.  Module parameters can be hardcoded, but their values are typically not immutable.  If a parameter can be modified at run-time, there is an associated parameter input at the left-hand edge of the module.

As an example, the **RoundToStep** module has three inputs, two parameters, and one output.  The first two inputs correspond to the module’s parameters, i.e. precision and mode.  The last input is a numeric value which will be rounded with the specified precision in the direction specified by the mode.  The module output is equal to the rounded input.

Inputs, outputs, and parameters can be renamed.  If you move the mouse on top of a name, a click brings up a pop-up menu which allows you to give the endpoint or parameter a new display name.  Renaming has no bearing on functionality.

<div className={docsStyles.centered}>
  <img src={TablePopup} />
</div>

You’ll see a number of small icons next to the endpoints when you hover on top of a module.  These icons correspond to additional controls which are relevant to module activation.  We’ll have more to say on this below, but let’s first discuss the data flow between modules.

### Module options

Modules can have options which control their behaviour or appearance.  Options apply to a specific instance of the module, and they can only be changed through the editor.

<div className={docsStyles.centered}>
  <img src={TableModuleOptions} />
</div>

As an example, **Table** only shows one data column by default.  If you hover on top of the module and click on the wrench icon, you’ll see the available options in a pop-up window.  Change the number of inputs to 3, press **OK**, and you’ll get a **Table** with three columns.

### Activation

A module processes its inputs as soon as it is activated.  This happens when the following conditions are both satisfied.
1. Every input has a value.
2. An event arrives at one of the driving inputs.

<div className={docsStyles.centered}>
  <img src={AndModule} />
</div>

At least one endpoint in any module is designated as a driving input by default.  To change the default settings, hover on top of a module and you’ll see a number of additional controls.  You can make any input a driver by clicking on the associated **DR** icon (a toggle button) next to an input connector.  A module with no driving inputs will never activate.

As mentioned, every input must a have a value before anything happens.  The input values typically arrive either as events from a stream, or from the output endpoints in some other module(s).  If the input corresponds to a numeric value or a string, you can specify an explicit initial value.  If you click on a **IV** icon next to an input, you’ll see an initial value dialog.

<div className={docsStyles.centered}>
  <img src={InitialValueDialog} />
</div>

### Feedback loops

By default, feedback loops are not allowed.  This is because feedback and event processing do not always mix well (just think back to the last time you placed a live microphone too close to a loudspeaker).

If you really want to create a feedback loop, we won’t stop you.  If you click on the **FB** icon next to an input connector, the endpoint will now accept events that originate from the same module.  If feedback is disabled, the endpoint won’t accept feedback events either directly or indirectly (i.e. not even when recycled through other modules).

Lastly, note the **NR** icon next to each output connector.  This is a non-repeat button, and if it’s on, the module suppresses any output that would be an exact replica of the last outgoing event.  This covers the use case where you’re only interested in events that represent something new.

<hr />
</div></ScrollableAnchor>
<ScrollableAnchor id="canvases"><div>

## Canvases

A Streamr canvas is a microservice which consumes and acts upon real-time data.  A canvas contains one or more [streams](#streams) (these provide the data) and one or more [modules](#modules) (these do the processing). Streams and modules are connected in the configuration that you'll design.  The connections determine how the data flows through the canvas.

There's a wide variety of built-in modules in Streamr.  Some of those perform basic arithmetic and logical operations, filtering, sampling, aggregation, and so on. Others transform the data in some fashion and feed it to the next stage.  Yet other modules interact with the outside world and with external systems.

Computation in Streamr is entirely event-based. Any module will execute immediately when activated by incoming events. When new events arrive in the input stream, the data automatically flows through the canvas. This inherently asynchronous process allows for fast and continuous in-memory processing of large volumes of real-time data.

As a simple example, here's a canvas consisting of one stream and a chart module connected together.  When you run the microservice, the events flow from the stream to the chart, and the chart draws the data points as they arrive.

<div className={docsStyles.centered}>
  <img src={MyFirstStreamOnCanvas} />
</div>

You can run a canvas in either historical or real-time mode.

- In the *historical mode*, running a canvas is a playback of what would have happened in the past. A playback can be extremely useful when you’re testing, refining, or demonstrating the functionality of a canvas.
- The *real-time mode* is used in production where you want to react to events as they arrive. There's no need to modify the canvas in order to run it live.  One click is all it takes to activate the microservice and start consuming real-time data.

In this chapter, we’ll show how to do the following: 

- Use the canvas editor.
- Subscribe to streams.
- Build canvases.
- Run a historical playback.
- Start or stop a live canvas.
- Reuse canvases as modules.

## Using the editor

You create a new service or modify an existing service by using the Streamr editor. When you log in to Streamr, the editor with a blank workspace is what you’ll first see. The editor is always accessible by clicking on the **Editor** tab.

<div className={docsStyles.centered}>
  <img src={BlankCanvasWithArrow} />
</div>

As a space-saving hint, note the small icon in the top left corner, just left of the Streamr log.  Click on the icon to hide the editor sidebar.

<div className={docsStyles.centered}>
  <img src={HideControlBarButton} />
</div>

Click again, and the sidebar reappears. 

There are three things you can do in the editor:

- If you want to create a new canvas, click on the left-most icon in the top row of the control sidebar. This is where you are taken by default.

<div className={docsStyles.centered}>
  <img src={NewServiceWithArrow} />
</div>

- If you want to view or modify an existing canvas, click on the icon in the middle.

<div className={docsStyles.centered}>
  <img src={OpenServiceWithArrow} />
</div>

- If you want to save the canvas, click on the icon on the right.

<div className={docsStyles.centered}>
  <img src={SaveServiceWithArrow} />
</div>

The editor is your workspace for building or modifying a canvas and the event processing logic. You can test the canvas with a playback of historical data and launch it live when you're ready to go.

There's a natural iterative workflow where you first build a perhaps rudimentary version of a canvas, test it with historical data where possible, refine the design based on the test findings, and repeat until you're happy.

You can also create a service programmatically by using the <g:link controller="help" action="api">canvas API</g:link>. 

### Building a canvas

<div className={docsStyles.centered}>
  <img src={AddTwitterStream} />
</div>

When you want to build a canvas, you’ll typically start by adding one or more data streams to the editor workspace.  You’ll then create the processing logic by adding modules to the canvas and connecting the streams and modules together. You can do all this interactively by dragging and dropping streams and modules from the sidebar to the workspace and by drawing connections between them.

When you place a stream on the canvas, you effectively subscribe to a real-time data source. To find a stream, just start typing its name in a text box labeled **Add Stream / Module** (see the editor sidebar).  We’ll autocomplete the stream name as you type. Either click on the highlighted name or press <kbd>Enter</kbd> to select the  stream. Real-time events are now available at the output endpoints.

<div className={docsStyles.centered}>
  <img src={ModuleBrowser} />
</div>

There are [modules](#streams) for streaming analytics, visualisation, communication, and many other purposes. You'll find all the built-in components in the **Module Browser** which is organised by category.

If you already know the name of the module you need, type its name (with autocomplete) in the search box (**Add Stream / Module**).  If there’s several partial matches, you can select the one you want from the popup window. As a shortcut, you can press <kbd>Enter</kbd> to select the first match. You can also drill down in the module browser to the module you want. Then either highlight the module with a mouse click and then click on the **Add Module** button. Or just drag a module from the browser to the canvas.

You can move modules around on the workspace as you wish, but the placement of a module has no impact on functionality.  For clarity, you may want to design the canvas so that module placement reflects the data flow from the input streams through the modules.

A data flow between two modules — or a data flow between a stream and a module — is created by drawing a connection from an outgoing endpoint to an incoming endpoint with the mouse (or other pointing device).  You can create as many outgoing connections as you wish. You can only have one incoming connection per an endpoint.

<div className={docsStyles.centered}>
  <img src={ConnectingStreamToModule} />
</div>

You can only connect endpoints with compatible data types. For instance, you cannot create a connection which feeds string events to an endpoint where numerical events are expected.

However, any non-boolean events are automatically converted to logical truth values if a boolean input is required. Numbers exactly equal to zero are deemed to be False, and any non-zero values True. An empty string ("") is False, a non-empty string is True. An empty list is False, a non-empty list is True. An empty Map is False, and anything else is True.

All connections are unidirectional, i.e. the data always flows from an output to one or more inputs in one direction only.  The modules form a directed graph. Feedback loops are discouraged, but you can create them if you really want.

When you view a canvas, the direction of a data connection is indicated by an arrow.  You can alter the endpoint of an existing connection by dragging it to another input endpoint.  If you instead drop the endpoint in an empty area in the workspace, the connection is cleared.  A mouse click on top of a module brings up an pop-up menu where you can choose to disconnect all incoming connections to the module.

The topology of a service can be arbitrarily complex. You can of course design a simple sequential work flow, and in many cases it will be perfectly adequate. In other cases the flow of data may involve merging data pathways, branches and even loops. Go ahead, be adventurous, but also bear in mind Streamr's abstraction capabilities. Reusing existing canvases will help you manage the development process and keep things tidy and neat.

### Running a playback

<div className={docsStyles.centered}>
  <img src={StartHistoricalRun} />
</div>

The historical playback facility is a great way to test a canvas.  In a playback, a canvas consumes historical events stored in the subscribed streams. A playback is a simulation of what would have happened in the past.

By default, any canvas is in a historical mode. Provided that the streams used by the canvas contain some historical data, you can run a playback at any time that the canvas is open in the editor.

You specify the time period (the start date and the end date) for a historical playback period in the editor sidebar.  The playback starts when you press the **Run** button.

By default, playback events are processed sequentially but at a much faster pace compared to the actual history. You can easily change the playback speed for the historical run. Click on the Options icon, and a pop-up menu shows the available choices.

<div className={docsStyles.centered}>
  <img src={PlaybackOptions} />
</div>

### Running live services

<div className={docsStyles.centered}>
  <img src={StartRealtimeRun} />
</div>

When a canvas is live, it will listen to real-time events arriving in the subscribed streams, and process them as soon as they're available. You can think of live canvas as digital agents who'll react to new events in real-time on your behalf.

A canvas does not need to be modified in any way when you want to take it live. It will work as is, in the same exact form as used in historical testing. Simply switch to the realtime tab, press the **Start** button, and voilà!

<div className={docsStyles.centered}>
  <img src={StopRealtimeRun} />
</div>

A live canvas keeps running until you explictly tell it to stop. When you stop a canvas, its internal state is saved on the disk. If you later restart the microservice, it will gracefully resume from the point where it stopped. It will not, however, process any events that occurred when it was not running.

You'll see all of your canvases (and their state) in the Canvases tab. Click on a canvas to open it in the editor. You can then stop it (if it is live) or launch it live (if it is stopped).

### Reusing canvases as modules

You can easily reuse a canvas as a component of another canvas. This is done via *abstraction*, where you encapsulate a canvas as a module. You can then use the new module when you build additional microservices.

To create an abstraction, you'll need to expose — or export — inputs and outputs. The exported endpoints will show up as endpoints of the abstracted canvas.

<hr />
</div></ScrollableAnchor>
<ScrollableAnchor id="extensions"><div>

## Extensions

You can easily extend Streamr by writing custom modules in Java programming language. When a custom module is activated in a Streamr canvas, your code is executed as if the module were a part of the built-in machinery. As an alternative to custom code, you can also do abstraction, i.e. reuse existing canvases as modules. 

### JavaModule

JavaModule is the tool to use for custom code. Start by creating a new canvas or by opening an existing canvas in the editor. Then insert a JavaModule on the workspace, click on the “Edit code” button, and a code editor will open in a resizable pop-up window. This is what you'll see:

<CodeSnippet language='java' showLineNumbers wrapLines>{JavaModule}</CodeSnippet>

The Java editor contains a code template that you need to fill in with the appropriate components. A custom module consists of inputs, parameters, outputs, an optional state, and a few specific methods. For the magic to happen, you'll need to specify the inputs and outputs and override the relevant methods. We'll go through the components below.

### Inputs and outputs

Module inputs correspond to the endpoints that receive incoming events. On the canvas, they are shown as small circles on the left-hand side of a module. The outputs correspond to the endpoints which send out computed values after module activation. The output endpoints are shown as small circles on the right-hand side of a module.

Inputs and outputs are defined in the beginning of the code template. To help you get started, there's two lines of commented code near the top.

<CodeSnippet language='java' showLineNumbers wrapLines>{InputsAndOutputs}</CodeSnippet>

If you uncomment those lines (as we've done above), you will get a module with one numerical input and one numerical output. If you want to see the result on the canvas, first click the “Apply” button and then the “Close” button. 

<div className={docsStyles.centered}>
  <img src={ModuleOnCanvas} />
</div>

In this example, the inputs belong to the `TimeSeriesInput` class and the outputs to the `TimeSeriesOutput` class. The first argument of an input or output constructor is always `this`, a reference to the current module. The second argument is there for the display name, i.e. a visual label for the endpoint. The variable name on the left-hand side of the assignment can be any valid variable name in Java.

The input and output variables must be unique within a module, but the display names are only labels with no deeper meaning. They don’t have to be unique, and an empty string is a valid name. A common convention is to make the display name equal to the variable name, but this is not a requirement.

You're not limited to numerical endpoints. These are the possible choices for an input event:

- **TimeSeriesInput**: Used for numeric floating point data.
- **BooleanInput**: Used for boolean data.
- **StringInput**: Used for string data.
- **ListInput**: Used for lists (or arrays) of data.
- **MapInput**: Used for key-value pairs.

These are the possible choices for an output event:
- **TimeSeriesOutput**: Used for numeric floating point data.
- **BooleanOutput**: Used for boolean data.
- **StringOutput**: Used for string data.
- **ListOutput**: Used for lists (or arrays) of data.
- **MapOutput**: Used for key-value pairs.

Parameters are just inputs with default values. Such inputs have a distict visual look in the Streamr editor. Because a parameter has a default value, there is no need for an incoming connection in the corresponding endpoint. If there is a connection, however, the custom module should take any parameter changes into account at run-time. Possible parameter types are listed below.

- **BooleanParameter**: Used for boolean values (displayed as a drop-down selection).
- **DoubleParameter**: Used for numeric floating point data (displayed as an input).
- **IntegerParameter**: Used for integers (displayed as an input).
- **StringParameter**: Used for strings (displayed as an input).
- **ColorParameter**: Used for RGB colors (displayed as a color selector).

There’s no limitations on the number of incoming and outgoing connections. An an example, the following code would give you three inputs (one of which is a parameter) and two outputs:

<CodeSnippet language='java' showLineNumbers wrapLines>{InputsAndOutputsExample}</CodeSnippet>

### State and methods

Every Streamr module can have a state. If present, the state persists between module activations and even when a live service is stopped and later restarted. Whilst a module does not need to have a state, there are many streaming data operations which simply cannot be implemented without one.

The state of a module is kept in its *instance variables* (aka *member variables* or *member fields*). Each instance of JavaModule has its own variables, and these are visible and acccessible in that one instance only. You can use any of the valid Java data types for the instance variables. Here's some examples of valid declarations:

<CodeSnippet language='java' showLineNumbers wrapLines>{JavaModuleDeclarations}</CodeSnippet>

Any manipulation of the module state and the generation of module output is handled by JavaModule's methods. There are three methods that you need to override and implement. They are the following:

`initialize()`: This method is called once when a specific JavaModule is activated. This is where you define and initialise the instance variables (i.e. the module state).

`sendOutput()`: This is where you read the incoming events, perform arbitrary calculations, and send events downstream. You can see and alter the module state here.

`clearState()`: This is where you reset the module state. Any module **must** be able to reset itself to its initial state on request. This is typically done by reinitialising the instance variables.

## Custom module example

For the sake of illustration, let's create a new JavaModule. It will be similar to the built-in **Sum**, but instead of keeping a running sum, we'll calculate a running product of successive numerical events.

We'll start with the module inputs and outputs. We only need one numerical input and one output here, so we'll just uncomment the relevant lines:

<CodeSnippet language='java' showLineNumbers wrapLines>{DefiningInputsAndOutputs}</CodeSnippet>

In this example the module state is equal to the current value of the cumulative product. We'll call the state `product` and initialise it by the assignment `product = 1` in the `initialize` method. As discussed, we also need to reset the module to its initial state on request. Let's just redo the initial assignment when the `clearState` method is called.

<CodeSnippet language='java' showLineNumbers wrapLines>{ClearState}</CodeSnippet>

All that's left to do is to write the code to multiply the product by the new incoming event, save the state, and submit the output.

<CodeSnippet language='java' showLineNumbers wrapLines>{IncomingEvent}</CodeSnippet>

The code in a JavaModule is compiled and validated when you click the “Apply” button. Unless there's syntax errors in the code, the module is now ready to use. This is what the output looks like with sample input data:

<div className={docsStyles.centered}>
  <img src={ModuleExampleOnCanvas} />
</div>

<hr />
</div></ScrollableAnchor>
