import cx from 'classnames'
import { Link } from 'react-router-dom'

import Warning from '$docs/components/Warning'
import CodeSnippet from '$shared/components/CodeSnippet'
import links from '$shared/../links'

import CanvasDemo from './images/intro_canvases_01_desktop.jpg'
import CanvasDemo2x from './images/intro_canvases_01_desktop@2x.jpg'

import docsStyles from '$docs/components/DocsLayout/docsLayout.pcss'
import canvasesStyles from '$docs/components/DocsPages/Canvases/canvasesStyles.pcss'

# Intro to canvases
A Streamr canvas is a microservice which consumes and acts upon realtime data. A canvas contains one or more <Link to={links.docs.streams.root}>streams</Link> (these provide the data) and one or more <Link to={links.docs.moduleReference.root}>modules</Link> (these do the processing). Streams and modules are connected in the configuration that you'll design. The connections determine how the data flows through the canvas.

<figure>
    <picture>
      <img
        className={docsStyles.bordered}
        src={CanvasDemo}
        srcSet={`${CanvasDemo2x} 2x`}
        alt="Streamr Canvas"
      />
    </picture>
</figure>

Here's a few examples of specific things you can do;

**Refine real-time data** by routing it through different modules. The built-in module library  includes arithmetic and logical operations. There are also functions for smoothing, sampling, and aggregating streaming data.

**Chain modules together** so that the output from one operation flows as an input to another. This is one way to build arbitrarily complex streaming analytics. If you want to keep things tidy, you can encapsulate the complexity and reuse the abstracted result.

**Visualise the data** by directing it to a charting module. The chart shows the new data in realtime as new events arrive or streaming analytics are computed.

**Communicate with the outside world** by sending text messages or emails when specific conditions are satisfied. You can embed realtime data, refined data, or natural language in the messages.

**Save refined data in another stream.** When you do this, the saved data are instantly accessible as new events. The refined data can be streamed from the platform to external data consumers.

**Post events in HTTP format to external RESTful services.** There's a wide range of popular and useful services out there, and you can use any one of them easily from Streamr.

**Control external devices.** As an example, you can override manual controls and make a remotely operated drone return to base when it's about to go out of range or running low on battery. Because the control interface is likely to be machine specific, this is one case where you'd be looking at coding a custom module in Java.

**Subscribe to a stream in external web pages and applications.** You'll receive every event as soon as it’s available.

There is an extensive <Link to={links.docs.moduleReference.root}>collection</Link> of built-in modules as a source of building blocks. You can abstract modules and re-use them later, and you can code custom modules in Java.

When you're ready to build a canvas, you’ll typically start by adding one or more data <Link to={links.docs.streams.root}>streams</Link> to the canvas workspace. You’ll then create the processing logic by adding modules to the canvas and connecting the streams and modules together. You can do all this interactively by dragging and dropping streams and modules from the module browser to the workspace and then drawing connections between them.
