import ScrollableAnchor from 'react-scrollable-anchor'
import { Link } from 'react-router-dom'

import docsStyles from '$newdocs/components/DocsLayout/docsLayout.pcss'
import links from '$shared/../links'
import CodeSnippet from '$shared/components/CodeSnippet'

import Warning from '$newdocs/components/Warning'

import MessagePartitioningImage from './images/streams/message-partitioning.png'
import StreamAndPartitionsImage from './images/streams/stream-and-partitions.png'

import {
    CreateJavascriptClient,
    CreateJavaClient,
    AuthJavascriptClient,
    AuthJavaClient,
    SubscribeJavascriptClient,
    SubscribeJavaClient,
    PublishJavascriptClient,
    PublishJavaClient,
} from './code/streams.js'

<ScrollableAnchor id="intro-to-streams"><div>

## Intro to streams
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="work-with-streams-in-core"><div>

## Work with streams in Core
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="work-with-streams-via-sdks"><div>

## Work with streams via SDKs

The easiest way to work with streams is to use the JavaScript client, which works in `node.js` as well as the browser. See the <Link to={links.newdocs.SDKs}>SDKs section</Link> for the official and community-maintained client libraries available for various languages:

- **JavaScript** client works in the browser as well as node.js.
- **Java** client is work-in-progress but already implements the most important set of functionality.

Client libraries for other languages are on the <a href={links.community.trello} target="_blank" rel="nofollow noopener noreferrer">roadmap</a>. If a client library isn't available for your language, you can dive into the details of the [websocket protocol](https://github.com/streamr-dev/streamr-client-protocol-js/blob/bb2f0168bcff454b5c458e275e9c2de0dee342f9/PROTOCOL.md).

If you'd like to contribute a client library and get it listed here, please get in touch on <a href={links.community.telegram} target="_blank" rel="nofollow noopener noreferrer">Telegram</a>, <a href={links.community.reddit} target="_blank" rel="nofollow noopener noreferrer">Reddit</a> or <a href={links.contact.general} rel="nofollow noopener noreferrer">email</a>!

### Authentication

When reading from or writing to Streams, you need to provide a session token or an API key, or login with an Ethereum account. To read more about API keys or obtaining a session token, refer to the <Link to={links.newdocs.api}>Authentication section of the API documentation</Link>.

### Creating a client instance with API key

**Javascript**

<CodeSnippet language='javascript'>{CreateJavascriptClient}</CodeSnippet>

**Java**

<CodeSnippet language='java'>{CreateJavaClient}</CodeSnippet>

### Subscribing to real-time events in a stream

By subscribing to Streams, your application gets immediately notified about new events in the Stream.

**JavaScript**

<CodeSnippet language='javascript'>{SubscribeJavascriptClient}</CodeSnippet>

**Java**

<CodeSnippet language='java'>{SubscribeJavaClient}</CodeSnippet>

### Publishing events to Streams

JavaScript:

<CodeSnippet language='javascript'>{PublishJavascriptClient}</CodeSnippet>

Java:

Events in Streams are key-value pairs, represented in Java as Map objects. Below is an example of creating an event payload and publishing it into a Stream:

<CodeSnippet language='java'>{PublishJavaClient}</CodeSnippet>

</div></ScrollableAnchor>

<ScrollableAnchor id="work-with-streams-via-api"><div>

## Work with streams via API
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="data-signing-and-verification"><div>

## Data signing and verification
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="end-to-end-encryption"><div>

## End-to-end encryption
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="partitioning"><div>

## Partitioning

To be precise, when messages are published to a stream, they are actually published to a **partition** within that stream. Partitions can be understood as sub-streams, or in other words, parts of a stream. One partition per stream is the default, which is sufficient for streams with moderate rates of data (approx. less than 100 msg/sec).

However, when a stream needs to handle large data rates, partitions are used for *sharding* the data. This simply means dividing a large volume of messages to multiple partitions, a bit like a large river can split the same amount of water to multiple smaller branches. Each partition shares the general properties of the parent stream, such as name, description, and user permissions, but the partitions behave independently when it comes to delivering and storing data in the Streamr Network, which allows for scalability.

<img src={StreamAndPartitionsImage} />

Partitions also enable subscribers to scale horizontally: a user consuming data from a stream could load balance the messages over a number of consuming processes, up to the number of partitions. So if a stream has 5 partitions, the user could start up to 5 independent subscribers on separate physical machines, with each subscriber receiving different messages (each process subscribes to a unique partition).

Partitions are identified by a number which starts from zero. For example, a stream with only one partition contains the partition `0` and all of the stream's data flows through this partition. A stream with 5 partitions has partitions `0` through `4` - here the stream's data is distributed across these 5 partitions. The data publisher is free to choose the target partition for each message. If no partition is specified, the data goes to partition 0.

Although the partition for a message can be chosen arbitrarily, a popular logic is to utilize a *partition key* - a value chosen from the data which is used to determine the partition of the message. For example, a customer id could be used as a partition key in an application that publishes customer interactions to a stream. This way, all the messages for a particular customer always go to the same partition, which is useful, as it keeps all the events related to a particular customer in a single, known partition instead of spreading them over all partitions.

<img src={MessagePartitioningImage} />

The `publish` methods in the Streamr SDKs usually take an optional `partitionKey` parameter. For example, in the JS client:

```
streamr.publish(stream, message, timestamp, partitionKey)
```

Internally, the library maps the `partitionKey` to a partition number using a hash function (modulo the number of partitions in the stream):

```
partition = hash(partitionKey) % numberOfPartitions
```

<Warning>

At the time of writing, there are some limitations with multi-partition streams: The number of partitions can only be set when creating streams via the API, and the number cannot be changed afterwards. When using multi-partition streams on canvases, the canvases always subscribe to all partitions in a stream.

</Warning>

Currently partitions donâ€™t have well-defined rate limits, but future versions of the P2P network may enforce limits. For now, we recommend not exceeding around 100 msg/sec/partition.

</div></ScrollableAnchor>
