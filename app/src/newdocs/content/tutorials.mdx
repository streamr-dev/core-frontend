
import cx from 'classnames'
import { Link } from 'react-router-dom'

import Warning from '$docs/components/Warning'
import CodeSnippet from '$shared/components/CodeSnippet'
import links from '$shared/../links'
import { formatPath } from '$shared/utils/url'

import CreateStream from './images/tutorials/createStream.png'
import StreamSetup from './images/tutorials/streamSetup.png'
import GetYourAPIKey from './images/tutorials/getYourAPIKey.png'
import SettingsAPICredentials from './images/tutorials/settingsAPICredentials.png'
import Postman from './images/tutorials/postman.png'
import Example2b from './images/tutorials/example2b.png'
import Example3b from './images/tutorials/example3b.png'
import ModuleExampleOnCanvas from './images/canvases/moduleExampleOnCanvas.png'
import JavaModuleOnCanvas from './images/canvases/javaModuleOnCanvas.png'

import { ClientSub, Example1, Example2a, Example3a, PythonRequests } from './code/tutorials.js'

import {
  JavaModule,
  InputsAndOutputs,
  InputsAndOutputsExample,
  JavaModuleDeclarations,
  DefiningInputsAndOutputs,
  ClearState,
  IncomingEvent 
} from './code/canvases.js'

import docsStyles from '$docs/components/DocsLayout/docsLayout.pcss'
import canvasesStyles from '$newdocs/components/DocsPages/Canvases/canvasesStyles.pcss'

<section id="building-a-simple-pub-sub-system">

## Building a simple pub/sub system

The aim of this tutorial is to provide an overview of Streamr basic data flows:

- What a data stream is within the context of Streamr
- How to create a simple pub/sub demo
- Common data integration patterns

By the end of this tutorial, you will learn how to create a stream and publish data to it, and how you can obtain/visualize data by subscribing to a stream. In the near future, we will be providing additional tutorials that will go further in depth about specific topics or use-cases.

### About Streams

In Streamr, each data point belongs to a Stream.  

**Streams** (akin to topics) are an ordered sequence of events (timestamped data points). Depending on the use case, a single Stream could contain data from a single source, or it could be a “firehose” of data from multiple sources.

**Data points** (also called events or messages) are timestamped pieces of information, such as measurements from a sensor, or messages in a chat. 

**Event payloads** are JSON objects, or in other words, a set of key-value pairs. Here’s an example event of a sensor reading:
<CodeSnippet language='json' wrapLines>{
`{
  "temperature": 65.4,
  "humidity": 82,
  "sensorID": KRF29283,
  "sensorLabel": "Rooftop Solar Panel"
}`
}</CodeSnippet>

Streamr ingests this sort of data via an <Link to={formatPath(links.docs.api)}>API</Link>. The easiest way to interact with the API from your own software is by using a Streamr client library. Currently we have a stable client for [JavaScript](https://github.com/streamr-dev/streamr-client-javascript), while there are two more MVP clients, in progress, for [Java](https://github.com/streamr-dev/streamr-client-java) and [Python](https://github.com/streamr-dev/streamr-client-python) suggested for development environment. Other programming languages like Go, C++, C# and more will follow.

If a library isn’t available for your language, you can call the [API endpoints](https://api-explorer.streamr.com) using any HTTP library.

Example using python + requests:

<CodeSnippet language='python'>{PythonRequests}</CodeSnippet>

Example using `curl`:

<CodeSnippet language='bash'>
    {`curl -i -X POST -H "Authorization: Bearer MY-SESSION-TOKEN" -d "{\"foo\":\"hello\",\"bar\":24.5}" https://www.streamr.com/api/v1/streams/MY-STREAM-ID/data`}
</CodeSnippet>

### Create a stream

If you’re already signed in, click Core in the top navigation. If you’re not, sign in and you will be taken to your User Page. From here, go to the Streams tab, and you will see a view something like this one.

<div className={docsStyles.centered}>
  <img src={CreateStream} />
</div>

### Get your Stream ID
From here, click Create Stream. You will be taken to the stream Setup view. First you need to name your stream and write a basic description. The Stream ID will be created for you. Click to copy the ID to clipboard. You’ll need this in order to produce events to your stream via the API. Click Save and Exit to return to your User Page.

<div className={docsStyles.centered}>
  <img src={StreamSetup} />
</div>

### Get your API key

Here you’ll notice the new, but empty stream you’ve created. From your profile menu (top right), choose API Keys. You need this to authenticate to the API.

<div className={docsStyles.centered}>
  <img src={GetYourAPIKey} />
</div>

From **Settings > API Keys**, click to add a new key, and give it a name like Tutorial.  Click the meatball menu to copy the new key and click Save Changes to return to your User Page.

<Warning>

**Only use your tutorial API keys for testing and development.** This ensures you don't accidentally modify a live stream or canvas.

</Warning>

<div className={docsStyles.centered}>
  <img src={SettingsAPICredentials} />
</div>

### Publish to a stream

The easiest way to push data to a stream is to use the [JavaScript client](https://github.com/streamr-dev/streamr-client-javascript), which works in node.js as well as the browser. Client libraries for other languages are on the roadmap. 

You can also try it locally in your browser. Just open this [JS Bin](https://jsbin.com/muqarukubu/edit?js,output), and replace <kbd>MY-STREAM-ID</kbd> and <kbd>MY-API-KEY</kbd> with your Stream ID and API key. Your browser will start producing data to your Stream!

You can also interact with the Streamr API using any HTTP library of your choice. You will find all the details in the <Link to={formatPath(links.docs.api)}>API docs</Link>, but here’s a brief rundown:

You’ll be making <kbd>HTTP POST</kbd> requests to a URL, which contains your Stream ID:
<CodeSnippet language='json' wrapLines >{`https://www.streamr.com/api/v1/streams/MY-STREAM-ID/data`}</CodeSnippet>

The body of the request will be your data payload in JSON.

Add your API key to the HTTP headers as follows:

<CodeSnippet language='json' wrapLines >{`Authorization: token MY-API-KEY`}</CodeSnippet>

This is how a test request would look in the fabulous [Postman](https://www.getpostman.com/) app, with the URL and Authorization header set:

<div className={docsStyles.centered}>
  <img src={Postman} />
</div>

All the different authorization options are explained in the: <Link to={formatPath(links.docs.api)}>API docs</Link>

### Subscribe to data

Along with Publishing data to a stream, this is best done with the [JavaScript client](https://github.com/streamr-dev/streamr-client-javascript) as mentioned above. 

Here is the given example from the Streamr Javascript client [readme](https://github.com/streamr-dev/streamr-client-javascript):

<CodeSnippet language='javascript' wrapLines showLineNumbers >{ClientSub}</CodeSnippet> 

### Patterns for data integration

There are three distinct patterns for connecting data to Streamr, each with their own pros and cons:

**1.** Pushing from the source (ideal)

**2.** Bridging from a streaming source

**3.** Bridging by polling a source

### 1. Pushing from the source

- Simplicity: **Good**
- Latency: **Good**
- Applicability: **Medium**

In this pattern, the data points are sent directly to Streamr by the source as soon as new data becomes available (for example, a sensor produces a new measurement).

**This is the recommended pattern**. However, depending on the circumstances, it may not always be available. It requires that you have control over the system that produces the data and can decide where it gets sent.

For example, if you are an IoT device manufacturer, you could add support for Streamr directly into your devices or gateways, enabling all your end users to easily connect their data to Streamr.

Various industrial data sources usually have good configurability for connecting the data anywhere you need to. However, consumer grade devices such as connected cars, phones, Fitbits, and others often force you to send your data to the manufacturer’s cloud, from where they might serve it back to you via an API. In these cases, you can use one of the bridging patterns in this post (see options two and three).

For a real-world example, here’s how to connect measurements from any number of [Ruuvi](http://ruuvi.com/) IoT tags to Streamr. The devices transmit data over Bluetooth Low Energy to a gateway computer which runs this node.js script. A separate Stream is created for each found Ruuvi device, and the measurements are produced to the appropriate Stream as they occur.

**Example 1: Push from the source example using the JS client**

<CodeSnippet language='javascript' wrapLines showLineNumbers >{Example1}</CodeSnippet>

For a more advanced example, see [this post](https://medium.com/streamrblog/cold-chain-monitoring-with-streamr-ruuvi-and-ethereum-952dacfc47f2) on how to set up a cold chain monitoring demo using Ruuvi tags, Streamr, and Ethereum smart contracts.

If your app is not in JavaScript, you can interact with the API directly using any HTTP library. See the <Link to={formatPath(links.docs.api)}>API docs</Link> for more information and examples.

### 2. Bridging from a streaming source

- Simplicity: **Medium**
- Latency: **Good**
- Applicability: **Medium**

This pattern is useful when you don’t have direct control over the source, but a streaming API or some other kind of listener hook is available for the data. These allow you to be notified whenever new data occurs, enabling you to immediately forward the event to Streamr. Data that is typically available via these kinds of APIs are news feeds, financial market data and social media feeds.

**Example 2a: Streaming bridge example using the JS client**

Here’s an example demonstrating how to bridge DATA/USD market data from the [Bitfinex](https://www.bitfinex.com/) exchange with a node.js script using a Bitfinex client library as well as the Streamr client library:

<CodeSnippet language='javascript' wrapLines showLineNumbers >{Example2a}</CodeSnippet>

**Example 2b: Streaming bridge example using MQTT module on Canvas**

Instead of a program such as the one above, a Canvas process built in the <Link to={formatPath(links.editor.canvasEditor)}>Streamr Editor</Link> can be used to build bridges. This might work for you even if you’re not a programmer, although creating integrations usually still requires some technical understanding of APIs and protocols.

Below is a process which listens to real-time positions of trams from the MQTT API maintained by the Helsinki public transport authority. Incoming events are produced to a Stream in real time.

<div className={docsStyles.centered}>
  <img src={Example2b} />
</div>

In this example the MQTT module parameters are:

<CodeSnippet language='javascript' wrapLines >{`URL: mqtt://mqtt.hsl.fi`}</CodeSnippet>

<CodeSnippet language='javascript' wrapLines >{`Topic: /hfp/v1/journey/ongoing/tram/#`}</CodeSnippet>

The MQTT module outputs JSON strings, which the JsonParser module parses to objects. From the data we extract the <kbd>“VP”</kbd> field, which itself is an object. We read the fields <kbd>“desi”</kbd>, <kbd>“lat”</kbd>, <kbd>“long”</kbd>, and <kbd>“veh”</kbd> and produce those values to a Stream using the SendToStream module.

### 3. Bridging by polling a source

- Simplicity: **Medium**
- Latency: **Medium**
- Applicability: **Good**

Most cloud services handing out data at least offer a request-response-based API, which can be used if neither of the above push-based options are available. In this case there is no way to get notified when new data is available, which means that the API needs to be repeatedly queried. This is called polling.

It’s not an optimal way to serve real-time data, because:

Data can be missed: multiple value changes in between subsequent requests are not observed.
It places an unnecessary load on the API server, as requests are made “just in case” regardless of whether the data has actually changed or not.
An average latency of half the polling interval is introduced.

For the below examples, we’ll query the weather in Zug, Switzerland from [OpenWeatherMap](https://openweathermap.org/) every 15 minutes. For this data, source polling is an acceptable solution for most use cases, since the weather usually doesn’t change rapidly.

**Example 3a: Polling bridge example using the JS client**

<CodeSnippet language='javascript' wrapLines showLineNumbers >{Example3a}</CodeSnippet>

**Example 3b: Polling bridge example using the HTTP module**

As before, using a Canvas is a potential alternative to a self-hosted script such as the one above. Let’s see what an equivalent Canvas would look like:

<div className={docsStyles.centered}>
  <img src={Example3b} />
</div>

Here, the Clock module ticks every 15 minutes and triggers the HTTP Request to get the data from OpenWeatherMap. The fields in the data are delivered to the Stream by the **SendToStream** module.

</section>

<section id="building-custom-canvas-module">

## Building a custom canvas module

You can easily extend Streamr by writing custom modules in the Java programming language. When a custom module is activated in a canvas, your code is executed as if the module were a part of the built-in machinery. As an alternative to custom code, you can also do abstraction, i.e. reuse existing canvases as modules. 

The **Java module** is the module to use for custom code. Start by creating a new canvas or by opening an existing canvas in the editor. Then insert a JavaModule on the workspace, click on the **Edit Code** button, and a code editor will open in a resizable pop-up window. This is what you'll see:

<CodeSnippet language='java' showLineNumbers wrapLines>{JavaModule}</CodeSnippet>

The Java editor contains a code template that you need to fill in with the appropriate components. A custom module consists of inputs, parameters, outputs, an optional state, and a few specific methods. For the magic to happen, you'll need to specify the inputs and outputs and override the relevant methods. 

The custom module's inputs correspond to the endpoints that receive incoming events. On the canvas, they are shown as small circles on the left-hand side of a module. The outputs correspond to the endpoints which send out computed values after module activation. The output endpoints are shown as small circles on the right-hand side of a module.

Inputs and outputs are defined in the beginning of the code template. To help you get started, there's two lines of commented code near the top.

<CodeSnippet language='java' showLineNumbers wrapLines>{InputsAndOutputs}</CodeSnippet>

If you uncomment those lines (as we've done above), you will get a module with one numerical input and one numerical output. If you want to see the result on the canvas, first click **Apply**, then **Close**. 

<div className={cx(docsStyles.centered, canvasesStyles.javaModuleOnCanvas)}>
  <img src={JavaModuleOnCanvas} />
</div>

In this example, the inputs belong to the `TimeSeriesInput` class and the outputs to the `TimeSeriesOutput` class. The first argument of an input or output constructor is always `this`, a reference to the current module. The second argument is there for the display name, i.e. a visual label for the endpoint. The variable name on the left-hand side of the assignment can be any valid variable name in Java.

The input and output variables must be unique within a module, but the display names are only labels with no deeper meaning. They don’t have to be unique, and an empty string is a valid name. A common convention is to make the display name equal to the variable name, but this is not a requirement.

You're not limited to numerical endpoints. These are the possible choices for an input event:

- **TimeSeriesInput**: Used for numeric floating point data.
- **BooleanInput**: Used for boolean data.
- **StringInput**: Used for string data.
- **ListInput**: Used for lists (or arrays) of data.
- **MapInput**: Used for key-value pairs.

These are the possible choices for an output event:
- **TimeSeriesOutput**: Used for numeric floating point data.
- **BooleanOutput**: Used for boolean data.
- **StringOutput**: Used for string data.
- **ListOutput**: Used for lists (or arrays) of data.
- **MapOutput**: Used for key-value pairs.

**Parameters are just inputs with default values.** Because a parameter has a default value, there is no need for an incoming connection in the corresponding endpoint. If there is a connection, however, the custom module should take any parameter changes into account at run-time. Possible parameter types are listed below.

- **BooleanParameter**: Used for boolean values (displayed as a drop-down selection).
- **DoubleParameter**: Used for numeric floating point data (displayed as an input).
- **IntegerParameter**: Used for integers (displayed as an input).
- **StringParameter**: Used for strings (displayed as an input).
- **ColorParameter**: Used for RGB colors (displayed as a color selector).

There’s no limitations on the number of incoming and outgoing connections. An an example, the following code would give you three inputs (one of which is a parameter) and two outputs:

<CodeSnippet language='java' showLineNumbers wrapLines>{InputsAndOutputsExample}</CodeSnippet>

### State and methods

Every Streamr module can have a state. If present, the state persists between module activations and even when a live service is stopped and later restarted. Whilst a module does not need to have a state, there are many streaming data operations which simply cannot be implemented without one.

The state of a module is kept in its *instance variables* (aka *member variables* or *member fields*). Each instance of JavaModule has its own variables, and these are visible and acccessible in that one instance only. You can use any of the valid Java data types for the instance variables. Here's some examples of valid declarations:

<CodeSnippet language='java' showLineNumbers wrapLines>{JavaModuleDeclarations}</CodeSnippet>

Any manipulation of the module state and the generation of module output is handled by JavaModule's methods. There are three methods that you need to override and implement. They are the following:

`initialize()`: This method is called once when a specific JavaModule is activated. This is where you define and initialise the instance variables (i.e. the module state).

`sendOutput()`: This is where you read the incoming events, perform arbitrary calculations, and send events downstream. You can see and alter the module state here.

`clearState()`: This is where you reset the module state. Any module **must** be able to reset itself to its initial state on request. This is typically done by reinitialising the instance variables.

## Custom module example

For the sake of illustration, let's create a new JavaModule. It will be similar to the built-in **Sum**, but instead of keeping a running sum, we'll calculate a running product of successive numerical events.

We'll start with the module inputs and outputs. We only need one numerical input and one output here, so we'll just uncomment the relevant lines:

<CodeSnippet language='java' showLineNumbers wrapLines>{DefiningInputsAndOutputs}</CodeSnippet>

In this example the module state is equal to the current value of the cumulative product. We'll call the state `product` and initialise it by the assignment `product = 1` in the `initialize` method. As discussed, we also need to reset the module to its initial state on request. Let's just redo the initial assignment when the `clearState` method is called.

<CodeSnippet language='java' showLineNumbers wrapLines>{ClearState}</CodeSnippet>

All that's left to do is to write the code to multiply the product by the new incoming event, save the state, and submit the output.

<CodeSnippet language='java' showLineNumbers wrapLines>{IncomingEvent}</CodeSnippet>

The code in a JavaModule is compiled and validated when you click the **Apply** button. Unless there's syntax errors in the code, the module is now ready to use. An easy way to generate an input is to connect the **>Clock module** to a **>Count module**, into a **SendToStream** module. This will input an incrementing number, for every clock tick, 1,2,3 etc. 

This is what the output looks like with sample input data:

<div className={docsStyles.centered}>
  <img src={ModuleExampleOnCanvas} />
</div>



</section>