
import cx from 'classnames'
import { Link } from 'react-router-dom'

import Warning from '$newdocs/components/Warning'
import CodeSnippet from '$shared/components/CodeSnippet'
import { formatPath } from '$shared/utils/url'
import links from '$shared/../links'

import CanvasDemo from './images/canvases/canvasDemo.png'
import RoundToStep from './images/canvases/roundToStep.png'
import TablePopup from './images/canvases/tablePopup.png'
import TableModuleOptions from './images/canvases/tableModuleOptions.png'
import AndModule from './images/canvases/andModule.png'
import InitialValueDialog from './images/canvases/initialValueDialog.png'
import BasicCanvas from './images/canvases/basicCanvas.png'
import BlankCanvasWithArrow from './images/canvases/blankCanvasWithArrow.png'
import HistoricalRealtime from './images/canvases/historicalRealtime.png'
import AddTramStream from './images/canvases/addTramStream.png'
import ModuleBrowser from './images/canvases/moduleBrowser.png'
import ConnectingTypes from './images/canvases/connectingTypes.png'
import ConnectingStreamToModule from './images/canvases/connectingStreamToModule.png'
import StartHistoricalRun from './images/canvases/startHistoricalRun.png'
import PlaybackOptions from './images/canvases/playbackOptions.png'
import StartRealtimeRun from './images/canvases/startRealtimeRun.png'
import StopRealtimeRun from './images/canvases/stopRealtimeRun.png'
import JavaModuleOnCanvas from './images/canvases/javaModuleOnCanvas.png'
import ModuleExampleOnCanvas from './images/canvases/moduleExampleOnCanvas.png'
import CreateCanvasButton from './images/canvases/createCanvasButton.png'
import CoreListing from './images/canvases/coreListing.png'

import {
  JavaModule,
  InputsAndOutputs,
  InputsAndOutputsExample,
  JavaModuleDeclarations,
  DefiningInputsAndOutputs,
  ClearState,
  IncomingEvent 
} from './code/canvases.js'

import docsStyles from '$newdocs/components/DocsLayout/docsLayout.pcss'
import canvasesStyles from '$newdocs/components/DocsPages/Canvases/canvasesStyles.pcss'

<section id="intro-to-canvases">

## Intro to canvases

A Streamr canvas is a microservice which consumes and acts upon realtime data. A canvas contains one or more <Link to={links.newdocs.streams}>streams</Link> (these provide the data) and one or more modules (these do the processing). Streams and modules are connected in the configuration that you'll design. The connections determine how the data flows through the canvas.

<div className={cx(docsStyles.centered, canvasesStyles.canvasDemo)}>
  <img src={CanvasDemo} />
</div>

There's a wide variety of built-in modules in Streamr. Some of those perform basic arithmetic and logical operations, filtering, sampling, aggregation, and so on. Others transform the data in some fashion and feed it to the next stage. Yet other modules interact with the outside world and with external systems.

Computation in Streamr is entirely event-based. **Any module will execute immediately when activated by incoming events.** When new events arrive in the input stream, the data automatically flows through the canvas. This inherently asynchronous process allows for fast and continuous in-memory processing of large volumes of realtime data.

You can also create a service programmatically through the canvas endpoints of the <Link to={links.newdocs.api}>API</Link>. 

### Building a canvas

When you're ready to build a canvas, you’ll typically start by adding one or more data streams to the canvas workspace. You’ll then create the processing logic by adding modules to the canvas and connecting the streams and modules together. You can do all this interactively by dragging and dropping streams and modules from the module browser to the workspace and then drawing connections between them.

When you place a stream on the canvas, you effectively *subscribe* to a realtime data source. To add a stream, just start typing its name in module browser search. The stream name will autocomplete as you type. Realtime events are now available at the output endpoints. There are modules for streaming analytics, visualisation, communication, and many other purposes. You'll find all the built-in components in the **module browser**.

<div className={cx(docsStyles.centered, canvasesStyles.moduleBrowser)}>
  <img src={ModuleBrowser} />
</div>

As a simple example, here's a canvas consisting of one stream and a chart module connected together. When you run the canvas, the events flow from the stream to the chart, and the chart draws the data points as they arrive.

<div className={docsStyles.centered}>
  <img src={BasicCanvas} />
</div>

### Adding modules

If you already know the name of the module you need, type its name in the search box, then select the right module or stream, or drag it into your workspace.

<div className={cx(docsStyles.centered, canvasesStyles.AddTramStream)}>
  <img src={AddTramStream} />
</div>

You can move modules around on the workspace as you wish, the placement of a module has no impact on functionality. For clarity, you may want to design the canvas so that module placement reflects the data flow from the input streams through the modules.

### Connecting modules

A data flow between two modules — or a data flow between a stream and a module — is created by drawing a connection from an outgoing endpoint (port) to an incoming endpoint. You can create as many outgoing connections as you wish. You can only have one incoming connection per an endpoint.

Along with **inputs** and **outputs, there is also **parameters**. **Parameters are just inputs with default values.** Because a parameter has a default value, there is no need for an incoming connection in the corresponding endpoint.

<div className={docsStyles.centered}>
  <img src={ConnectingStreamToModule} />
</div>

You can only connect endpoints with compatible data types. As you hold your mouse down, compatible connections will glow green and incompatible connections glow red. For instance, you cannot create a connection which feeds string events to an endpoint where numerical events are expected. There are conversion modules such as *StringToNumber* which can if you get stuck with the wrong data type.

<div className={docsStyles.centered}>
  <img src={ConnectingTypes} />
</div>

<Warning>

**Module logic rules**

- Any non-boolean events are automatically converted to logical truth values if a boolean input is required. 
- Numbers exactly equal to zero are deemed to be False, and any non-zero values True.
- An empty string ("") is False, a non-empty string is True. 
- An empty list is False, a non-empty list is True. 
- An empty Map is False, and anything else is True.

</Warning>

All connections are unidirectional, i.e. the data always flows from an output to one or more inputs in one direction only. The modules form a directed graph. Feedback loops are discouraged, but you can create them if you really want.

You can alter the endpoint of an existing connection by dragging it to another input endpoint. If you instead drop the endpoint in an empty area in the workspace, the connection is cleared. Right clicking on top of a module port will bring up a pop-up menu with the option to disconnect all incoming connections to the module.

The topology of a service can be arbitrarily complex. You can of course design a simple sequential work flow, and in many cases it will be perfectly adequate. In other cases the flow of data may involve merging data pathways, branches and even loops. Go ahead, be adventurous, but also bear in mind Streamr's abstraction capabilities. Reusing existing canvases will help you manage the development process and keep things tidy and neat.

### How to run your canvas

You can run your canvas in one of two ways - **historical** or **realtime** mode.

<div className={docsStyles.centered}>
  <img src={HistoricalRealtime} />
</div>

- The **realtime mode** (default mode) is used in production where you want to react to events as they arrive. There's no need to modify the canvas in order to run it live. One click is all it takes to activate the microservice and start consuming realtime data.
- In **historical mode**, running a canvas is a playback of what has happened in a past date range. A playback can be extremely useful when you’re testing, refining, or demonstrating the functionality of a canvas.

There's a natural iterative workflow where you first build a perhaps rudimentary version of a canvas, test it with historical data where possible, refine the design based on the test findings, and repeat until you're happy.

### Running a realtime canvas

When you run a canvas in *realtime mode*, it will listen to realtime events arriving in the subscribed streams, and process them as soon as they're available. When the canvas is running you won't be able to edit it, if you need to make changes, you'll need to stop the canvas and then restart it.

<div className={cx(docsStyles.centered, canvasesStyles.startRealtimeRun)}>
  <img src={StartRealtimeRun} />
</div>

A live canvas keeps running until you explictly tell it to stop. When you stop a canvas, its internal state is saved on the disk. If you later restart the canvas, it will gracefully resume from the point where it stopped. It will not, however, process any events that occurred when it was not running.

<div className={cx(docsStyles.centered, canvasesStyles.stopRealtimeRun)}>
  <img src={StopRealtimeRun} />
</div>

### Running a historical canvas

<div className={cx(docsStyles.centered, canvasesStyles.startHistoricalRun)}>
  <img src={StartHistoricalRun} />
</div>

A canvas run in historical mode consumes a playback of past events stored in the subscribed streams. The playback is a simulation of what has happened in the past. You may run the canvas in historical mode provided the streams inside the canvas contain some historical data.

You can specify the time period (the start date and the end date) for the historical playback period as well as the speed of playback. By default, playback events are processed sequentially but at a much faster pace compared to the actual history. You can easily change the playback speed for the historical run. Click on the arrow menu icon, connected to the **Run** button to choose your desired playback speed.

The playback starts when you press the **Run** button.

<div className={cx(docsStyles.centered, canvasesStyles.playbackOptions)}>
  <img src={PlaybackOptions} />
</div>

### Reusing canvases as modules

You can easily reuse a canvas as a component of another canvas. This is done via *abstraction*, where you encapsulate a canvas as a module. You can then use the new module when you build additional canvases.

To create an abstraction, you'll need to expose — or export — inputs and outputs. The exported endpoints will show up as endpoints of the abstracted canvas.

### Custom modules

You can easily extend Streamr by writing custom modules in Java programming language. When a custom module is activated in a canvas, your code is executed as if the module were a part of the built-in machinery. As an alternative to custom code, you can also do abstraction, i.e. reuse existing canvases as modules. 

The *Java module* is the module to use for custom code. Start by creating a new canvas or by opening an existing canvas in the editor. Then insert a JavaModule on the workspace, click on the “Edit Code” button, and a code editor will open in a resizable pop-up window. This is what you'll see:

<CodeSnippet language='java' showLineNumbers wrapLines>{JavaModule}</CodeSnippet>

The Java editor contains a code template that you need to fill in with the appropriate components. A custom module consists of inputs, parameters, outputs, an optional state, and a few specific methods. For the magic to happen, you'll need to specify the inputs and outputs and override the relevant methods. 

The custom module's inputs correspond to the endpoints that receive incoming events. On the canvas, they are shown as small circles on the left-hand side of a module. The outputs correspond to the endpoints which send out computed values after module activation. The output endpoints are shown as small circles on the right-hand side of a module.

Inputs and outputs are defined in the beginning of the code template. To help you get started, there's two lines of commented code near the top.

<CodeSnippet language='java' showLineNumbers wrapLines>{InputsAndOutputs}</CodeSnippet>

If you uncomment those lines (as we've done above), you will get a module with one numerical input and one numerical output. If you want to see the result on the canvas, first click **Apply**, then **Close**. 

<div className={cx(docsStyles.centered, canvasesStyles.javaModuleOnCanvas)}>
  <img src={JavaModuleOnCanvas} />
</div>

In this example, the inputs belong to the `TimeSeriesInput` class and the outputs to the `TimeSeriesOutput` class. The first argument of an input or output constructor is always `this`, a reference to the current module. The second argument is there for the display name, i.e. a visual label for the endpoint. The variable name on the left-hand side of the assignment can be any valid variable name in Java.

The input and output variables must be unique within a module, but the display names are only labels with no deeper meaning. They don’t have to be unique, and an empty string is a valid name. A common convention is to make the display name equal to the variable name, but this is not a requirement.

You're not limited to numerical endpoints. These are the possible choices for an input event:

- **TimeSeriesInput**: Used for numeric floating point data.
- **BooleanInput**: Used for boolean data.
- **StringInput**: Used for string data.
- **ListInput**: Used for lists (or arrays) of data.
- **MapInput**: Used for key-value pairs.

These are the possible choices for an output event:
- **TimeSeriesOutput**: Used for numeric floating point data.
- **BooleanOutput**: Used for boolean data.
- **StringOutput**: Used for string data.
- **ListOutput**: Used for lists (or arrays) of data.
- **MapOutput**: Used for key-value pairs.

**Parameters are just inputs with default values.** Because a parameter has a default value, there is no need for an incoming connection in the corresponding endpoint. If there is a connection, however, the custom module should take any parameter changes into account at run-time. Possible parameter types are listed below.

- **BooleanParameter**: Used for boolean values (displayed as a drop-down selection).
- **DoubleParameter**: Used for numeric floating point data (displayed as an input).
- **IntegerParameter**: Used for integers (displayed as an input).
- **StringParameter**: Used for strings (displayed as an input).
- **ColorParameter**: Used for RGB colors (displayed as a color selector).

There’s no limitations on the number of incoming and outgoing connections. An an example, the following code would give you three inputs (one of which is a parameter) and two outputs:

<CodeSnippet language='java' showLineNumbers wrapLines>{InputsAndOutputsExample}</CodeSnippet>

### State and methods

Every Streamr module can have a state. If present, the state persists between module activations and even when a live service is stopped and later restarted. Whilst a module does not need to have a state, there are many streaming data operations which simply cannot be implemented without one.

The state of a module is kept in its *instance variables* (aka *member variables* or *member fields*). Each instance of JavaModule has its own variables, and these are visible and acccessible in that one instance only. You can use any of the valid Java data types for the instance variables. Here's some examples of valid declarations:

<CodeSnippet language='java' showLineNumbers wrapLines>{JavaModuleDeclarations}</CodeSnippet>

Any manipulation of the module state and the generation of module output is handled by JavaModule's methods. There are three methods that you need to override and implement. They are the following:

`initialize()`: This method is called once when a specific JavaModule is activated. This is where you define and initialise the instance variables (i.e. the module state).

`sendOutput()`: This is where you read the incoming events, perform arbitrary calculations, and send events downstream. You can see and alter the module state here.

`clearState()`: This is where you reset the module state. Any module **must** be able to reset itself to its initial state on request. This is typically done by reinitialising the instance variables.

## Custom module example

For the sake of illustration, let's create a new JavaModule. It will be similar to the built-in **Sum**, but instead of keeping a running sum, we'll calculate a running product of successive numerical events.

We'll start with the module inputs and outputs. We only need one numerical input and one output here, so we'll just uncomment the relevant lines:

<CodeSnippet language='java' showLineNumbers wrapLines>{DefiningInputsAndOutputs}</CodeSnippet>

In this example the module state is equal to the current value of the cumulative product. We'll call the state `product` and initialise it by the assignment `product = 1` in the `initialize` method. As discussed, we also need to reset the module to its initial state on request. Let's just redo the initial assignment when the `clearState` method is called.

<CodeSnippet language='java' showLineNumbers wrapLines>{ClearState}</CodeSnippet>

All that's left to do is to write the code to multiply the product by the new incoming event, save the state, and submit the output.

<CodeSnippet language='java' showLineNumbers wrapLines>{IncomingEvent}</CodeSnippet>

The code in a JavaModule is compiled and validated when you click the **Apply** button. Unless there's syntax errors in the code, the module is now ready to use. This is what the output looks like with sample input data:

<div className={docsStyles.centered}>
  <img src={ModuleExampleOnCanvas} />
</div>

</section>

<section id="work-with-canvases-in-core">

## Work with canvases in Core

To create a new canvas, click on 'Create Canvas' inside the canvas listing Core page.

<div className={docsStyles.centered}>
  <img src={CreateCanvasButton} />
</div>

You'll see all of your canvases (and their running state) in the <Link to={links.userpages.canvases}>Canvases page</Link> inside the Core app. Click on a canvas to open it in the editor. You can then stop it (if it is live) or launch it live (if it is stopped).

<div className={docsStyles.centered}>
  <img src={CoreListing} />
</div>

</section>

<section id="building-integrations">

## Building integrations
***Documentation coming soon***

</section>

<section id="ethereum-modules">

## Ethereum modules
***Documentation coming soon***

</section>